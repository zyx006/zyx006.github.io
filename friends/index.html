<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="君绾墨的博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>君绾墨的blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1609991782159">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>君绾墨的blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">君绾墨</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>在校大学生一枚</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">2</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://czyx007.top/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/zyx006">
              <i class="fa fa-github-alt" title="Github"></i>
            </a>
          
            <a href="https://qm.qq.com/cgi-bin/qm/qr?k=I2jkn0dziL9o-T2Xcm7NG16jZzvoP7fy&amp;noverify=0">
              <i class="fa fa-qq" title="QQ"></i>
            </a>
          
        
        
      </div>
    </div>
  


</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box gemini box-shadow-wrapper">
          <section class="friends-section bg-color slide-down-in">
            <div class="firends-box">
              <h1 class="firends-title" itemprop="name headline">友情链接</h1>
              
              
              
            </div>
            <hr>
            <div style="text-align:center">
              <span class="with-love">
                <i class="fa fa-heart"></i>
              </span>
              留言添加友链
              <span class="with-love">
                <i class="fa fa-heart"></i>
              </span>
            </div>
            <hr>
            <div class="friends-note">
              <p><strong>友链格式：</strong></p>
              <ul>
                <li>网站名称：枫糖</li>
                <li>网站地址：<a href="https://blog.maplesugar.space" data-pjax-state="">https://blog.maplesugar.space</a>
                </li>
                <li> 网站描述：From rookie to master</li>
                <li> 网站 Logo / 头像：<a href="https://blog.maplesugar.space/uploads/maple-leaf-avatar.jpg"
                    data-pjax-state="">https://blog.maplesugar.space/uploads/maple-leaf-avatar.jpg</a></li>
              </ul>
            </div>
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.4/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('https://upimage.alexhchu.com/2020/04/21/47eda59424daa.gif');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'I2glXAwPdvDE1Re5gNIXP4gz-gzGzoHsz',
    appKey: 'c6Sjq0TH6GiGiKzO1DOOTvqY',
    avatar: '',
    placeholder: '撰写评论…',
    pageSize: '',
    lang: 'zh-cn',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      ©2020-2021 君绾墨
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    <div class="bg-img">
      <img src="https://gitee.com/gentlemans_ink/blogimage/raw/master/img/20210103124339.jpg" />
    </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://czyx007.top/post/han-jia-hui-gui-da-li-bao-ti-jie/"" data-c="
          &lt;p&gt;时间跨度：01-04 17:46:10 ~ 01-06 23:01:46&lt;/p&gt;
&lt;p&gt;关键知识点：&lt;strong&gt;高精度&lt;/strong&gt;，斐波那契数列&lt;/p&gt;
&lt;p&gt;部分新增知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C语言内置函数__builtin__popcount();&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字之间的关系&lt;/strong&gt;，&lt;strong&gt;质数的性质&lt;/strong&gt;（数论？）&lt;!-- more --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;t1-标题统计&#34;&gt;T1 标题统计&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5015&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;获取一整行字符串后计算除空格和换行符以外的字符数即可&lt;/p&gt;
&lt;h3 id=&#34;ac代码&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    string str;
    getline(cin,str);
    
    int cnt = 0;
    for(auto i:str)
    if(i != &#39; &#39; &amp;amp;&amp;amp; i != &#39;\n&#39;)
        cnt++;
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t2-davor&#34;&gt;T2 Davor&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4956&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-2&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;用等差数列求出每星期筹到的金钱总额乘以总周数52，若刚好等于n则输出并中断。&lt;br&gt;
为了满足 x 尽可能大，k 尽可能小，应使x从100开始倒序循环。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-2&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);

    for(int x = 100; x &amp;gt;= 1; x--)
    {
        for(int k = 1;k &amp;lt; 3000; k++)
        {
            int cnt = 52 * (x + x+6*k)*7/2;
            if(cnt == n)
            {
                printf(&amp;quot;%d\n%d&amp;quot;,x,k);
                return 0;
            }
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t3-语句解析&#34;&gt;T3 语句解析&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1597&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-3&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;按照题面所给的语句格式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;变量 := 变量或一位整数;&lt;br&gt;
逐字扫描判断，以分号作为分隔符进行逐句赋值，未赋值的变量以初始值0作为终值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ac代码-3&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    string str;
    cin &amp;gt;&amp;gt; str;

    int a = 0,b = 0,c = 0;
    for(int i = 0; i &amp;lt; str.length(); i++)
    {
        if(str[i] == &#39;a&#39;)
        {
            int j = i;
            while(str[j] !=&#39;;&#39;)j++;
            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)
                a = (str[j-1]-&#39;0&#39;);
            else
            {
                if(str[j-1] == &#39;b&#39;)
                    a = b;
                else if(str[j-1] == &#39;c&#39;)
                    a = c;
            }
            i = j;
        }
        else if(str[i] == &#39;b&#39;)
        {
            int j = i;
            while(str[j] !=&#39;;&#39;)j++;
            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)
                b = (str[j-1]-&#39;0&#39;);
            else
            {
                if(str[j-1] == &#39;a&#39;)
                    b = a;
                else if(str[j-1] == &#39;c&#39;)
                    b = c;
            }
            i = j;
        }
        else if(str[i] == &#39;c&#39;)
        {
            int j = i;
            while(str[j] !=&#39;;&#39;)j++;
            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)
                c = (str[j-1]-&#39;0&#39;);
            else
            {
                if(str[j-1] == &#39;a&#39;)
                    c = a;
                else if(str[j-1] == &#39;b&#39;)
                    c = b;
            }
            i = j;
        }
    }
    printf(&amp;quot;%d %d %d&amp;quot;,a,b,c);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t4-数楼梯&#34;&gt;T4 数楼梯&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1255&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-4&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;本题关键知识点：&lt;strong&gt;高精度&lt;/strong&gt;，&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;br&gt;
从前几阶楼梯可以发现，上到每节楼梯的走法数分别为1,2,3,5，……，显然就是去掉第一项后的斐波那契列&lt;br&gt;
但题目数据范围N &amp;lt;= 5000,斐波那契数列的值呈指数级爆炸增长，因而要使用高精度防止数据溢出。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-4&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

const int MAXN = 5010;

int a[MAXN],b[MAXN],c[MAXN];

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);

    if(n &amp;lt; 3)
        printf(&amp;quot;%d&amp;quot;,n);
    else
    {
        int cnt = 1;
        a[1] = 1,b[1] = 2;
        for(int i = 3; i &amp;lt;= n; i++)
        {
            for(int j = 1; j &amp;lt;= cnt; j++)
                c[j] = a[j]+b[j];
            for(int j = 1; j &amp;lt;= cnt; j++)
            {
                if(c[j] &amp;gt; 9)
                {
                    c[j+1] += c[j]/10;
                    c[j] %= 10;
                    if(j+1 &amp;gt; cnt)
                        cnt++;
                }
            }
            for(int j = 1; j &amp;lt;= cnt; j++)
                a[j] = b[j];
            for(int j = 1; j &amp;lt;= cnt; j++)
                b[j] = c[j];
        }
        for(int i = cnt;i &amp;gt; 0;i--)
            printf(&amp;quot;%d&amp;quot;,b[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t5-分数线划定&#34;&gt;T5 分数线划定&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1068&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-5&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;用结构体存储每名选手的报名号和成绩，然后依照提议解题即可，要注意cmp函数的写法。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-5&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

struct peo
{
    int id,score;
};

bool cmp(const peo &amp;amp;p1,const peo &amp;amp;p2)
{
    if(p1.score != p2.score)
        return p1.score &amp;gt; p2.score;
    else
        return p1.id &amp;lt; p2.id;
}

int main()
{
    int n,m;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);
    int num = m * 1.5;
    struct peo p[n];

    for(int i = 0; i &amp;lt; n; i++)
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;p[i].id,&amp;amp;p[i].score);
    sort(p,p+n,cmp);

    int line = p[num-1].score,cnt = 0;
    for(int i = 0; p[i].score &amp;gt;= line; i++)
        cnt++;
    printf(&amp;quot;%d %d\n&amp;quot;,line,cnt);
    for(int i = 0; i &amp;lt; cnt; i++)
        printf(&amp;quot;%d %d\n&amp;quot;,p[i].id,p[i].score);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t6-涂国旗&#34;&gt;T6 涂国旗&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3392&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-6&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;预处理存储每行R/W/B三种颜色的块数，之后暴力O(n^2)枚举前两种颜色的行数(第三种颜色为剩下的行数)，用m减去某行某颜色的块数既得该行的成本，取得每次成本总和的最小值即可。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-6&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

struct color
{
    int white,blue,red;
};

int main()
{
    int n,m;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);
    
    char ch[n][m];
    struct color c[n];

    for(int i = 0; i &amp;lt; n; i++)
    {
        int w = 0,b = 0,r = 0;
        for(int j = 0; j &amp;lt; m; j++)
        {
            scanf(&amp;quot; %c&amp;quot;,&amp;amp;ch[i][j]);
            switch(ch[i][j])
            {
                case &#39;W&#39;:
                    w++;
                    break;
                case &#39;R&#39;:
                    r++;
                    break;
                case &#39;B&#39;:
                    b++;
                    break;
            }
        }
        c[i].white = w;
        c[i].blue = b;
        c[i].red = r;
    }

    int cnt = 1e7;
    for(int i = 1; i &amp;lt;= n-2; i++)
    {
        for(int j = i+1; j &amp;lt;= n-1; j++)
        {
            int sum = 0;
            for(int k = 1; k &amp;lt;= i; k++)
                sum += (m-c[k-1].white);
            for(int k = i+1; k &amp;lt;= j; k++)
                sum += (m-c[k-1].blue);
            for(int k = j+1; k &amp;lt;= n; k++)
                sum += (m-c[k-1].red);
            cnt = min(cnt,sum);
        }
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t7-拼数&#34;&gt;T7 拼数&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1012&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-7&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;将所有数字按字典序顺序降序排列后拼接即可。要注意cmp函数不能直接判断两字符串&lt;br&gt;
&lt;s&gt;return s1 &amp;gt; s2;&lt;/s&gt;&lt;br&gt;
&lt;u&gt;return s1+s2 &amp;gt; s2+s1;&lt;/u&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;详见代码中注释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ac代码-7&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

vector&amp;lt;string&amp;gt; v; 

bool cmp(const string &amp;amp;s1,const string &amp;amp;s2)
{
    /*
    若用s1 &amp;gt; s2,则结果为321 32 -&amp;gt;32132,但最大应为32321
    使用s1+s2 &amp;gt; s2+s1则可避免这种32132&amp;gt;32321的情况 
    */
    return s1+s2 &amp;gt; s2+s1;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    for(int i = 0;i &amp;lt; n;i++)
    {
        string str;
        cin &amp;gt;&amp;gt; str;
        v.push_back(str);
    }
    sort(v.begin(),v.end(),cmp);
    for(auto i:v)
        cout &amp;lt;&amp;lt; i;
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t8-烤鸡&#34;&gt;T8 烤鸡&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2089&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-8&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;直接暴力枚举10种配料的所有搭配方案，若质量总和等于n则保存，等待输出。注意每种配料的质量都不能为0。&lt;br&gt;
(由于配料质量和的最大值只有30，所以n &amp;gt; 30的可以直接输出0)&lt;/p&gt;
&lt;h3 id=&#34;ac代码-8&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
//typedef long long ll;

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; v;
vector&amp;lt;int&amp;gt; vs;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    
    int cnt = 0;
    for(int q = 1;q &amp;lt;= 3;q++)
    for(int w = 1;w &amp;lt;= 3;w++)
    for(int e = 1;e &amp;lt;= 3;e++)
    for(int r = 1;r &amp;lt;= 3;r++)
    for(int t = 1;t &amp;lt;= 3;t++)
    for(int y = 1;y &amp;lt;= 3;y++)
    for(int u = 1;u &amp;lt;= 3;u++)
    for(int i = 1;i &amp;lt;= 3;i++)
    for(int o = 1;o &amp;lt;= 3;o++)
    for(int p = 1;p &amp;lt;= 3;p++)
        if(q+w+e+r+t+y+u+i+o+p == n)
        {
            vs.push_back(q);
            vs.push_back(w);
            vs.push_back(e);
            vs.push_back(r);
            vs.push_back(t);
            vs.push_back(y);
            vs.push_back(u);
            vs.push_back(i);
            vs.push_back(o);
            vs.push_back(p);
            v.push_back(vs);
            vs.clear();
            cnt++;
        }
    
    printf(&amp;quot;%d\n&amp;quot;,cnt);
    for(auto i:v)
    {
        for(auto j:i)
            printf(&amp;quot;%d &amp;quot;,j);
        printf(&amp;quot;\n&amp;quot;);
    }
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t9-独木桥&#34;&gt;T9 独木桥&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1007&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-9&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;首先，不用考虑题目中的这一因素的影响：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引用洛谷题解中很形象的两个例子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先自行脑补一下，假装你正在20000米高空的轰炸机上用高倍显微镜望远镜默默欣赏士兵离开，你会发现什么东西？一堆花花绿绿的迷彩服在移动。（不是鬼片！不是鬼片！不是鬼片！重要的事情说三遍）&lt;br&gt;
那么当两个士兵撞在一起时，从你的视角看会发生什么？当然他们认为他们都掉头了，但因为你在特高的地方，你会认为他们“穿过”了对方。换言之，这与他们相互穿过并没有任何区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;两个人相遇转身，相当于交换灵魂后继续走&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么问题就很简单了，最大值就是最靠近端点的两个人各自向对方方向走下桥,时间较长的那个人的时间，最小值就是所有人走完桥的时间的最小值的最大值。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-9&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int l,n;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;n);
    
    int pos[n]={0};
    for(int i = 0;i &amp;lt; n;i++)
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;pos[i]);
    sort(pos,pos+n,greater&amp;lt;int&amp;gt;());
    int ma = max(pos[0],l-pos[n-1]+1);
    int mi = 0;
    for(int i = 0;i &amp;lt; n;i++)
    {
        int tmp = min(pos[i],l-pos[i]+1);
        mi = max(tmp,mi);
    }
    printf(&amp;quot;%d %d&amp;quot;,mi,ma);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t10-first-step-ファーストステップ&#34;&gt;T10 First Step (ファーストステップ)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3654&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-10&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;枚举每个可站点，判断该点向右方和向下方各有多少种站位方式&lt;br&gt;
要注意k=1的情况下，横着站和竖着站一样，因而要进行特判，此时站位方式数量就是可站点的数量。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-10&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int r,c,k;
    scanf(&amp;quot;%d %d %d&amp;quot;,&amp;amp;r,&amp;amp;c,&amp;amp;k);

    int po = 0;
    char gym[r][c];
    for(int i = 0; i &amp;lt; r; i++)
        for(int j = 0; j &amp;lt; c; j++)
        {
            scanf(&amp;quot; %c&amp;quot;,&amp;amp;gym[i][j]);
            if(gym[i][j] == &#39;.&#39;)
                po++;
        }

    if(k == 1)
    {
        printf(&amp;quot;%d&amp;quot;,po);
        return 0;
    }
    int cnt = 0,sum = 0;
    for(int i = 0; i &amp;lt; r; i++)
    {
        for(int j = 0; j &amp;lt; c; j++)
        {
            if(gym[i][j] == &#39;.&#39;)
            {
                if(i &amp;lt; r-1)
                {
                    sum = 0;
                    for(int q = j; q &amp;lt; c; q++)
                    {
                        if(gym[i][q] == &#39;.&#39;)
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                    sum = 0;
                    for(int q = i; q &amp;lt; r; q++)
                    {
                        if(gym[q][j] == &#39;.&#39;)
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                }
                else
                {
                    sum = 0;
                    for(int q = j; q &amp;lt; c; q++)
                    {
                        if(gym[i][q] == &#39;.&#39;)
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                }
            }
        }
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t11-蜜蜂路线&#34;&gt;T11 蜜蜂路线&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2437&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-11&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1255&#34;&gt;类似题目 T4数楼梯&lt;/a&gt;&lt;br&gt;
本题需用到&lt;strong&gt;高精度&lt;/strong&gt;和&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;br&gt;
不同的是本题中最终结果并不是从斐波那契数列第一项加起，它的起始项(左端点)是变化的。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-11&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
//typedef long long ll;

const int MAXN = 5010;

int a[MAXN]= {1,1},b[MAXN]= {1},c[MAXN];

int main()
{
    int m,n;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;m,&amp;amp;n);

    for(int i = m+1; i &amp;lt;= n; i++)
    {
        for(int j = 0; j &amp;lt;= a[0]; j++)
            c[j] = a[j];
        for(int j = 1; j &amp;lt;= a[0]; j++)
        {
            a[j] += b[j];
            a[j+1] += a[j]/10;
            a[j] %= 10;
        }
        while(a[a[0]+1]&amp;gt;0)
            a[0]++;
        memset(b,sizeof(b),0);
        for(int j = 0; j &amp;lt;= c[0]; j++)
            b[j] = c[j];
    }
    for(int i = a[0]; i &amp;gt;= 1; i--)
        printf(&amp;quot;%d&amp;quot;,a[i]);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t12-最大公约数和最小公倍数问题&#34;&gt;T12 最大公约数和最小公倍数问题&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1029&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-12&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;以x,y为端点进行O(n^2) 枚举,由于本题数据范围是10^5,为了防止TLE需要进行优化，只用枚举max(x,y)的所有因子即可。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-12&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
//typedef long long ll;

vector&amp;lt;int&amp;gt; v;
void getnum(int a);

int main()
{
    int x,y;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x,&amp;amp;y);
    
    getnum(max(x,y));
    
    int cnt = 0,size = v.size();
    for(int i = 0;i &amp;lt; size;i++)
    {
        for(int j = size-1;j &amp;gt;= 0;j--)
        {
            int gnum = __gcd(v[i],v[j]);
            int LCD = (v[i] * v[j]) / gnum;
            if(gnum == x &amp;amp;&amp;amp; LCD == y)
                cnt++;
        }
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
}

void getnum(int a)
{
    for(int i = 1;i &amp;lt;= a;i++)
        if(a % i == 0)
            v.push_back(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t13-种田&#34;&gt;T13 种田&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2660&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-13&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2241&#34;&gt;类似题目：第四周提单 统计方形&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不同的是，上题是统计所有方形的数量，而这题是每次切割最大正方形，每次以最短边为边长切割，体力值即为每次所切割的正方形的周长之和。但单单这样写会在最后一个测试点被10^16的数据卡TLE，只能拿90分，因而要进行优化，不能一个正方形一个正方形的切，要一次切多个，也就是切max(x,y)/min(x,y)个。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-13&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef long long ll;

int main()
{
    ll n,m;
    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;m);

    ll res = 0;
    while(n != 0 &amp;amp;&amp;amp; m != 0)
    {
        ll mi = min(n,m);
        if(n &amp;lt; m)
        {
            res += 4 * (m/mi) * mi;
            m %= mi;
        }
        else
        {
            res += 4 * (n/mi) * mi;
            n %= mi;
        }
    }
    printf(&amp;quot;%lld&amp;quot;,res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t14-混合牛奶-mixing-milk&#34;&gt;T14 混合牛奶 Mixing Milk&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1208&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-14&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;用结构体存储每位农民的单价和最大量，按单价从低到高进行排序，依次购买直至购买量等于所需量时即求出最小费用。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-14&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

struct farmer{
    int price,sum;	
};

bool cmp(const farmer &amp;amp;f1,const farmer &amp;amp;f2)
{
    return f1.price &amp;lt; f2.price;
}

int main()
{
    int n,m;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);
    struct farmer f[m];
    
    for(int i = 0;i &amp;lt; m;i++)
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;f[i].price,&amp;amp;f[i].sum);
    sort(f,f+m,cmp);
    
    int su = 0,money = 0;
    for(int i = 0;i &amp;lt; m;i++)
    {
        if(su + f[i].sum &amp;lt;= n)
        {
            su += f[i].sum;
            money += f[i].price * f[i].sum;
        }
        else
        {
            money += f[i].price * (n - su);
            break;
        }
    }
    printf(&amp;quot;%d&amp;quot;,money);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t15-排队&#34;&gt;T15 排队&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5412&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-15&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;结构体存储按身高从矮到高排序，最后用cout输出即可。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-15&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

struct stu
{
    int sex;
    double height;
};

bool cmp(const stu &amp;amp;s1,const stu &amp;amp;s2)
{
    return s1.height &amp;lt; s2.height;
}

int main()
{
    int t;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
    while(t--)
    {
        int n;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
        struct stu s[n];
        for(int i = 0; i &amp;lt; n; i++)
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;s[i].sex);
        for(int i = 0; i &amp;lt; n; i++)
            scanf(&amp;quot;%lf&amp;quot;,&amp;amp;s[i].height);
        
        sort(s,s+n,cmp);
        for(int i = 0; i &amp;lt; n; i++)
            if(s[i].sex == 0)
                cout &amp;lt;&amp;lt; s[i].height &amp;lt;&amp;lt; &#39; &#39;;
        printf(&amp;quot;\n&amp;quot;);
        for(int i = 0; i &amp;lt; n; i++)
            if(s[i].sex == 1)
                cout &amp;lt;&amp;lt; s[i].height &amp;lt;&amp;lt; &#39; &#39;;
        printf(&amp;quot;\n&amp;quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t16-小a的糖果&#34;&gt;T16 小A的糖果&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3817&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-16&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;从左到右依次遍历，若左右之和大于x则将&lt;strong&gt;右侧数&lt;/strong&gt;减去&lt;strong&gt;两数之和与x的差&lt;/strong&gt; ，结果即为每次该差的总和。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-16&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef long long ll;

int main()
{
    ll n,x;
    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;x);
    ll num[n] = {0};
    
    for(int i = 0;i &amp;lt; n;i++)
        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;num[i]);
        
    ll cnt = 0;
    for(ll i = 0;i &amp;lt; n-1;i++)
    {
        if(num[i] + num[i+1] &amp;gt; x)
        {
            cnt += num[i]+num[i+1]-x;
            num[i+1] -= num[i]+num[i+1]-x;
        }
    }
    printf(&amp;quot;%lld&amp;quot;,cnt);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t17-阶乘之和&#34;&gt;T17 阶乘之和&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1009&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-17&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;高精度加法&lt;/strong&gt;与&lt;strong&gt;高精度乘法&lt;/strong&gt;结合&lt;/p&gt;
&lt;h3 id=&#34;ac代码-17&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

const int MAXN = 2e3;

int a[MAXN]= {1},b[MAXN];

void plu(int a[],int b[])
{
    int more = 0;
    for(int i = 0; i &amp;lt; 1000; i++)
    {
        b[i] += a[i] + more;
        more = b[i]/10;
        b[i] %= 10;
    }
}

void mul(int a[],int b)
{
    int more = 0;
    for(int i = 0; i &amp;lt; 1000; i++)
    {
        a[i] = a[i] * b + more;
        more = a[i]/10;
        a[i] %= 10;
    }
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    for(int i = 1; i &amp;lt;= n; i++)
    {
        mul(a,i);
        plu(a,b);
    }

    int flag = 0;
    for(int i = 999; i &amp;gt;= 0; i--)
    {
        if(b[i])
            flag = 1;
        if(flag)
            printf(&amp;quot;%d&amp;quot;,b[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t18-找筷子&#34;&gt;T18   找筷子&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1469&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-18&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;利用位运算异或的性质即可，偶数个相同的数异或结果为0，因而将所有筷子长度异或起来的结果即为落单的筷子的长度。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-18&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    int len,res;
    for(int i = 0;i &amp;lt; n;i++)
    {
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;len);
        if(i &amp;gt; 0)
            res ^= len;
        else if(i == 0)
            res = len;
    }
    printf(&amp;quot;%d&amp;quot;,res);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t19-两只塔姆沃斯牛-the-tamworth-two&#34;&gt;T19 两只塔姆沃斯牛 The Tamworth Two&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1518&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-19&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;结构体存储坐标和方向，不断循环即可，若某次移动结束后坐标重合即相遇，输出时间（即循环次数），若循环次数过大时（例10^6次）仍未相遇，即可判定永远不会相遇。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-19&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

char map[10][10];

struct farmer
{
    int x,y;
    char dire = &#39;n&#39;;//East South West North
} f;

struct cow
{
    int x,y;
    char dire = &#39;n&#39;;
} c;

int main()
{
    for(int i = 0; i &amp;lt; 10; i++)
        for(int j = 0; j &amp;lt; 10; j++)
        {
            scanf(&amp;quot; %c&amp;quot;,&amp;amp;map[i][j]);
            if(map[i][j] == &#39;F&#39;)
            {
                f.x = i;
                f.y = j;
            }
            else if(map[i][j] == &#39;C&#39;)
            {
                c.x = i;
                c.y = j;
            }
        }

    int cnt = 0;
    while(!(f.x == c.x &amp;amp;&amp;amp; f.y == c.y))
    {
        switch(f.dire)
        {
            case &#39;n&#39;:
                if(f.x != 0)
                {
                    if(map[f.x-1][f.y] != &#39;*&#39;)
                        f.x--;
                    else
                        f.dire = &#39;e&#39;;
                }
                else
                    f.dire = &#39;e&#39;;
                break;
            case &#39;e&#39;:
                if(f.y != 9)
                {
                    if(map[f.x][f.y+1] != &#39;*&#39;)
                        f.y++;
                    else
                        f.dire = &#39;s&#39;;
                }
                else
                    f.dire = &#39;s&#39;;
                break;
            case &#39;s&#39;:
                if(f.x != 9)
                {
                    if(map[f.x+1][f.y] != &#39;*&#39;)
                        f.x++;
                    else
                        f.dire = &#39;w&#39;;
                }
                else
                    f.dire = &#39;w&#39;;
                break;
            case &#39;w&#39;:
                if(f.y != 0)
                {
                    if(map[f.x][f.y-1] != &#39;*&#39;)
                        f.y--;
                    else
                        f.dire = &#39;n&#39;;
                }
                else
                    f.dire = &#39;n&#39;;
                break;
        }
        switch(c.dire)
        {
            case &#39;n&#39;:
                if(c.x != 0)
                {
                    if(map[c.x-1][c.y] != &#39;*&#39;)
                        c.x--;
                    else
                        c.dire = &#39;e&#39;;
                }
                else
                    c.dire = &#39;e&#39;;
                break;
            case &#39;e&#39;:
                if(c.y != 9)
                {
                    if(map[c.x][c.y+1] != &#39;*&#39;)
                        c.y++;
                    else
                        c.dire = &#39;s&#39;;
                }
                else
                    c.dire = &#39;s&#39;;
                break;
            case &#39;s&#39;:
                if(c.x != 9)
                {
                    if(map[c.x+1][c.y] != &#39;*&#39;)
                        c.x++;
                    else
                        c.dire = &#39;w&#39;;
                }
                else
                    c.dire = &#39;w&#39;;
                break;
            case &#39;w&#39;:
                if(c.y != 0)
                {
                    if(map[c.x][c.y-1] != &#39;*&#39;)
                        c.y--;
                    else
                        c.dire = &#39;n&#39;;
                }
                else
                    c.dire = &#39;n&#39;;
                break;
        }
        cnt++;
        if(cnt &amp;gt; 1e6)
        {
            printf(&amp;quot;0&amp;quot;);
            return 0;
        }
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t20-编码&#34;&gt;T20 编码&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1246&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-20&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;暴力枚举判断是否相等即可，要注意字母按升序排列，也就是不可能出现zoo之类的单词&lt;br&gt;
&lt;s&gt;刚刚才发现我读入字符串写的竟然是scanf(&amp;quot;%s&amp;quot;,&amp;amp;str);竟然还AC了，离谱，编译器之前竟然没报警告&lt;/s&gt;&lt;/p&gt;
&lt;h3 id=&#34;ac代码-20&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int cnt = 1;
    char str[7],s[7];
    
    scanf(&amp;quot;%s&amp;quot;,str);
    
    for(char i = &#39;a&#39;; i &amp;lt;= &#39;z&#39;; i++)
    {
        s[1] = &#39;\0&#39;;
        s[0] = i;
        if(strcmp(str,s) == 0)
        {
            printf(&amp;quot;%d&amp;quot;,cnt);
            return 0;
        }
        cnt++;
    }

    for(char i = &#39;a&#39;; i &amp;lt;= &#39;y&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;z&#39;; j++)
        {
            s[2] = &#39;\0&#39;;
            s[1] = j;
            s[0] = i;
            if(strcmp(str,s) == 0)
            {
                printf(&amp;quot;%d&amp;quot;,cnt);
                return 0;
            }
            cnt++;
        }

    for(char i = &#39;a&#39;; i &amp;lt;= &#39;x&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;y&#39;; j++)
            for(char k = j+1; k &amp;lt;= &#39;z&#39;; k++)
            {
                s[3] = &#39;\0&#39;;
                s[2] = k;
                s[1] = j;
                s[0] = i;
                if(strcmp(str,s) == 0)
                {
                    printf(&amp;quot;%d&amp;quot;,cnt);
                    return 0;
                }
                cnt++;
            }

    for(char i = &#39;a&#39;; i &amp;lt;= &#39;w&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;x&#39;; j++)
            for(char k = j+1; k &amp;lt;= &#39;y&#39;; k++)
                for(char q = k+1; q &amp;lt;= &#39;z&#39;; q++)
                {
                    s[4] = &#39;\0&#39;;
                    s[3] = q;
                    s[2] = k;
                    s[1] = j;
                    s[0] = i;
                    if(strcmp(str,s) == 0)
                    {
                        printf(&amp;quot;%d&amp;quot;,cnt);
                        return 0;
                    }
                    cnt++;
                }


    for(char i = &#39;a&#39;; i &amp;lt;= &#39;v&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;w&#39;; j++)
            for(char k = j+1; k &amp;lt;= &#39;x&#39;; k++)
                for(char q = k+1; q &amp;lt;= &#39;y&#39;; q++)
                    for(char w = q+1; w &amp;lt;= &#39;z&#39;; w++)
                    {
                        s[5] = &#39;\0&#39;;
                        s[4] = w;
                        s[3] = q;
                        s[2] = k;
                        s[1] = j;
                        s[0] = i;
                        if(strcmp(str,s) == 0)
                        {
                            printf(&amp;quot;%d&amp;quot;,cnt);
                            return 0;
                        }
                        cnt++;
                    }

    for(char i = &#39;a&#39;; i &amp;lt;= &#39;u&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;v&#39;; j++)
            for(char k = j+1; k &amp;lt;= &#39;w&#39;; k++)
                for(char q = k+1; q &amp;lt;= &#39;x&#39;; q++)
                    for(char w = q+1; w &amp;lt;= &#39;y&#39;; w++)
                        for(char e = w+1; e &amp;lt;= &#39;z&#39;; e++)
                        {
                            s[6] = &#39;\0&#39;;
                            s[5] = e;
                            s[4] = w;
                            s[3] = q;
                            s[2] = k;
                            s[1] = j;
                            s[0] = i;
                            if(strcmp(str,s) == 0)
                            {
                                printf(&amp;quot;%d&amp;quot;,cnt);
                                return 0;
                            }
                            cnt++;
                        }
    printf(&amp;quot;0&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t21-帮贡排序&#34;&gt;T21 帮贡排序&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1786&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-21&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;按照题意即可，要注意调整职位和输出时的排序方式不同，要写两个cmp函数，调整职位和输出前要分别调用一次sort函数。&lt;br&gt;
&lt;s&gt;一定要注意职位的大小写，不然一个字母的差别就是全WA与全AC的差别&lt;/s&gt;&lt;/p&gt;
&lt;h3 id=&#34;ac代码-21&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

enum prof
{
    BangZhong,JingYing,TangZhu,ZhangLao,HuFa,FuBangZhu,BangZhu
};

struct org
{
    string name;
    int pro,con,level,index;
};

bool cmp1(const org &amp;amp;o1,const org &amp;amp;o2)
{
    if(o1.con != o2.con)
        return o1.con &amp;gt; o2.con;
    else
        return o1.index &amp;lt; o2.index;
}

bool cmp2(const org &amp;amp;o1,const org &amp;amp;o2)
{
    if(o1.pro != o2.pro)
        return o1.pro &amp;gt; o2.pro;
    else if(o1.level != o2.level)
        return o1.level &amp;gt; o2.level;
    else
        return o1.index &amp;lt; o2.index;
}

int bz,fbz,hf,zl,tz,jy,baz;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    struct org o[n];
    for(int i = 0; i &amp;lt; n; i++)
    {
        string pr;
        cin &amp;gt;&amp;gt; o[i].name &amp;gt;&amp;gt; pr;
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;o[i].con,&amp;amp;o[i].level);
        o[i].index = i;
        if(pr == &amp;quot;BangZhu&amp;quot;)
            o[i].pro = BangZhu;
        else if(pr == &amp;quot;FuBangZhu&amp;quot;)
            o[i].pro = FuBangZhu;
        else if(pr == &amp;quot;HuFa&amp;quot;)
            o[i].pro = HuFa;
        else if(pr == &amp;quot;ZhangLao&amp;quot;)
            o[i].pro = ZhangLao;
        else if(pr == &amp;quot;TangZhu&amp;quot;)
            o[i].pro = TangZhu;
        else if(pr == &amp;quot;JingYing&amp;quot;)
            o[i].pro = JingYing;
        else if(pr == &amp;quot;BangZhong&amp;quot;)
            o[i].pro = BangZhong;
    }
    
    sort(o,o+n,cmp1);
    for(int i = 0; i &amp;lt; n; i++)
    {
        if(o[i].pro &amp;lt;= HuFa &amp;amp;&amp;amp; o[i].name != &amp;quot;absi2011&amp;quot;)
        {
            if(hf &amp;lt; 2)
            {
                o[i].pro = HuFa;
                hf++;
            }
            else if(zl &amp;lt; 4)
            {
                o[i].pro = ZhangLao;
                zl++;
            }
            else if(tz &amp;lt; 7)
            {
                o[i].pro = TangZhu;
                tz++;
            }
            else if(jy &amp;lt; 25)
            {
                o[i].pro = JingYing;
                jy++;
            }
            else
            {
                o[i].pro = BangZhong;
                baz++;
            }
        }
    }
    
    sort(o,o+n,cmp2);
    for(auto i:o)
    {
        cout &amp;lt;&amp;lt; i.name &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        switch(i.pro)
        {
            case BangZhu:
                printf(&amp;quot;BangZhu&amp;quot;);/*打成Bangzhu导致全WA，改正后全AC*/
                break;
            case FuBangZhu:
                printf(&amp;quot;FuBangZhu&amp;quot;);
                break;
            case HuFa:
                printf(&amp;quot;HuFa&amp;quot;);
                break;
            case ZhangLao:
                printf(&amp;quot;ZhangLao&amp;quot;);
                break;
            case TangZhu:
                printf(&amp;quot;TangZhu&amp;quot;);
                break;
            case JingYing:
                printf(&amp;quot;JingYing&amp;quot;);
                break;
            case BangZhong:
                printf(&amp;quot;BangZhong&amp;quot;);
                break;
        }
        printf(&amp;quot; %d\n&amp;quot;,i.level);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t22-数列找不同&#34;&gt;T22 数列找不同&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3901&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-22&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;预处理不断循环找出每个区间内各数互不相同的最长区间，每次固定右端点找出最小左端点，若询问的左端点小于对应的最小左端点即可判断存在相同的数。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-22&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

const int MAXN = 1e6;

int num[MAXN],a[MAXN];//num[i]-&amp;gt;以第i个数为右端点时左端点的最小值

int main()
{
    int n,q;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;q);

    int k;
    for(int i = 1; i &amp;lt;= n; i++)
    {
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);
        num[i] = max(num[i-1],a[k]+1);
        a[k] = i;
    }
    while(q--)
    {
        int l,r;
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;r);
        if(num[r] &amp;lt;= l)
            printf(&amp;quot;Yes\n&amp;quot;);
        else
            printf(&amp;quot;No\n&amp;quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t23-倒水&#34;&gt;T23 倒水&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1582&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-23&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/solution/P1582&#34;&gt;&lt;s&gt;洛谷题解里果然都是神犇&lt;/s&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新增知识点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C语言内置函数： __builtin__popcount(); 返回参数在二进制下1的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复习知识点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;位运算中 n&amp;amp;-n 表示n在二进制中最后一个1所代表的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为所有的水都是由两份相同的水合并而成的，因此每瓶水的体积一定是2^i（i ∈ N）升，最后保留k个瓶子，那么最后总的升数的二进制表示中，1的个数一定&amp;lt;=k。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;合并前&lt;/th&gt;
&lt;th&gt;二进制&lt;/th&gt;
&lt;th&gt;合并后&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1个瓶子&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2个瓶子&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;2个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3个瓶子&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;3个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4个瓶子&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5个瓶子&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;5个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6个瓶子&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;td&gt;6个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7个瓶子&lt;/td&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;td&gt;7个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8个瓶子&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;8个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;……&lt;/td&gt;
&lt;td&gt;……&lt;/td&gt;
&lt;td&gt;……&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由图显然，n个有水的瓶子，最后合并成的瓶子个数，就是这个数转成二进制1的个数。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-23&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n,k,res = 0;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;k);
    while(__builtin_popcount(n) &amp;gt; k)
    {
        res += n&amp;amp;(-n);
        n += n&amp;amp;(-n);
    }
    printf(&amp;quot;%d&amp;quot;,res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t24-cities-and-states-s&#34;&gt;T24 Cities and States S&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3405&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-24&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;题目中&lt;strong&gt;特殊的一对&lt;/strong&gt;类似于成对的飞地，显然在一对飞地中，其中一方的CS（City State）代码等于另一方的SC（State City）代码，进而存储一方的CS就可被另一方的SC吻合读取，特殊对数加一。要注意City代码与State代码相等的&lt;s&gt;本地&lt;/s&gt;特殊城市。&lt;/p&gt;
&lt;h3 id=&#34;ac代码-24&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;map&amp;gt;
using namespace std;
//typedef long long ll;

map&amp;lt;string,int&amp;gt; mp;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    
    int cnt = 0;
    string city,state,cs,sc;
    for(int i = 0;i &amp;lt; n;i++)
    {
        cin &amp;gt;&amp;gt; city &amp;gt;&amp;gt; state;
        cs = city.substr(0,2) + state;
        sc = state + city.substr(0,2);
        cnt += mp[sc];
        if(cs == sc)
            cnt -= mp[cs];
        mp[cs]++;
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t25-dreamoon-and-sets&#34;&gt;T25 Dreamoon and Sets&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF476D&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;题目解析-25&#34;&gt;题目解析&lt;/h3&gt;
&lt;p&gt;&lt;s&gt;第一道紫题&lt;/s&gt;&lt;br&gt;
&lt;s&gt;我觉得我得重读小学二年级&lt;/s&gt;&lt;br&gt;
枚举失败的我从洛谷题解中获取到了一些奇怪的知识：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;互质的一组数中a,b,c,d的值越接近,就能使最大值越小。&lt;br&gt;
相邻的两个正整数数是互质的，相邻的两个奇数也是互质的。&lt;br&gt;
连续n个正整数必有一个数能被n整除，不考虑1,2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;a,b,c,d互质，所以a,b,c,d中最多有一个偶数 为了让四个数的值更接近，我们不妨先假设有1个偶数，3个奇数。&lt;/li&gt;
&lt;li&gt;进一步转换，我们可以将a,b,c,d设为x,x+m1,x+m2,x+m3.&lt;/li&gt;
&lt;li&gt;因此我们先尝试令m1=1,m2=2,即四元组中前三个数为x,x+1,x+2。由于四元组中最多只有一个偶数，故x为奇数，根据以上易证的结论可知这三个数一定互质。&lt;/li&gt;
&lt;li&gt;考虑x是奇数，那么(x,x+1,x+2,x+4)&lt;strong&gt;一定&lt;/strong&gt;满足要求，且不能更小。考虑x是偶数，那么(x,x+1,x+3,x+5)&lt;strong&gt;不一定&lt;/strong&gt;满足要求，而且不能更小。显然x取奇数时是最优的。&lt;/li&gt;
&lt;li&gt;最大数为 (n*6-1)*k&lt;/li&gt;
&lt;li&gt;第一个数从1开始选，同时要保证所以四元组的第一个数为基数，每隔6个确定一个x就好了。x的通项公式即为(i-1)*6+1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ac代码-25&#34;&gt;AC代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main()
{
    int n,k;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;k);
    printf(&amp;quot;%d\n&amp;quot;,(n*6-1) * k);
    for(int i = 1;i &amp;lt;= n;i++)
    {
        int num = (i-1)*6+1;
        printf(&amp;quot;%d %d %d %d\n&amp;quot;,num*k,(num+1)*k,(num+2)*k,(num+4)*k);
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;
">寒假回归大礼包题解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://czyx007.top/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;本站使用Gridea博客系统，由vercel提供访问加速，在此感谢。&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀​&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://qm.qq.com/cgi-bin/qm/qr?k=I2jkn0dziL9o-T2Xcm7NG16jZzvoP7fy&amp;amp;noverify=0&#34;&gt;QQ：1029606625&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/zyx006&#34;&gt;Github：zyx006&lt;/a&gt;&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://czyx007.top/post/mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本文迁移自原生Github Pages&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;⌘  Command&lt;br&gt;
⇧  Shift&lt;br&gt;
⇪  CapsLock&lt;br&gt;
⌥  Option&lt;br&gt;
⌃  Control&lt;!-- more --&gt;&lt;br&gt;
↩  Return/Enter&lt;br&gt;
⌫  Delete&lt;br&gt;
⌦  向前删除键(Fn + Delete)&lt;br&gt;
↑  上箭头&lt;br&gt;
↓  下箭头&lt;br&gt;
←  左箭头&lt;br&gt;
→  右箭头&lt;br&gt;
⇞  PageUp(Fn + ↑)&lt;br&gt;
⇟  PageDown(Fn + ↓)&lt;br&gt;
Home  Fn + ←&lt;br&gt;
End  Fn + →&lt;br&gt;
⇥  右制表符(Tpb键)&lt;br&gt;
⇤  左制表符(Shift + Tpb)&lt;br&gt;
⎋  Escape(Esc)&lt;/p&gt;
&lt;h2 id=&#34;searchreplace查询替换&#34;&gt;Search/Replace(查询/替换)&lt;/h2&gt;
&lt;p&gt;Double Shift(⇧)  查询任何东西&lt;br&gt;
Command(⌘) + F  文件内查找&lt;br&gt;
Command(⌘) + G  查找模式下，向下查找&lt;br&gt;
Command(⌘) + Shift(⇧) + G  查找模式下，向上查找&lt;br&gt;
Command(⌘) + R  文件内替换&lt;br&gt;
Command(⌘) + Shift(⇧) + F  全局查找(根据路径)&lt;br&gt;
Command(⌘) + Shift(⇧) + R  全局替换(根据路径)&lt;br&gt;
Command(⌘) + Shift(⇧) + S  查询结构(Ultimate Edition 版专用，需要在Keymap中设置)&lt;br&gt;
Command(⌘) + Shift(⇧) + M  替换结构(Ultimate Edition 版专用，需要在Keymap中设置)&lt;/p&gt;
&lt;h2 id=&#34;usage-search使用查询&#34;&gt;Usage Search(使用查询)&lt;/h2&gt;
&lt;p&gt;Option(⌥) + F7 / Command(⌘) + F7  在文件中查找用法 / 在类中查找用法&lt;br&gt;
Command(⌘) + Shift(⇧) + F7  在文件中突出显示的用法&lt;br&gt;
Command(⌘) + Option(⌥) + F7  显示用法&lt;/p&gt;
&lt;h2 id=&#34;compile-and-run编译和运行&#34;&gt;Compile and Run(编译和运行)&lt;/h2&gt;
&lt;p&gt;Command(⌘) + F  编译Project&lt;br&gt;
Command(⌘) + Shift(⇧) + F9  编译选择的文件、包或模块&lt;br&gt;
Control(⌃) + Option(⌥) + R  弹出 Run 的可选择菜单&lt;br&gt;
Control(⌃) + Option(⌥) + D  弹出 Debug 的可选择菜单&lt;br&gt;
Control(⌃) + R  运行&lt;br&gt;
Control(⌃) + D  调试&lt;br&gt;
Control(⌃) + Shift(⇧) + R, Control(⌃) + Shift(⇧) + D  从编辑器运行上下文环境配置&lt;/p&gt;
&lt;h2 id=&#34;通用&#34;&gt;通用&lt;/h2&gt;
&lt;p&gt;Command(⌘) + C  复制&lt;br&gt;
Command(⌘) + V  粘贴&lt;/p&gt;
&lt;h3 id=&#34;剪切&#34;&gt;   剪切&lt;/h3&gt;
&lt;p&gt;   Step 1:Command(⌘) + C  复制&lt;br&gt;
   Step 2:在需要转移的文件夹位置使用Command(⌘) + Option(⌥) + V。(如果操作后悔了，还可以 Command(⌘) + Z 撤销。)&lt;/p&gt;
&lt;p&gt;Command(⌘) + A  全选&lt;br&gt;
Command(⌘) + S  保存&lt;br&gt;
Command(⌘) + F  查找(Find)&lt;br&gt;
Command(⌘) + M  最小化窗口&lt;br&gt;
Command(⌘) + N  新建文件&lt;br&gt;
Command(⌘) + O  打开&lt;br&gt;
Command(⌘) + H  隐藏窗口&lt;br&gt;
Command(⌘) + Shift(⇧) + S  另存&lt;br&gt;
Command(⌘) + W  关闭&lt;br&gt;
Command(⌘) + Q  退出&lt;br&gt;
Command(⌘) + Z  撤销(如果是safari浏览器，就是恢复刚关闭的页面)&lt;br&gt;
Command(⌘) + Shift(⇧) + Z  重做，也就是撤销的逆向操作&lt;br&gt;
Command(⌘) + Option(⌥) + Esc  强制退出程序(类似于window下的任务管理器)&lt;br&gt;
自带的输入法(Capslock 短按中英文切换，长按英文大写)&lt;br&gt;
Command(⌘) + Shift(⇧) + 4  截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口&lt;br&gt;
Command(⌘) + Delete  将文件移至废纸篓(Windows键盘是 Win + Backspace)&lt;br&gt;
Command(⌘) + Shift(⇧) + Delete  清倒废纸篓(Windows键盘是 Win + Shift + Backspace)&lt;br&gt;
Space  快速查看选中的文件，也就是预览功能&lt;br&gt;
Command(⌘) + ↑  打开包含当前文件夹的文件夹，相当于Windows里的“向上”&lt;br&gt;
Command(⌘) + Tab  在应用程序间切换(应用处于打开且在桌面的情况)&lt;/p&gt;
&lt;h2 id=&#34;浏览器&#34;&gt;浏览器&lt;/h2&gt;
&lt;p&gt;Command(⌘) + L  光标直接跳至地址栏(可能被Windows响应锁屏)&lt;br&gt;
Command(⌘) + &#39;+&#39; / &#39;=&#39;  放大页面&lt;br&gt;
Command(⌘) + &#39;-&#39;  缩小页面&lt;br&gt;
Control(⌃) + Tab  转向下一个标签页&lt;br&gt;
Control(⌃) + Shift(⇧) + Tab  转向上一个标签页&lt;br&gt;
Command(⌘) + R  刷新&lt;br&gt;
Command(⌘) + T  新建一个选项卡&lt;br&gt;
PageDown  向下滚动屏幕&lt;br&gt;
PageUp  向上滚动屏幕&lt;br&gt;
按下箭头键 向上、向下、向左或向右滚动&lt;br&gt;
按下箭头键时按住Option(⌥)键大幅度滚动&lt;br&gt;
enter即回车  重命名&lt;br&gt;
Command(⌘) + 鼠标点击  多选不连续的文件或文件夹&lt;/p&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;p&gt;选中多个连续的文件或文件夹&lt;br&gt;
按住Shift(⇧)键不放，使用鼠标依次点击(或按住鼠标后拖动)希望选择的文件或者文件夹即可&lt;br&gt;
文件可以右键重命名&lt;br&gt;
如果桌面的文件不对齐排列，可以右键整理&lt;br&gt;
Shift(⇧) + Command(⌘) + C  打开“电脑”窗口&lt;br&gt;
文件右键有一个“制作替身”，相当于新建一个快捷方式&lt;/p&gt;
">Mac键盘符号和快捷键说明</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;时间跨度：01-04 17:46:10 ~ 01-06 23:01:46&lt;/p&gt;\n&lt;p&gt;关键知识点：&lt;strong&gt;高精度&lt;/strong&gt;，斐波那契数列&lt;/p&gt;\n&lt;p&gt;部分新增知识点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;C语言内置函数__builtin__popcount();&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;数字之间的关系&lt;/strong&gt;，&lt;strong&gt;质数的性质&lt;/strong&gt;（数论？）&lt;!-- more --&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;t1-标题统计\&#34;&gt;T1 标题统计&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P5015\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;获取一整行字符串后计算除空格和换行符以外的字符数即可&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    string str;\n    getline(cin,str);\n    \n    int cnt = 0;\n    for(auto i:str)\n    if(i != &#39; &#39; &amp;amp;&amp;amp; i != &#39;\\n&#39;)\n        cnt++;\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t2-davor\&#34;&gt;T2 Davor&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P4956\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-2\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;用等差数列求出每星期筹到的金钱总额乘以总周数52，若刚好等于n则输出并中断。&lt;br&gt;\n为了满足 x 尽可能大，k 尽可能小，应使x从100开始倒序循环。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-2\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n\n    for(int x = 100; x &amp;gt;= 1; x--)\n    {\n        for(int k = 1;k &amp;lt; 3000; k++)\n        {\n            int cnt = 52 * (x + x+6*k)*7/2;\n            if(cnt == n)\n            {\n                printf(&amp;quot;%d\\n%d&amp;quot;,x,k);\n                return 0;\n            }\n        }\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t3-语句解析\&#34;&gt;T3 语句解析&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1597\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-3\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;按照题面所给的语句格式&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;变量 := 变量或一位整数;&lt;br&gt;\n逐字扫描判断，以分号作为分隔符进行逐句赋值，未赋值的变量以初始值0作为终值。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;ac代码-3\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    string str;\n    cin &amp;gt;&amp;gt; str;\n\n    int a = 0,b = 0,c = 0;\n    for(int i = 0; i &amp;lt; str.length(); i++)\n    {\n        if(str[i] == &#39;a&#39;)\n        {\n            int j = i;\n            while(str[j] !=&#39;;&#39;)j++;\n            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)\n                a = (str[j-1]-&#39;0&#39;);\n            else\n            {\n                if(str[j-1] == &#39;b&#39;)\n                    a = b;\n                else if(str[j-1] == &#39;c&#39;)\n                    a = c;\n            }\n            i = j;\n        }\n        else if(str[i] == &#39;b&#39;)\n        {\n            int j = i;\n            while(str[j] !=&#39;;&#39;)j++;\n            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)\n                b = (str[j-1]-&#39;0&#39;);\n            else\n            {\n                if(str[j-1] == &#39;a&#39;)\n                    b = a;\n                else if(str[j-1] == &#39;c&#39;)\n                    b = c;\n            }\n            i = j;\n        }\n        else if(str[i] == &#39;c&#39;)\n        {\n            int j = i;\n            while(str[j] !=&#39;;&#39;)j++;\n            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)\n                c = (str[j-1]-&#39;0&#39;);\n            else\n            {\n                if(str[j-1] == &#39;a&#39;)\n                    c = a;\n                else if(str[j-1] == &#39;b&#39;)\n                    c = b;\n            }\n            i = j;\n        }\n    }\n    printf(&amp;quot;%d %d %d&amp;quot;,a,b,c);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t4-数楼梯\&#34;&gt;T4 数楼梯&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1255\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-4\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;本题关键知识点：&lt;strong&gt;高精度&lt;/strong&gt;，&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;br&gt;\n从前几阶楼梯可以发现，上到每节楼梯的走法数分别为1,2,3,5，……，显然就是去掉第一项后的斐波那契列&lt;br&gt;\n但题目数据范围N &amp;lt;= 5000,斐波那契数列的值呈指数级爆炸增长，因而要使用高精度防止数据溢出。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-4\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nconst int MAXN = 5010;\n\nint a[MAXN],b[MAXN],c[MAXN];\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n\n    if(n &amp;lt; 3)\n        printf(&amp;quot;%d&amp;quot;,n);\n    else\n    {\n        int cnt = 1;\n        a[1] = 1,b[1] = 2;\n        for(int i = 3; i &amp;lt;= n; i++)\n        {\n            for(int j = 1; j &amp;lt;= cnt; j++)\n                c[j] = a[j]+b[j];\n            for(int j = 1; j &amp;lt;= cnt; j++)\n            {\n                if(c[j] &amp;gt; 9)\n                {\n                    c[j+1] += c[j]/10;\n                    c[j] %= 10;\n                    if(j+1 &amp;gt; cnt)\n                        cnt++;\n                }\n            }\n            for(int j = 1; j &amp;lt;= cnt; j++)\n                a[j] = b[j];\n            for(int j = 1; j &amp;lt;= cnt; j++)\n                b[j] = c[j];\n        }\n        for(int i = cnt;i &amp;gt; 0;i--)\n            printf(&amp;quot;%d&amp;quot;,b[i]);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t5-分数线划定\&#34;&gt;T5 分数线划定&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1068\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-5\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;用结构体存储每名选手的报名号和成绩，然后依照提议解题即可，要注意cmp函数的写法。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-5\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nstruct peo\n{\n    int id,score;\n};\n\nbool cmp(const peo &amp;amp;p1,const peo &amp;amp;p2)\n{\n    if(p1.score != p2.score)\n        return p1.score &amp;gt; p2.score;\n    else\n        return p1.id &amp;lt; p2.id;\n}\n\nint main()\n{\n    int n,m;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);\n    int num = m * 1.5;\n    struct peo p[n];\n\n    for(int i = 0; i &amp;lt; n; i++)\n        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;p[i].id,&amp;amp;p[i].score);\n    sort(p,p+n,cmp);\n\n    int line = p[num-1].score,cnt = 0;\n    for(int i = 0; p[i].score &amp;gt;= line; i++)\n        cnt++;\n    printf(&amp;quot;%d %d\\n&amp;quot;,line,cnt);\n    for(int i = 0; i &amp;lt; cnt; i++)\n        printf(&amp;quot;%d %d\\n&amp;quot;,p[i].id,p[i].score);\n\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t6-涂国旗\&#34;&gt;T6 涂国旗&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3392\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-6\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;预处理存储每行R/W/B三种颜色的块数，之后暴力O(n^2)枚举前两种颜色的行数(第三种颜色为剩下的行数)，用m减去某行某颜色的块数既得该行的成本，取得每次成本总和的最小值即可。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-6\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nstruct color\n{\n    int white,blue,red;\n};\n\nint main()\n{\n    int n,m;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);\n    \n    char ch[n][m];\n    struct color c[n];\n\n    for(int i = 0; i &amp;lt; n; i++)\n    {\n        int w = 0,b = 0,r = 0;\n        for(int j = 0; j &amp;lt; m; j++)\n        {\n            scanf(&amp;quot; %c&amp;quot;,&amp;amp;ch[i][j]);\n            switch(ch[i][j])\n            {\n                case &#39;W&#39;:\n                    w++;\n                    break;\n                case &#39;R&#39;:\n                    r++;\n                    break;\n                case &#39;B&#39;:\n                    b++;\n                    break;\n            }\n        }\n        c[i].white = w;\n        c[i].blue = b;\n        c[i].red = r;\n    }\n\n    int cnt = 1e7;\n    for(int i = 1; i &amp;lt;= n-2; i++)\n    {\n        for(int j = i+1; j &amp;lt;= n-1; j++)\n        {\n            int sum = 0;\n            for(int k = 1; k &amp;lt;= i; k++)\n                sum += (m-c[k-1].white);\n            for(int k = i+1; k &amp;lt;= j; k++)\n                sum += (m-c[k-1].blue);\n            for(int k = j+1; k &amp;lt;= n; k++)\n                sum += (m-c[k-1].red);\n            cnt = min(cnt,sum);\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t7-拼数\&#34;&gt;T7 拼数&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1012\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-7\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;将所有数字按字典序顺序降序排列后拼接即可。要注意cmp函数不能直接判断两字符串&lt;br&gt;\n&lt;s&gt;return s1 &amp;gt; s2;&lt;/s&gt;&lt;br&gt;\n&lt;u&gt;return s1+s2 &amp;gt; s2+s1;&lt;/u&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;详见代码中注释&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;ac代码-7\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;vector&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nvector&amp;lt;string&amp;gt; v; \n\nbool cmp(const string &amp;amp;s1,const string &amp;amp;s2)\n{\n    /*\n    若用s1 &amp;gt; s2,则结果为321 32 -&amp;gt;32132,但最大应为32321\n    使用s1+s2 &amp;gt; s2+s1则可避免这种32132&amp;gt;32321的情况 \n    */\n    return s1+s2 &amp;gt; s2+s1;\n}\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    for(int i = 0;i &amp;lt; n;i++)\n    {\n        string str;\n        cin &amp;gt;&amp;gt; str;\n        v.push_back(str);\n    }\n    sort(v.begin(),v.end(),cmp);\n    for(auto i:v)\n        cout &amp;lt;&amp;lt; i;\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t8-烤鸡\&#34;&gt;T8 烤鸡&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P2089\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-8\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;直接暴力枚举10种配料的所有搭配方案，若质量总和等于n则保存，等待输出。注意每种配料的质量都不能为0。&lt;br&gt;\n(由于配料质量和的最大值只有30，所以n &amp;gt; 30的可以直接输出0)&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-8\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;vector&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nvector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; v;\nvector&amp;lt;int&amp;gt; vs;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    \n    int cnt = 0;\n    for(int q = 1;q &amp;lt;= 3;q++)\n    for(int w = 1;w &amp;lt;= 3;w++)\n    for(int e = 1;e &amp;lt;= 3;e++)\n    for(int r = 1;r &amp;lt;= 3;r++)\n    for(int t = 1;t &amp;lt;= 3;t++)\n    for(int y = 1;y &amp;lt;= 3;y++)\n    for(int u = 1;u &amp;lt;= 3;u++)\n    for(int i = 1;i &amp;lt;= 3;i++)\n    for(int o = 1;o &amp;lt;= 3;o++)\n    for(int p = 1;p &amp;lt;= 3;p++)\n        if(q+w+e+r+t+y+u+i+o+p == n)\n        {\n            vs.push_back(q);\n            vs.push_back(w);\n            vs.push_back(e);\n            vs.push_back(r);\n            vs.push_back(t);\n            vs.push_back(y);\n            vs.push_back(u);\n            vs.push_back(i);\n            vs.push_back(o);\n            vs.push_back(p);\n            v.push_back(vs);\n            vs.clear();\n            cnt++;\n        }\n    \n    printf(&amp;quot;%d\\n&amp;quot;,cnt);\n    for(auto i:v)\n    {\n        for(auto j:i)\n            printf(&amp;quot;%d &amp;quot;,j);\n        printf(&amp;quot;\\n&amp;quot;);\n    }\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t9-独木桥\&#34;&gt;T9 独木桥&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1007\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-9\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;首先，不用考虑题目中的这一因素的影响：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;引用洛谷题解中很形象的两个例子：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;首先自行脑补一下，假装你正在20000米高空的轰炸机上用高倍显微镜望远镜默默欣赏士兵离开，你会发现什么东西？一堆花花绿绿的迷彩服在移动。（不是鬼片！不是鬼片！不是鬼片！重要的事情说三遍）&lt;br&gt;\n那么当两个士兵撞在一起时，从你的视角看会发生什么？当然他们认为他们都掉头了，但因为你在特高的地方，你会认为他们“穿过”了对方。换言之，这与他们相互穿过并没有任何区别。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;两个人相遇转身，相当于交换灵魂后继续走&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;那么问题就很简单了，最大值就是最靠近端点的两个人各自向对方方向走下桥,时间较长的那个人的时间，最小值就是所有人走完桥的时间的最小值的最大值。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-9\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int l,n;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;n);\n    \n    int pos[n]={0};\n    for(int i = 0;i &amp;lt; n;i++)\n        scanf(&amp;quot;%d&amp;quot;,&amp;amp;pos[i]);\n    sort(pos,pos+n,greater&amp;lt;int&amp;gt;());\n    int ma = max(pos[0],l-pos[n-1]+1);\n    int mi = 0;\n    for(int i = 0;i &amp;lt; n;i++)\n    {\n        int tmp = min(pos[i],l-pos[i]+1);\n        mi = max(tmp,mi);\n    }\n    printf(&amp;quot;%d %d&amp;quot;,mi,ma);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t10-first-step-ファーストステップ\&#34;&gt;T10 First Step (ファーストステップ)&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3654\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-10\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;枚举每个可站点，判断该点向右方和向下方各有多少种站位方式&lt;br&gt;\n要注意k=1的情况下，横着站和竖着站一样，因而要进行特判，此时站位方式数量就是可站点的数量。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-10\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int r,c,k;\n    scanf(&amp;quot;%d %d %d&amp;quot;,&amp;amp;r,&amp;amp;c,&amp;amp;k);\n\n    int po = 0;\n    char gym[r][c];\n    for(int i = 0; i &amp;lt; r; i++)\n        for(int j = 0; j &amp;lt; c; j++)\n        {\n            scanf(&amp;quot; %c&amp;quot;,&amp;amp;gym[i][j]);\n            if(gym[i][j] == &#39;.&#39;)\n                po++;\n        }\n\n    if(k == 1)\n    {\n        printf(&amp;quot;%d&amp;quot;,po);\n        return 0;\n    }\n    int cnt = 0,sum = 0;\n    for(int i = 0; i &amp;lt; r; i++)\n    {\n        for(int j = 0; j &amp;lt; c; j++)\n        {\n            if(gym[i][j] == &#39;.&#39;)\n            {\n                if(i &amp;lt; r-1)\n                {\n                    sum = 0;\n                    for(int q = j; q &amp;lt; c; q++)\n                    {\n                        if(gym[i][q] == &#39;.&#39;)\n                            sum++;\n                        else\n                            break;\n                        if(sum == k)\n                        {\n                            cnt++;\n                            break;\n                        }\n                    }\n                    sum = 0;\n                    for(int q = i; q &amp;lt; r; q++)\n                    {\n                        if(gym[q][j] == &#39;.&#39;)\n                            sum++;\n                        else\n                            break;\n                        if(sum == k)\n                        {\n                            cnt++;\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    sum = 0;\n                    for(int q = j; q &amp;lt; c; q++)\n                    {\n                        if(gym[i][q] == &#39;.&#39;)\n                            sum++;\n                        else\n                            break;\n                        if(sum == k)\n                        {\n                            cnt++;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t11-蜜蜂路线\&#34;&gt;T11 蜜蜂路线&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P2437\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-11\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1255\&#34;&gt;类似题目 T4数楼梯&lt;/a&gt;&lt;br&gt;\n本题需用到&lt;strong&gt;高精度&lt;/strong&gt;和&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;br&gt;\n不同的是本题中最终结果并不是从斐波那契数列第一项加起，它的起始项(左端点)是变化的。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-11\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;cstring&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nconst int MAXN = 5010;\n\nint a[MAXN]= {1,1},b[MAXN]= {1},c[MAXN];\n\nint main()\n{\n    int m,n;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;m,&amp;amp;n);\n\n    for(int i = m+1; i &amp;lt;= n; i++)\n    {\n        for(int j = 0; j &amp;lt;= a[0]; j++)\n            c[j] = a[j];\n        for(int j = 1; j &amp;lt;= a[0]; j++)\n        {\n            a[j] += b[j];\n            a[j+1] += a[j]/10;\n            a[j] %= 10;\n        }\n        while(a[a[0]+1]&amp;gt;0)\n            a[0]++;\n        memset(b,sizeof(b),0);\n        for(int j = 0; j &amp;lt;= c[0]; j++)\n            b[j] = c[j];\n    }\n    for(int i = a[0]; i &amp;gt;= 1; i--)\n        printf(&amp;quot;%d&amp;quot;,a[i]);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t12-最大公约数和最小公倍数问题\&#34;&gt;T12 最大公约数和最小公倍数问题&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1029\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-12\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;以x,y为端点进行O(n^2) 枚举,由于本题数据范围是10^5,为了防止TLE需要进行优化，只用枚举max(x,y)的所有因子即可。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-12\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\n#include&amp;lt;vector&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nvector&amp;lt;int&amp;gt; v;\nvoid getnum(int a);\n\nint main()\n{\n    int x,y;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x,&amp;amp;y);\n    \n    getnum(max(x,y));\n    \n    int cnt = 0,size = v.size();\n    for(int i = 0;i &amp;lt; size;i++)\n    {\n        for(int j = size-1;j &amp;gt;= 0;j--)\n        {\n            int gnum = __gcd(v[i],v[j]);\n            int LCD = (v[i] * v[j]) / gnum;\n            if(gnum == x &amp;amp;&amp;amp; LCD == y)\n                cnt++;\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n}\n\nvoid getnum(int a)\n{\n    for(int i = 1;i &amp;lt;= a;i++)\n        if(a % i == 0)\n            v.push_back(i);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t13-种田\&#34;&gt;T13 种田&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P2660\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-13\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P2241\&#34;&gt;类似题目：第四周提单 统计方形&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;不同的是，上题是统计所有方形的数量，而这题是每次切割最大正方形，每次以最短边为边长切割，体力值即为每次所切割的正方形的周长之和。但单单这样写会在最后一个测试点被10^16的数据卡TLE，只能拿90分，因而要进行优化，不能一个正方形一个正方形的切，要一次切多个，也就是切max(x,y)/min(x,y)个。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-13\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    ll n,m;\n    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;m);\n\n    ll res = 0;\n    while(n != 0 &amp;amp;&amp;amp; m != 0)\n    {\n        ll mi = min(n,m);\n        if(n &amp;lt; m)\n        {\n            res += 4 * (m/mi) * mi;\n            m %= mi;\n        }\n        else\n        {\n            res += 4 * (n/mi) * mi;\n            n %= mi;\n        }\n    }\n    printf(&amp;quot;%lld&amp;quot;,res);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t14-混合牛奶-mixing-milk\&#34;&gt;T14 混合牛奶 Mixing Milk&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1208\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-14\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;用结构体存储每位农民的单价和最大量，按单价从低到高进行排序，依次购买直至购买量等于所需量时即求出最小费用。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-14\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nstruct farmer{\n    int price,sum;\t\n};\n\nbool cmp(const farmer &amp;amp;f1,const farmer &amp;amp;f2)\n{\n    return f1.price &amp;lt; f2.price;\n}\n\nint main()\n{\n    int n,m;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);\n    struct farmer f[m];\n    \n    for(int i = 0;i &amp;lt; m;i++)\n        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;f[i].price,&amp;amp;f[i].sum);\n    sort(f,f+m,cmp);\n    \n    int su = 0,money = 0;\n    for(int i = 0;i &amp;lt; m;i++)\n    {\n        if(su + f[i].sum &amp;lt;= n)\n        {\n            su += f[i].sum;\n            money += f[i].price * f[i].sum;\n        }\n        else\n        {\n            money += f[i].price * (n - su);\n            break;\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,money);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t15-排队\&#34;&gt;T15 排队&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P5412\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-15\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;结构体存储按身高从矮到高排序，最后用cout输出即可。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-15\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nstruct stu\n{\n    int sex;\n    double height;\n};\n\nbool cmp(const stu &amp;amp;s1,const stu &amp;amp;s2)\n{\n    return s1.height &amp;lt; s2.height;\n}\n\nint main()\n{\n    int t;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);\n    while(t--)\n    {\n        int n;\n        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n        struct stu s[n];\n        for(int i = 0; i &amp;lt; n; i++)\n            scanf(&amp;quot;%d&amp;quot;,&amp;amp;s[i].sex);\n        for(int i = 0; i &amp;lt; n; i++)\n            scanf(&amp;quot;%lf&amp;quot;,&amp;amp;s[i].height);\n        \n        sort(s,s+n,cmp);\n        for(int i = 0; i &amp;lt; n; i++)\n            if(s[i].sex == 0)\n                cout &amp;lt;&amp;lt; s[i].height &amp;lt;&amp;lt; &#39; &#39;;\n        printf(&amp;quot;\\n&amp;quot;);\n        for(int i = 0; i &amp;lt; n; i++)\n            if(s[i].sex == 1)\n                cout &amp;lt;&amp;lt; s[i].height &amp;lt;&amp;lt; &#39; &#39;;\n        printf(&amp;quot;\\n&amp;quot;);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t16-小a的糖果\&#34;&gt;T16 小A的糖果&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3817\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-16\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;从左到右依次遍历，若左右之和大于x则将&lt;strong&gt;右侧数&lt;/strong&gt;减去&lt;strong&gt;两数之和与x的差&lt;/strong&gt; ，结果即为每次该差的总和。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-16\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    ll n,x;\n    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;x);\n    ll num[n] = {0};\n    \n    for(int i = 0;i &amp;lt; n;i++)\n        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;num[i]);\n        \n    ll cnt = 0;\n    for(ll i = 0;i &amp;lt; n-1;i++)\n    {\n        if(num[i] + num[i+1] &amp;gt; x)\n        {\n            cnt += num[i]+num[i+1]-x;\n            num[i+1] -= num[i]+num[i+1]-x;\n        }\n    }\n    printf(&amp;quot;%lld&amp;quot;,cnt);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t17-阶乘之和\&#34;&gt;T17 阶乘之和&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1009\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-17\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;高精度加法&lt;/strong&gt;与&lt;strong&gt;高精度乘法&lt;/strong&gt;结合&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-17\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nconst int MAXN = 2e3;\n\nint a[MAXN]= {1},b[MAXN];\n\nvoid plu(int a[],int b[])\n{\n    int more = 0;\n    for(int i = 0; i &amp;lt; 1000; i++)\n    {\n        b[i] += a[i] + more;\n        more = b[i]/10;\n        b[i] %= 10;\n    }\n}\n\nvoid mul(int a[],int b)\n{\n    int more = 0;\n    for(int i = 0; i &amp;lt; 1000; i++)\n    {\n        a[i] = a[i] * b + more;\n        more = a[i]/10;\n        a[i] %= 10;\n    }\n}\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    for(int i = 1; i &amp;lt;= n; i++)\n    {\n        mul(a,i);\n        plu(a,b);\n    }\n\n    int flag = 0;\n    for(int i = 999; i &amp;gt;= 0; i--)\n    {\n        if(b[i])\n            flag = 1;\n        if(flag)\n            printf(&amp;quot;%d&amp;quot;,b[i]);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t18-找筷子\&#34;&gt;T18   找筷子&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1469\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-18\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;利用位运算异或的性质即可，偶数个相同的数异或结果为0，因而将所有筷子长度异或起来的结果即为落单的筷子的长度。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-18\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    int len,res;\n    for(int i = 0;i &amp;lt; n;i++)\n    {\n        scanf(&amp;quot;%d&amp;quot;,&amp;amp;len);\n        if(i &amp;gt; 0)\n            res ^= len;\n        else if(i == 0)\n            res = len;\n    }\n    printf(&amp;quot;%d&amp;quot;,res);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t19-两只塔姆沃斯牛-the-tamworth-two\&#34;&gt;T19 两只塔姆沃斯牛 The Tamworth Two&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1518\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-19\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;结构体存储坐标和方向，不断循环即可，若某次移动结束后坐标重合即相遇，输出时间（即循环次数），若循环次数过大时（例10^6次）仍未相遇，即可判定永远不会相遇。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-19\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nchar map[10][10];\n\nstruct farmer\n{\n    int x,y;\n    char dire = &#39;n&#39;;//East South West North\n} f;\n\nstruct cow\n{\n    int x,y;\n    char dire = &#39;n&#39;;\n} c;\n\nint main()\n{\n    for(int i = 0; i &amp;lt; 10; i++)\n        for(int j = 0; j &amp;lt; 10; j++)\n        {\n            scanf(&amp;quot; %c&amp;quot;,&amp;amp;map[i][j]);\n            if(map[i][j] == &#39;F&#39;)\n            {\n                f.x = i;\n                f.y = j;\n            }\n            else if(map[i][j] == &#39;C&#39;)\n            {\n                c.x = i;\n                c.y = j;\n            }\n        }\n\n    int cnt = 0;\n    while(!(f.x == c.x &amp;amp;&amp;amp; f.y == c.y))\n    {\n        switch(f.dire)\n        {\n            case &#39;n&#39;:\n                if(f.x != 0)\n                {\n                    if(map[f.x-1][f.y] != &#39;*&#39;)\n                        f.x--;\n                    else\n                        f.dire = &#39;e&#39;;\n                }\n                else\n                    f.dire = &#39;e&#39;;\n                break;\n            case &#39;e&#39;:\n                if(f.y != 9)\n                {\n                    if(map[f.x][f.y+1] != &#39;*&#39;)\n                        f.y++;\n                    else\n                        f.dire = &#39;s&#39;;\n                }\n                else\n                    f.dire = &#39;s&#39;;\n                break;\n            case &#39;s&#39;:\n                if(f.x != 9)\n                {\n                    if(map[f.x+1][f.y] != &#39;*&#39;)\n                        f.x++;\n                    else\n                        f.dire = &#39;w&#39;;\n                }\n                else\n                    f.dire = &#39;w&#39;;\n                break;\n            case &#39;w&#39;:\n                if(f.y != 0)\n                {\n                    if(map[f.x][f.y-1] != &#39;*&#39;)\n                        f.y--;\n                    else\n                        f.dire = &#39;n&#39;;\n                }\n                else\n                    f.dire = &#39;n&#39;;\n                break;\n        }\n        switch(c.dire)\n        {\n            case &#39;n&#39;:\n                if(c.x != 0)\n                {\n                    if(map[c.x-1][c.y] != &#39;*&#39;)\n                        c.x--;\n                    else\n                        c.dire = &#39;e&#39;;\n                }\n                else\n                    c.dire = &#39;e&#39;;\n                break;\n            case &#39;e&#39;:\n                if(c.y != 9)\n                {\n                    if(map[c.x][c.y+1] != &#39;*&#39;)\n                        c.y++;\n                    else\n                        c.dire = &#39;s&#39;;\n                }\n                else\n                    c.dire = &#39;s&#39;;\n                break;\n            case &#39;s&#39;:\n                if(c.x != 9)\n                {\n                    if(map[c.x+1][c.y] != &#39;*&#39;)\n                        c.x++;\n                    else\n                        c.dire = &#39;w&#39;;\n                }\n                else\n                    c.dire = &#39;w&#39;;\n                break;\n            case &#39;w&#39;:\n                if(c.y != 0)\n                {\n                    if(map[c.x][c.y-1] != &#39;*&#39;)\n                        c.y--;\n                    else\n                        c.dire = &#39;n&#39;;\n                }\n                else\n                    c.dire = &#39;n&#39;;\n                break;\n        }\n        cnt++;\n        if(cnt &amp;gt; 1e6)\n        {\n            printf(&amp;quot;0&amp;quot;);\n            return 0;\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t20-编码\&#34;&gt;T20 编码&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1246\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-20\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;暴力枚举判断是否相等即可，要注意字母按升序排列，也就是不可能出现zoo之类的单词&lt;br&gt;\n&lt;s&gt;刚刚才发现我读入字符串写的竟然是scanf(&amp;quot;%s&amp;quot;,&amp;amp;str);竟然还AC了，离谱，编译器之前竟然没报警告&lt;/s&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-20\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;cstring&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int cnt = 1;\n    char str[7],s[7];\n    \n    scanf(&amp;quot;%s&amp;quot;,str);\n    \n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;z&#39;; i++)\n    {\n        s[1] = &#39;\\0&#39;;\n        s[0] = i;\n        if(strcmp(str,s) == 0)\n        {\n            printf(&amp;quot;%d&amp;quot;,cnt);\n            return 0;\n        }\n        cnt++;\n    }\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;y&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;z&#39;; j++)\n        {\n            s[2] = &#39;\\0&#39;;\n            s[1] = j;\n            s[0] = i;\n            if(strcmp(str,s) == 0)\n            {\n                printf(&amp;quot;%d&amp;quot;,cnt);\n                return 0;\n            }\n            cnt++;\n        }\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;x&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;y&#39;; j++)\n            for(char k = j+1; k &amp;lt;= &#39;z&#39;; k++)\n            {\n                s[3] = &#39;\\0&#39;;\n                s[2] = k;\n                s[1] = j;\n                s[0] = i;\n                if(strcmp(str,s) == 0)\n                {\n                    printf(&amp;quot;%d&amp;quot;,cnt);\n                    return 0;\n                }\n                cnt++;\n            }\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;w&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;x&#39;; j++)\n            for(char k = j+1; k &amp;lt;= &#39;y&#39;; k++)\n                for(char q = k+1; q &amp;lt;= &#39;z&#39;; q++)\n                {\n                    s[4] = &#39;\\0&#39;;\n                    s[3] = q;\n                    s[2] = k;\n                    s[1] = j;\n                    s[0] = i;\n                    if(strcmp(str,s) == 0)\n                    {\n                        printf(&amp;quot;%d&amp;quot;,cnt);\n                        return 0;\n                    }\n                    cnt++;\n                }\n\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;v&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;w&#39;; j++)\n            for(char k = j+1; k &amp;lt;= &#39;x&#39;; k++)\n                for(char q = k+1; q &amp;lt;= &#39;y&#39;; q++)\n                    for(char w = q+1; w &amp;lt;= &#39;z&#39;; w++)\n                    {\n                        s[5] = &#39;\\0&#39;;\n                        s[4] = w;\n                        s[3] = q;\n                        s[2] = k;\n                        s[1] = j;\n                        s[0] = i;\n                        if(strcmp(str,s) == 0)\n                        {\n                            printf(&amp;quot;%d&amp;quot;,cnt);\n                            return 0;\n                        }\n                        cnt++;\n                    }\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;u&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;v&#39;; j++)\n            for(char k = j+1; k &amp;lt;= &#39;w&#39;; k++)\n                for(char q = k+1; q &amp;lt;= &#39;x&#39;; q++)\n                    for(char w = q+1; w &amp;lt;= &#39;y&#39;; w++)\n                        for(char e = w+1; e &amp;lt;= &#39;z&#39;; e++)\n                        {\n                            s[6] = &#39;\\0&#39;;\n                            s[5] = e;\n                            s[4] = w;\n                            s[3] = q;\n                            s[2] = k;\n                            s[1] = j;\n                            s[0] = i;\n                            if(strcmp(str,s) == 0)\n                            {\n                                printf(&amp;quot;%d&amp;quot;,cnt);\n                                return 0;\n                            }\n                            cnt++;\n                        }\n    printf(&amp;quot;0&amp;quot;);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t21-帮贡排序\&#34;&gt;T21 帮贡排序&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1786\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-21\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;按照题意即可，要注意调整职位和输出时的排序方式不同，要写两个cmp函数，调整职位和输出前要分别调用一次sort函数。&lt;br&gt;\n&lt;s&gt;一定要注意职位的大小写，不然一个字母的差别就是全WA与全AC的差别&lt;/s&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-21\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nenum prof\n{\n    BangZhong,JingYing,TangZhu,ZhangLao,HuFa,FuBangZhu,BangZhu\n};\n\nstruct org\n{\n    string name;\n    int pro,con,level,index;\n};\n\nbool cmp1(const org &amp;amp;o1,const org &amp;amp;o2)\n{\n    if(o1.con != o2.con)\n        return o1.con &amp;gt; o2.con;\n    else\n        return o1.index &amp;lt; o2.index;\n}\n\nbool cmp2(const org &amp;amp;o1,const org &amp;amp;o2)\n{\n    if(o1.pro != o2.pro)\n        return o1.pro &amp;gt; o2.pro;\n    else if(o1.level != o2.level)\n        return o1.level &amp;gt; o2.level;\n    else\n        return o1.index &amp;lt; o2.index;\n}\n\nint bz,fbz,hf,zl,tz,jy,baz;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    struct org o[n];\n    for(int i = 0; i &amp;lt; n; i++)\n    {\n        string pr;\n        cin &amp;gt;&amp;gt; o[i].name &amp;gt;&amp;gt; pr;\n        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;o[i].con,&amp;amp;o[i].level);\n        o[i].index = i;\n        if(pr == &amp;quot;BangZhu&amp;quot;)\n            o[i].pro = BangZhu;\n        else if(pr == &amp;quot;FuBangZhu&amp;quot;)\n            o[i].pro = FuBangZhu;\n        else if(pr == &amp;quot;HuFa&amp;quot;)\n            o[i].pro = HuFa;\n        else if(pr == &amp;quot;ZhangLao&amp;quot;)\n            o[i].pro = ZhangLao;\n        else if(pr == &amp;quot;TangZhu&amp;quot;)\n            o[i].pro = TangZhu;\n        else if(pr == &amp;quot;JingYing&amp;quot;)\n            o[i].pro = JingYing;\n        else if(pr == &amp;quot;BangZhong&amp;quot;)\n            o[i].pro = BangZhong;\n    }\n    \n    sort(o,o+n,cmp1);\n    for(int i = 0; i &amp;lt; n; i++)\n    {\n        if(o[i].pro &amp;lt;= HuFa &amp;amp;&amp;amp; o[i].name != &amp;quot;absi2011&amp;quot;)\n        {\n            if(hf &amp;lt; 2)\n            {\n                o[i].pro = HuFa;\n                hf++;\n            }\n            else if(zl &amp;lt; 4)\n            {\n                o[i].pro = ZhangLao;\n                zl++;\n            }\n            else if(tz &amp;lt; 7)\n            {\n                o[i].pro = TangZhu;\n                tz++;\n            }\n            else if(jy &amp;lt; 25)\n            {\n                o[i].pro = JingYing;\n                jy++;\n            }\n            else\n            {\n                o[i].pro = BangZhong;\n                baz++;\n            }\n        }\n    }\n    \n    sort(o,o+n,cmp2);\n    for(auto i:o)\n    {\n        cout &amp;lt;&amp;lt; i.name &amp;lt;&amp;lt; &amp;quot; &amp;quot;;\n        switch(i.pro)\n        {\n            case BangZhu:\n                printf(&amp;quot;BangZhu&amp;quot;);/*打成Bangzhu导致全WA，改正后全AC*/\n                break;\n            case FuBangZhu:\n                printf(&amp;quot;FuBangZhu&amp;quot;);\n                break;\n            case HuFa:\n                printf(&amp;quot;HuFa&amp;quot;);\n                break;\n            case ZhangLao:\n                printf(&amp;quot;ZhangLao&amp;quot;);\n                break;\n            case TangZhu:\n                printf(&amp;quot;TangZhu&amp;quot;);\n                break;\n            case JingYing:\n                printf(&amp;quot;JingYing&amp;quot;);\n                break;\n            case BangZhong:\n                printf(&amp;quot;BangZhong&amp;quot;);\n                break;\n        }\n        printf(&amp;quot; %d\\n&amp;quot;,i.level);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t22-数列找不同\&#34;&gt;T22 数列找不同&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3901\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-22\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;预处理不断循环找出每个区间内各数互不相同的最长区间，每次固定右端点找出最小左端点，若询问的左端点小于对应的最小左端点即可判断存在相同的数。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-22\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nconst int MAXN = 1e6;\n\nint num[MAXN],a[MAXN];//num[i]-&amp;gt;以第i个数为右端点时左端点的最小值\n\nint main()\n{\n    int n,q;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;q);\n\n    int k;\n    for(int i = 1; i &amp;lt;= n; i++)\n    {\n        scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);\n        num[i] = max(num[i-1],a[k]+1);\n        a[k] = i;\n    }\n    while(q--)\n    {\n        int l,r;\n        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;r);\n        if(num[r] &amp;lt;= l)\n            printf(&amp;quot;Yes\\n&amp;quot;);\n        else\n            printf(&amp;quot;No\\n&amp;quot;);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t23-倒水\&#34;&gt;T23 倒水&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1582\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-23\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/solution/P1582\&#34;&gt;&lt;s&gt;洛谷题解里果然都是神犇&lt;/s&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;新增知识点：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;C语言内置函数： __builtin__popcount(); 返回参数在二进制下1的个数&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;复习知识点：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;位运算中 n&amp;amp;-n 表示n在二进制中最后一个1所代表的值&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;因为所有的水都是由两份相同的水合并而成的，因此每瓶水的体积一定是2^i（i ∈ N）升，最后保留k个瓶子，那么最后总的升数的二进制表示中，1的个数一定&amp;lt;=k。&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;合并前&lt;/th&gt;\n&lt;th&gt;二进制&lt;/th&gt;\n&lt;th&gt;合并后&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;1个瓶子&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2个瓶子&lt;/td&gt;\n&lt;td&gt;10&lt;/td&gt;\n&lt;td&gt;2个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;3个瓶子&lt;/td&gt;\n&lt;td&gt;11&lt;/td&gt;\n&lt;td&gt;3个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;4个瓶子&lt;/td&gt;\n&lt;td&gt;100&lt;/td&gt;\n&lt;td&gt;4个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;5个瓶子&lt;/td&gt;\n&lt;td&gt;101&lt;/td&gt;\n&lt;td&gt;5个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;6个瓶子&lt;/td&gt;\n&lt;td&gt;110&lt;/td&gt;\n&lt;td&gt;6个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;7个瓶子&lt;/td&gt;\n&lt;td&gt;111&lt;/td&gt;\n&lt;td&gt;7个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;8个瓶子&lt;/td&gt;\n&lt;td&gt;1000&lt;/td&gt;\n&lt;td&gt;8个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;……&lt;/td&gt;\n&lt;td&gt;……&lt;/td&gt;\n&lt;td&gt;……&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;由图显然，n个有水的瓶子，最后合并成的瓶子个数，就是这个数转成二进制1的个数。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-23\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int n,k,res = 0;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;k);\n    while(__builtin_popcount(n) &amp;gt; k)\n    {\n        res += n&amp;amp;(-n);\n        n += n&amp;amp;(-n);\n    }\n    printf(&amp;quot;%d&amp;quot;,res);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t24-cities-and-states-s\&#34;&gt;T24 Cities and States S&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3405\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-24\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;题目中&lt;strong&gt;特殊的一对&lt;/strong&gt;类似于成对的飞地，显然在一对飞地中，其中一方的CS（City State）代码等于另一方的SC（State City）代码，进而存储一方的CS就可被另一方的SC吻合读取，特殊对数加一。要注意City代码与State代码相等的&lt;s&gt;本地&lt;/s&gt;特殊城市。&lt;/p&gt;\n&lt;h3 id=\&#34;ac代码-24\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;map&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nmap&amp;lt;string,int&amp;gt; mp;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    \n    int cnt = 0;\n    string city,state,cs,sc;\n    for(int i = 0;i &amp;lt; n;i++)\n    {\n        cin &amp;gt;&amp;gt; city &amp;gt;&amp;gt; state;\n        cs = city.substr(0,2) + state;\n        sc = state + city.substr(0,2);\n        cnt += mp[sc];\n        if(cs == sc)\n            cnt -= mp[cs];\n        mp[cs]++;\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t25-dreamoon-and-sets\&#34;&gt;T25 Dreamoon and Sets&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/CF476D\&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;题目解析-25\&#34;&gt;题目解析&lt;/h3&gt;\n&lt;p&gt;&lt;s&gt;第一道紫题&lt;/s&gt;&lt;br&gt;\n&lt;s&gt;我觉得我得重读小学二年级&lt;/s&gt;&lt;br&gt;\n枚举失败的我从洛谷题解中获取到了一些奇怪的知识：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;互质的一组数中a,b,c,d的值越接近,就能使最大值越小。&lt;br&gt;\n相邻的两个正整数数是互质的，相邻的两个奇数也是互质的。&lt;br&gt;\n连续n个正整数必有一个数能被n整除，不考虑1,2&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;a,b,c,d互质，所以a,b,c,d中最多有一个偶数 为了让四个数的值更接近，我们不妨先假设有1个偶数，3个奇数。&lt;/li&gt;\n&lt;li&gt;进一步转换，我们可以将a,b,c,d设为x,x+m1,x+m2,x+m3.&lt;/li&gt;\n&lt;li&gt;因此我们先尝试令m1=1,m2=2,即四元组中前三个数为x,x+1,x+2。由于四元组中最多只有一个偶数，故x为奇数，根据以上易证的结论可知这三个数一定互质。&lt;/li&gt;\n&lt;li&gt;考虑x是奇数，那么(x,x+1,x+2,x+4)&lt;strong&gt;一定&lt;/strong&gt;满足要求，且不能更小。考虑x是偶数，那么(x,x+1,x+3,x+5)&lt;strong&gt;不一定&lt;/strong&gt;满足要求，而且不能更小。显然x取奇数时是最优的。&lt;/li&gt;\n&lt;li&gt;最大数为 (n*6-1)*k&lt;/li&gt;\n&lt;li&gt;第一个数从1开始选，同时要保证所以四元组的第一个数为基数，每隔6个确定一个x就好了。x的通项公式即为(i-1)*6+1&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;ac代码-25\&#34;&gt;AC代码&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\n\nint main()\n{\n    int n,k;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;k);\n    printf(&amp;quot;%d\\n&amp;quot;,(n*6-1) * k);\n    for(int i = 1;i &amp;lt;= n;i++)\n    {\n        int num = (i-1)*6+1;\n        printf(&amp;quot;%d %d %d %d\\n&amp;quot;,num*k,(num+1)*k,(num+2)*k,(num+4)*k);\n    }\n    return 0;\n}&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;han-jia-hui-gui-da-li-bao-ti-jie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;寒假回归大礼包题解&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-01-06 23:03:13&#34;,&#34;dateFormat&#34;:&#34;2021-01-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://czyx007.top/post/han-jia-hui-gui-da-li-bao-ti-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;34 min read&#34;,&#34;time&#34;:1984000,&#34;words&#34;:6461,&#34;minutes&#34;:34},&#34;description&#34;:&#34;时间跨度：01-04 17:46:10 ~ 01-06 23:01:46\n关键知识点：高精度，斐波那契数列\n部分新增知识点：\n\nC语言内置函数__builtin__popcount();\n数字之间的关系，质数的性质（数论？）\n\nT1 标题统...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#t1-%E6%A0%87%E9%A2%98%E7%BB%9F%E8%AE%A1\&#34;&gt;T1 标题统计&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t2-davor\&#34;&gt;T2 Davor&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-2\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t3-%E8%AF%AD%E5%8F%A5%E8%A7%A3%E6%9E%90\&#34;&gt;T3 语句解析&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-3\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-3\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t4-%E6%95%B0%E6%A5%BC%E6%A2%AF\&#34;&gt;T4 数楼梯&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-4\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-4\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t5-%E5%88%86%E6%95%B0%E7%BA%BF%E5%88%92%E5%AE%9A\&#34;&gt;T5 分数线划定&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-5\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-5\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t6-%E6%B6%82%E5%9B%BD%E6%97%97\&#34;&gt;T6 涂国旗&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-6\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-6\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t7-%E6%8B%BC%E6%95%B0\&#34;&gt;T7 拼数&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-7\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-7\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t8-%E7%83%A4%E9%B8%A1\&#34;&gt;T8 烤鸡&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-8\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-8\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t9-%E7%8B%AC%E6%9C%A8%E6%A1%A5\&#34;&gt;T9 独木桥&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-9\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-9\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t10-first-step-%E3%83%95%E3%82%A1%E3%83%BC%E3%82%B9%E3%83%88%E3%82%B9%E3%83%86%E3%83%83%E3%83%97\&#34;&gt;T10 First Step (ファーストステップ)&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-10\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-10\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t11-%E8%9C%9C%E8%9C%82%E8%B7%AF%E7%BA%BF\&#34;&gt;T11 蜜蜂路线&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-11\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-11\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t12-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98\&#34;&gt;T12 最大公约数和最小公倍数问题&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-12\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-12\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t13-%E7%A7%8D%E7%94%B0\&#34;&gt;T13 种田&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-13\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-13\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t14-%E6%B7%B7%E5%90%88%E7%89%9B%E5%A5%B6-mixing-milk\&#34;&gt;T14 混合牛奶 Mixing Milk&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-14\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-14\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t15-%E6%8E%92%E9%98%9F\&#34;&gt;T15 排队&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-15\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-15\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t16-%E5%B0%8Fa%E7%9A%84%E7%B3%96%E6%9E%9C\&#34;&gt;T16 小A的糖果&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-16\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-16\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t17-%E9%98%B6%E4%B9%98%E4%B9%8B%E5%92%8C\&#34;&gt;T17 阶乘之和&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-17\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-17\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t18-%E6%89%BE%E7%AD%B7%E5%AD%90\&#34;&gt;T18   找筷子&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-18\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-18\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t19-%E4%B8%A4%E5%8F%AA%E5%A1%94%E5%A7%86%E6%B2%83%E6%96%AF%E7%89%9B-the-tamworth-two\&#34;&gt;T19 两只塔姆沃斯牛 The Tamworth Two&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-19\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-19\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t20-%E7%BC%96%E7%A0%81\&#34;&gt;T20 编码&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-20\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-20\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t21-%E5%B8%AE%E8%B4%A1%E6%8E%92%E5%BA%8F\&#34;&gt;T21 帮贡排序&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-21\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-21\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t22-%E6%95%B0%E5%88%97%E6%89%BE%E4%B8%8D%E5%90%8C\&#34;&gt;T22 数列找不同&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-22\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-22\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t23-%E5%80%92%E6%B0%B4\&#34;&gt;T23 倒水&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-23\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-23\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t24-cities-and-states-s\&#34;&gt;T24 Cities and States S&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-24\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-24\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t25-dreamoon-and-sets\&#34;&gt;T25 Dreamoon and Sets&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-25\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-25\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;本站使用Gridea博客系统，由vercel提供访问加速，在此感谢。&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀​&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://qm.qq.com/cgi-bin/qm/qr?k=I2jkn0dziL9o-T2Xcm7NG16jZzvoP7fy&amp;amp;noverify=0\&#34;&gt;QQ：1029606625&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;https://github.com/zyx006\&#34;&gt;Github：zyx006&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-01-01 17:14:11&#34;,&#34;dateFormat&#34;:&#34;2021-01-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://czyx007.top/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:10000,&#34;words&#34;:48,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n本站使用Gridea博客系统，由vercel提供访问加速，在此感谢。\n📬 联系我呀​\nQQ：1029606625\nGithub：zyx006\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀​&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;本文迁移自原生Github Pages&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;⌘  Command&lt;br&gt;\n⇧  Shift&lt;br&gt;\n⇪  CapsLock&lt;br&gt;\n⌥  Option&lt;br&gt;\n⌃  Control&lt;!-- more --&gt;&lt;br&gt;\n↩  Return/Enter&lt;br&gt;\n⌫  Delete&lt;br&gt;\n⌦  向前删除键(Fn + Delete)&lt;br&gt;\n↑  上箭头&lt;br&gt;\n↓  下箭头&lt;br&gt;\n←  左箭头&lt;br&gt;\n→  右箭头&lt;br&gt;\n⇞  PageUp(Fn + ↑)&lt;br&gt;\n⇟  PageDown(Fn + ↓)&lt;br&gt;\nHome  Fn + ←&lt;br&gt;\nEnd  Fn + →&lt;br&gt;\n⇥  右制表符(Tpb键)&lt;br&gt;\n⇤  左制表符(Shift + Tpb)&lt;br&gt;\n⎋  Escape(Esc)&lt;/p&gt;\n&lt;h2 id=\&#34;searchreplace查询替换\&#34;&gt;Search/Replace(查询/替换)&lt;/h2&gt;\n&lt;p&gt;Double Shift(⇧)  查询任何东西&lt;br&gt;\nCommand(⌘) + F  文件内查找&lt;br&gt;\nCommand(⌘) + G  查找模式下，向下查找&lt;br&gt;\nCommand(⌘) + Shift(⇧) + G  查找模式下，向上查找&lt;br&gt;\nCommand(⌘) + R  文件内替换&lt;br&gt;\nCommand(⌘) + Shift(⇧) + F  全局查找(根据路径)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + R  全局替换(根据路径)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + S  查询结构(Ultimate Edition 版专用，需要在Keymap中设置)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + M  替换结构(Ultimate Edition 版专用，需要在Keymap中设置)&lt;/p&gt;\n&lt;h2 id=\&#34;usage-search使用查询\&#34;&gt;Usage Search(使用查询)&lt;/h2&gt;\n&lt;p&gt;Option(⌥) + F7 / Command(⌘) + F7  在文件中查找用法 / 在类中查找用法&lt;br&gt;\nCommand(⌘) + Shift(⇧) + F7  在文件中突出显示的用法&lt;br&gt;\nCommand(⌘) + Option(⌥) + F7  显示用法&lt;/p&gt;\n&lt;h2 id=\&#34;compile-and-run编译和运行\&#34;&gt;Compile and Run(编译和运行)&lt;/h2&gt;\n&lt;p&gt;Command(⌘) + F  编译Project&lt;br&gt;\nCommand(⌘) + Shift(⇧) + F9  编译选择的文件、包或模块&lt;br&gt;\nControl(⌃) + Option(⌥) + R  弹出 Run 的可选择菜单&lt;br&gt;\nControl(⌃) + Option(⌥) + D  弹出 Debug 的可选择菜单&lt;br&gt;\nControl(⌃) + R  运行&lt;br&gt;\nControl(⌃) + D  调试&lt;br&gt;\nControl(⌃) + Shift(⇧) + R, Control(⌃) + Shift(⇧) + D  从编辑器运行上下文环境配置&lt;/p&gt;\n&lt;h2 id=\&#34;通用\&#34;&gt;通用&lt;/h2&gt;\n&lt;p&gt;Command(⌘) + C  复制&lt;br&gt;\nCommand(⌘) + V  粘贴&lt;/p&gt;\n&lt;h3 id=\&#34;剪切\&#34;&gt;   剪切&lt;/h3&gt;\n&lt;p&gt;   Step 1:Command(⌘) + C  复制&lt;br&gt;\n   Step 2:在需要转移的文件夹位置使用Command(⌘) + Option(⌥) + V。(如果操作后悔了，还可以 Command(⌘) + Z 撤销。)&lt;/p&gt;\n&lt;p&gt;Command(⌘) + A  全选&lt;br&gt;\nCommand(⌘) + S  保存&lt;br&gt;\nCommand(⌘) + F  查找(Find)&lt;br&gt;\nCommand(⌘) + M  最小化窗口&lt;br&gt;\nCommand(⌘) + N  新建文件&lt;br&gt;\nCommand(⌘) + O  打开&lt;br&gt;\nCommand(⌘) + H  隐藏窗口&lt;br&gt;\nCommand(⌘) + Shift(⇧) + S  另存&lt;br&gt;\nCommand(⌘) + W  关闭&lt;br&gt;\nCommand(⌘) + Q  退出&lt;br&gt;\nCommand(⌘) + Z  撤销(如果是safari浏览器，就是恢复刚关闭的页面)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + Z  重做，也就是撤销的逆向操作&lt;br&gt;\nCommand(⌘) + Option(⌥) + Esc  强制退出程序(类似于window下的任务管理器)&lt;br&gt;\n自带的输入法(Capslock 短按中英文切换，长按英文大写)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + 4  截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口&lt;br&gt;\nCommand(⌘) + Delete  将文件移至废纸篓(Windows键盘是 Win + Backspace)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + Delete  清倒废纸篓(Windows键盘是 Win + Shift + Backspace)&lt;br&gt;\nSpace  快速查看选中的文件，也就是预览功能&lt;br&gt;\nCommand(⌘) + ↑  打开包含当前文件夹的文件夹，相当于Windows里的“向上”&lt;br&gt;\nCommand(⌘) + Tab  在应用程序间切换(应用处于打开且在桌面的情况)&lt;/p&gt;\n&lt;h2 id=\&#34;浏览器\&#34;&gt;浏览器&lt;/h2&gt;\n&lt;p&gt;Command(⌘) + L  光标直接跳至地址栏(可能被Windows响应锁屏)&lt;br&gt;\nCommand(⌘) + &#39;+&#39; / &#39;=&#39;  放大页面&lt;br&gt;\nCommand(⌘) + &#39;-&#39;  缩小页面&lt;br&gt;\nControl(⌃) + Tab  转向下一个标签页&lt;br&gt;\nControl(⌃) + Shift(⇧) + Tab  转向上一个标签页&lt;br&gt;\nCommand(⌘) + R  刷新&lt;br&gt;\nCommand(⌘) + T  新建一个选项卡&lt;br&gt;\nPageDown  向下滚动屏幕&lt;br&gt;\nPageUp  向上滚动屏幕&lt;br&gt;\n按下箭头键 向上、向下、向左或向右滚动&lt;br&gt;\n按下箭头键时按住Option(⌥)键大幅度滚动&lt;br&gt;\nenter即回车  重命名&lt;br&gt;\nCommand(⌘) + 鼠标点击  多选不连续的文件或文件夹&lt;/p&gt;\n&lt;h2 id=\&#34;其他\&#34;&gt;其他&lt;/h2&gt;\n&lt;p&gt;选中多个连续的文件或文件夹&lt;br&gt;\n按住Shift(⇧)键不放，使用鼠标依次点击(或按住鼠标后拖动)希望选择的文件或者文件夹即可&lt;br&gt;\n文件可以右键重命名&lt;br&gt;\n如果桌面的文件不对齐排列，可以右键整理&lt;br&gt;\nShift(⇧) + Command(⌘) + C  打开“电脑”窗口&lt;br&gt;\n文件右键有一个“制作替身”，相当于新建一个快捷方式&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Mac键盘符号和快捷键说明&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-11-14 17:41:52&#34;,&#34;dateFormat&#34;:&#34;2020-11-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://czyx007.top/post/mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:199000,&#34;words&#34;:833,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n本文迁移自原生Github Pages\n\n⌘  Command\n⇧  Shift\n⇪  CapsLock\n⌥  Option\n⌃  Control\n↩  Return/Enter\n⌫  Delete\n⌦  向前删除键(Fn + Delet...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#searchreplace%E6%9F%A5%E8%AF%A2%E6%9B%BF%E6%8D%A2\&#34;&gt;Search/Replace(查询/替换)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#usage-search%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2\&#34;&gt;Usage Search(使用查询)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#compile-and-run%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C\&#34;&gt;Compile and Run(编译和运行)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E7%94%A8\&#34;&gt;通用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%AA%E5%88%87\&#34;&gt;   剪切&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%8F%E8%A7%88%E5%99%A8\&#34;&gt;浏览器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B6%E4%BB%96\&#34;&gt;其他&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/love.js"></script>



</html>