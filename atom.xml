<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://czyx007.top</id>
    <title>君绾墨的blog</title>
    <updated>2021-01-09T12:04:16.593Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://czyx007.top"/>
    <link rel="self" href="https://czyx007.top/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://czyx007.top/images/avatar.png</logo>
    <icon>https://czyx007.top/favicon.ico</icon>
    <rights>All rights reserved 2021, 君绾墨的blog</rights>
    <entry>
        <title type="html"><![CDATA[数学专题一题解]]></title>
        <id>https://czyx007.top/post/shu-xue-zhuan-ti-yi-ti-jie/</id>
        <link href="https://czyx007.top/post/shu-xue-zhuan-ti-yi-ti-jie/">
        </link>
        <updated>2021-01-09T10:21:45.000Z</updated>
        <summary type="html"><![CDATA[<p>时间跨度：01-07 15:52:16 - 01-09 18:19:02<br>
<s>(8号摸鱼去了)</s></p>
<p>强化知识点：<br>
<strong>埃氏筛</strong>，<strong>分解质因数</strong>，<strong>快速幂</strong>，<strong>逆元</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>时间跨度：01-07 15:52:16 - 01-09 18:19:02<br>
<s>(8号摸鱼去了)</s></p>
<p>强化知识点：<br>
<strong>埃氏筛</strong>，<strong>分解质因数</strong>，<strong>快速幂</strong>，<strong>逆元</strong></p>
<!-- more -->
<h1 id="t1-快速幂取余运算">T1 快速幂||取余运算</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1226">洛谷P1226</a></p>
<h2 id="题目解析">题目解析</h2>
<p>快速幂模板题，按题意最后取余即可</p>
<h2 id="ac代码">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

ll fastpow(ll x,ll y,ll mod)
{
    x %= mod;
    ll res = 1;
    while(y)
    {
        if(y&amp;1)
            res = res * x % mod;
        y &gt;&gt;= 1;
        x = x * x % mod;  
    }
    return res;
}

int main()
{
    ll b,p,k;
    scanf(&quot;%lld %lld %lld&quot;,&amp;b,&amp;p,&amp;k);
    printf(&quot;%lld^%lld mod %lld=%lld&quot;,b,p,k,fastpow(b,p,k)%k);
    return 0;
} 
</code></pre>
<h1 id="t2-线性筛素数">T2 线性筛素数</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3383">洛谷P3383</a></p>
<h2 id="题目解析-2">题目解析</h2>
<p>埃氏筛优化，保证每个合数只被筛一遍。将每个素数依次存入数组中，第k小的素数即为数组中第k-1个元素。</p>
<h2 id="ac代码-2">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e8+10;
int prime[MAXN];
ll num[MAXN];

void isPrime(ll n)
{
    ll cnt = 0;
    prime[0] = prime[1] = 1;
    for(ll i = 2; i &lt;= n; i++)
    {
        if(!prime[i])
            num[cnt++] = i;
        for(ll j = 0; j &lt; cnt &amp;&amp; i*num[j] &lt; MAXN; j++)
        {
            prime[i*num[j]] = 1;
            if(i%num[j] == 0)
                break;
        }
    }
}

int main()
{

    int n,q;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;q);

    isPrime(n);
    int k;
    while(q--)
    {
        scanf(&quot;%d&quot;,&amp;k);
        printf(&quot;%lld\n&quot;,num[k-1]);
    }

    return 0;
}
</code></pre>
<h1 id="t3-乘法逆元">T3 乘法逆元</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3811">洛谷P3811</a></p>
<h2 id="题目解析-3">题目解析</h2>
<p>需用到逆元递推公式：inv[i] = (p-p/i) * inv[p%i] % p;</p>
<h2 id="ac代码-3">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e7;

ll inv[MAXN];

int main()
{
    ll n,p;
    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;p);
    
    inv[1] = 1;
    printf(&quot;1\n&quot;);
    for(int i = 2; i &lt;= n; i++)
    {
        inv[i] = (p-p/i) * inv[p%i] % p;
        printf(&quot;%lld\n&quot;,inv[i]);
    }
    return 0;
}
</code></pre>
<h1 id="t4-乘法逆元2">T4 乘法逆元2</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5431">洛谷P5431</a></p>
<h2 id="题目解析-4">题目解析</h2>
<p>先通分后取模，每次k乘上k本身（k,k<sup>2,k</sup>3，不用快速幂），通分求和后分子乘上分母的逆元再取模即为结果。</p>
<h2 id="ac代码-4">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

ll p;

const int MAXN = 5e6+10;
ll num[MAXN];

ll fastpow(ll x,ll y)
{
    x %= p;
    ll res = 1;
    while(y)
    {
        if(y&amp;1)
            res = res * x % p;
        y &gt;&gt;= 1;
        x = x * x % p;
    }
    return res;
}

ll inv(ll x)
{
    return fastpow(x,p-2);
}

int main()
{
    ll n,k;
    scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;p,&amp;k);
    ll t = k%p;	
    
    ll up = 0,down = 1;
    for(ll i = 0; i &lt; n; i++)
    {
        scanf(&quot;%lld&quot;,&amp;num[i]);
        up = (up*num[i]+down*t)%p;
        down = down * num[i] % p;
        t = t * k % p;
    }
    printf(&quot;%lld&quot;,up*inv(down)%p);
    return 0;
}
</code></pre>
<h1 id="t5-质数口袋">T5 质数口袋</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5723">洛谷P5723</a></p>
<h2 id="题目解析-5">题目解析</h2>
<p>埃氏筛打表后每次从头遍历即可，注意打表数组要开bool型数组，不然会MLE。</p>
<h2 id="ac代码-5">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e5;
bool prime[MAXN];

void isPrime()
{
    prime[0] = prime[1] = true;
    for(ll i = 2; i*i &lt;= MAXN; i++)
    {
        if(!prime[i])
            for(ll j = i*i; j &lt;= MAXN; j += i)
                prime[j] = true;
    }
}

int main()
{
    int L;
    scanf(&quot;%d&quot;,&amp;L);

    isPrime();
    int sum = 0,cnt = 0;
    for(int i = 2;; i++)
    {
        if(!prime[i])
        {
            if(sum + i &lt;= L)
            {
                sum += i;
                cnt++;
                printf(&quot;%d\n&quot;,i);
            }
            else
                break;
        }
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
}
</code></pre>
<h1 id="t6-回文质数">T6 回文质数</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1217">洛谷P1217</a></p>
<h2 id="题目解析-6">题目解析</h2>
<p>这道题我是用提前打表写的，打表后直接查询遍历输出即可。</p>
<h4 id="打表代码">打表代码</h4>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int MAXN = 100000010;
bool prime[MAXN];

void isPrime()
{
    prime[0] = prime[1] = true;
    for(ll i = 2;i*i &lt;= MAXN;i++)
    {
        if(!prime[i])
            for(ll j = i*i;j &lt;= MAXN;j += i)
                prime[j] = true;
    }
}

ll reverse( ll number )
{
    ll num = 0,flag = 0;
    if(number &lt; 0)
    {
        number = -number;
        flag = 1;
    }
    while(number)
    {
        num += number % 10;
        if((number &gt; 10) || (number % 10 == 0))
            num *= 10;
        number /= 10;
    }
    if(flag)
        num = -num;
    return num;
}

int main()
{
    FILE *fp;
    fp = fopen(&quot;1.txt&quot;,&quot;w&quot;);
    isPrime();
    for(ll i = 0;i &lt;= MAXN;i++)
        if(!prime[i])
        {
            if(i == reverse(i))
                fprintf(fp,&quot;%lld,&quot;,i);
        }
    fclose(fp);
    return 0;
}
</code></pre>
<h2 id="ac代码-6">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
//typedef long long ll;

int prime[] = {5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899};

int main()
{
    int a,b;
    scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
    for(auto i:prime)
        if(i &gt;= a &amp;&amp; i &lt;= b)
            printf(&quot;%d\n&quot;,i);
        else if(i &gt; b)
            break;
    return 0;
}
</code></pre>
<h1 id="t7-哥德巴赫猜想升级版">T7 哥德巴赫猜想（升级版）</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1579">洛谷P1579</a></p>
<h2 id="题目解析-7">题目解析</h2>
<p>埃氏筛打表后双重循环找出符合条件的一组输出即可。</p>
<h2 id="ac代码-7">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e6+10;
int prime[MAXN];

void isPrime()
{
    prime[0] = prime[1] = 1;
    for (ll i = 2; i * i &lt; MAXN; i++)
    {
        if (!prime[i])
        {
            for (ll j = i * i; j &lt; MAXN; j += i)
                prime[j] = 1;
        }
    }
}

int main()
{
    isPrime();

    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 2; i &lt; n-1; i++)
        for(int j = 2; j &lt; n-1-i; j++)
        {
            int k = n-i-j;
            if(prime[i] == 0 &amp;&amp; prime[j] == 0 &amp;&amp; prime[k] == 0)
                if(i+j+k == n)
                {
                    printf(&quot;%d %d %d&quot;, i, j, k);
                    return 0;
                }
        }
    return 0;
}
</code></pre>
<h1 id="t8-a-b-problem">T8 A % B Problem</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1865">洛谷P1865</a></p>
<h2 id="题目解析-8">题目解析</h2>
<p>埃氏筛打表后每次在区间内遍历即可，注意判断区间是否成立。</p>
<h2 id="ac代码-8">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e6+10;
bool prime[MAXN];

void isPrime()
{
    prime[0] = prime[1] = true;
    for(ll i = 2;i*i &lt;= MAXN;i++)
    {
        if(!prime[i])
            for(ll j = i*i;j &lt;= MAXN;j += i)
                prime[j] = true;
    }
}

int main()
{
    int n,m;
    int l,r;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    
    isPrime();
    while(n--)
    {
        scanf(&quot;%d %d&quot;,&amp;l,&amp;r);
        if(l &gt;= 1 &amp;&amp; l &lt;= m &amp;&amp; r &gt;= 1 &amp;&amp; r &lt;= m &amp;&amp; l &lt;= r)
        {
            int cnt = 0;
            for(int i = l;i &lt;= r;i++)
                if(!prime[i])
                    cnt++;
            printf(&quot;%d\n&quot;,cnt);
        }
        else
            printf(&quot;Crossing the line\n&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="t9-素数个数">T9 素数个数</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3912">洛谷P3912</a></p>
<h2 id="题目解析-9">题目解析</h2>
<p>埃氏筛打表时统计素数个数，打表完成后直接输出个数即可。</p>
<h2 id="ac代码-9">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e8+10;
bool prime[MAXN];

void isPrime(ll n)
{
    ll cnt = 0;
    prime[0] = prime[1] = 1;
    for(ll i = 2;i &lt;= n;i++)
    {
        if(!prime[i])
        {
            cnt++;
            for(ll j = i*i;j &lt;= n;j += i)
                prime[j] = true;
        }
    }
    printf(&quot;%lld&quot;,cnt); 
}

int main()
{
    ll n;
    scanf(&quot;%lld&quot;,&amp;n);
    isPrime(n);
    return 0;
} 
</code></pre>
<h1 id="t10-因子和">T10 因子和</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1593">洛谷P1593</a></p>
<h2 id="题目解析-10">题目解析</h2>
<p><s>逐渐看不懂的题解</s><br>
分解质因数并记录每个质因数的个数（记为幂数一起存储），结果为所有质因数等比数列求和再相乘。<br>
（要注意特判逆元为0的情况）<br>
<img src="https://gitee.com/gentlemans_ink/blogimage/raw/master/img/20210109193417.png" alt="" loading="lazy"></p>
<h2 id="ac代码-10">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int mod = 9901,MAXN = 1e6;
ll num[MAXN][2],sum[MAXN];

ll fastpow(ll x,ll y)
{
    x %= mod;
    ll res = 1;
    while(y)
    {
        if(y&amp;1)
            res = res * x % mod;
        y &gt;&gt;= 1;
        x = x * x % mod;
    }
    return res;
}

ll inv(ll x)
{
    return fastpow(x,mod-2)%mod;
}

int main()
{
    ll a,b;
    scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b);
    ll t = a;
    
    ll cnt = 0;
    for(ll i = 2;i*i &lt;= a;i++)
    {
        if(t%i == 0)
            num[++cnt][0] = i;
        while(t%i == 0)
        {
            num[cnt][1]++;
            t /= i;
        }
    }
    if(t != 1)
    {
        num[++cnt][0] = t;
        num[cnt][1] = 1;
    }
    
    ll res = 1;
    for(ll i = 1;i &lt;= cnt;i++)
    {
        sum[i] = (fastpow(num[i][0],num[i][1]*b+1)-1)*inv(num[i][0]-1)%mod;
        if(sum[i] == 0)
            sum[i] = num[i][1]*b+1;
        res = res * sum[i] % mod;
    }
    printf(&quot;%lld&quot;,(res%mod+mod)%mod);
    return 0;
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[寒假回归大礼包题解]]></title>
        <id>https://czyx007.top/post/han-jia-hui-gui-da-li-bao-ti-jie/</id>
        <link href="https://czyx007.top/post/han-jia-hui-gui-da-li-bao-ti-jie/">
        </link>
        <updated>2021-01-06T15:03:13.000Z</updated>
        <summary type="html"><![CDATA[<p>时间跨度：01-04 17:46:10 - 01-06 23:01:46</p>
<p>关键知识点：<strong>高精度</strong>，斐波那契数列</p>
<p>部分新增知识点：</p>
<ul>
<li>C语言内置函数__builtin__popcount();</li>
<li><strong>数字之间的关系</strong>，<strong>质数的性质</strong>（数论？）</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>时间跨度：01-04 17:46:10 - 01-06 23:01:46</p>
<p>关键知识点：<strong>高精度</strong>，斐波那契数列</p>
<p>部分新增知识点：</p>
<ul>
<li>C语言内置函数__builtin__popcount();</li>
<li><strong>数字之间的关系</strong>，<strong>质数的性质</strong>（数论？）</li>
</ul>
<!-- more -->
<h1 id="t1-标题统计">T1 标题统计</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5015">洛谷P5015</a></p>
<h2 id="题目解析">题目解析</h2>
<p>获取一整行字符串后计算除空格和换行符以外的字符数即可</p>
<h2 id="ac代码">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    string str;
    getline(cin,str);
    
    int cnt = 0;
    for(auto i:str)
    if(i != ' ' &amp;&amp; i != '\n')
        cnt++;
    printf(&quot;%d&quot;,cnt);
    return 0;
} 
</code></pre>
<h1 id="t2-davor">T2 Davor</h1>
<p>题目链接:<a href="https://www.luogu.com.cn/problem/P4956">洛谷P4956</a></p>
<h2 id="题目解析-2">题目解析</h2>
<p>用等差数列求出每星期筹到的金钱总额乘以总周数52，若刚好等于n则输出并中断。<br>
为了满足 x 尽可能大，k 尽可能小，应使x从100开始倒序循环。</p>
<h2 id="ac代码-2">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);

    for(int x = 100; x &gt;= 1; x--)
    {
        for(int k = 1;k &lt; 3000; k++)
        {
            int cnt = 52 * (x + x+6*k)*7/2;
            if(cnt == n)
            {
                printf(&quot;%d\n%d&quot;,x,k);
                return 0;
            }
        }
    }
    return 0;
}
</code></pre>
<h1 id="t3-语句解析">T3 语句解析</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1597">洛谷P1597</a></p>
<h2 id="题目解析-3">题目解析</h2>
<p>按照题面所给的语句格式</p>
<blockquote>
<p>变量 := 变量或一位整数;</p>
</blockquote>
<p>逐字扫描判断，以分号作为分隔符进行逐句赋值，未赋值的变量以初始值0作为终值。</p>
<h2 id="ac代码-3">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    string str;
    cin &gt;&gt; str;

    int a = 0,b = 0,c = 0;
    for(int i = 0; i &lt; str.length(); i++)
    {
        if(str[i] == 'a')
        {
            int j = i;
            while(str[j] !=';')j++;
            if(str[j-1] &gt;= '0' &amp;&amp; str[j-1] &lt;= '9')
                a = (str[j-1]-'0');
            else
            {
                if(str[j-1] == 'b')
                    a = b;
                else if(str[j-1] == 'c')
                    a = c;
            }
            i = j;
        }
        else if(str[i] == 'b')
        {
            int j = i;
            while(str[j] !=';')j++;
            if(str[j-1] &gt;= '0' &amp;&amp; str[j-1] &lt;= '9')
                b = (str[j-1]-'0');
            else
            {
                if(str[j-1] == 'a')
                    b = a;
                else if(str[j-1] == 'c')
                    b = c;
            }
            i = j;
        }
        else if(str[i] == 'c')
        {
            int j = i;
            while(str[j] !=';')j++;
            if(str[j-1] &gt;= '0' &amp;&amp; str[j-1] &lt;= '9')
                c = (str[j-1]-'0');
            else
            {
                if(str[j-1] == 'a')
                    c = a;
                else if(str[j-1] == 'b')
                    c = b;
            }
            i = j;
        }
    }
    printf(&quot;%d %d %d&quot;,a,b,c);
    return 0;
}
</code></pre>
<h1 id="t4-数楼梯">T4 数楼梯</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1255">洛谷P1255</a></p>
<h2 id="题目解析-4">题目解析</h2>
<p>本题关键知识点：<strong>高精度</strong>，<strong>斐波那契数列</strong><br>
从前几阶楼梯可以发现，上到每节楼梯的走法数分别为1,2,3,5，……，显然就是去掉第一项后的斐波那契列<br>
但题目数据范围N &lt;= 5000,斐波那契数列的值呈指数级爆炸增长，因而要使用高精度防止数据溢出。</p>
<h2 id="ac代码-4">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

const int MAXN = 5010;

int a[MAXN],b[MAXN],c[MAXN];

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);

    if(n &lt; 3)
        printf(&quot;%d&quot;,n);
    else
    {
        int cnt = 1;
        a[1] = 1,b[1] = 2;
        for(int i = 3; i &lt;= n; i++)
        {
            for(int j = 1; j &lt;= cnt; j++)
                c[j] = a[j]+b[j];
            for(int j = 1; j &lt;= cnt; j++)
            {
                if(c[j] &gt; 9)
                {
                    c[j+1] += c[j]/10;
                    c[j] %= 10;
                    if(j+1 &gt; cnt)
                        cnt++;
                }
            }
            for(int j = 1; j &lt;= cnt; j++)
                a[j] = b[j];
            for(int j = 1; j &lt;= cnt; j++)
                b[j] = c[j];
        }
        for(int i = cnt;i &gt; 0;i--)
            printf(&quot;%d&quot;,b[i]);
    }
    return 0;
}
</code></pre>
<h1 id="t5-分数线划定">T5 分数线划定</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1068">洛谷P1068</a></p>
<h2 id="题目解析-5">题目解析</h2>
<p>用结构体存储每名选手的报名号和成绩，然后依照提议解题即可，要注意cmp函数的写法。</p>
<h2 id="ac代码-5">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

struct peo
{
    int id,score;
};

bool cmp(const peo &amp;p1,const peo &amp;p2)
{
    if(p1.score != p2.score)
        return p1.score &gt; p2.score;
    else
        return p1.id &lt; p2.id;
}

int main()
{
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    int num = m * 1.5;
    struct peo p[n];

    for(int i = 0; i &lt; n; i++)
        scanf(&quot;%d %d&quot;,&amp;p[i].id,&amp;p[i].score);
    sort(p,p+n,cmp);

    int line = p[num-1].score,cnt = 0;
    for(int i = 0; p[i].score &gt;= line; i++)
        cnt++;
    printf(&quot;%d %d\n&quot;,line,cnt);
    for(int i = 0; i &lt; cnt; i++)
        printf(&quot;%d %d\n&quot;,p[i].id,p[i].score);

    return 0;
}
</code></pre>
<h1 id="t6-涂国旗">T6 涂国旗</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3392">洛谷P3392</a></p>
<h2 id="题目解析-6">题目解析</h2>
<p>预处理存储每行R/W/B三种颜色的块数，之后暴力O(n^2)枚举前两种颜色的行数(第三种颜色为剩下的行数)，用m减去某行某颜色的块数既得该行的成本，取得每次成本总和的最小值即可。</p>
<h2 id="ac代码-6">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

struct color
{
    int white,blue,red;
};

int main()
{
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    
    char ch[n][m];
    struct color c[n];

    for(int i = 0; i &lt; n; i++)
    {
        int w = 0,b = 0,r = 0;
        for(int j = 0; j &lt; m; j++)
        {
            scanf(&quot; %c&quot;,&amp;ch[i][j]);
            switch(ch[i][j])
            {
                case 'W':
                    w++;
                    break;
                case 'R':
                    r++;
                    break;
                case 'B':
                    b++;
                    break;
            }
        }
        c[i].white = w;
        c[i].blue = b;
        c[i].red = r;
    }

    int cnt = 1e7;
    for(int i = 1; i &lt;= n-2; i++)
    {
        for(int j = i+1; j &lt;= n-1; j++)
        {
            int sum = 0;
            for(int k = 1; k &lt;= i; k++)
                sum += (m-c[k-1].white);
            for(int k = i+1; k &lt;= j; k++)
                sum += (m-c[k-1].blue);
            for(int k = j+1; k &lt;= n; k++)
                sum += (m-c[k-1].red);
            cnt = min(cnt,sum);
        }
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
}
</code></pre>
<h1 id="t7-拼数">T7 拼数</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1012">洛谷P1012</a></p>
<h2 id="题目解析-7">题目解析</h2>
<p>将所有数字按字典序顺序降序排列后拼接即可。要注意cmp函数不能直接判断两字符串<br>
<s>return s1 &gt; s2;</s><br>
<u>return s1+s2 &gt; s2+s1;</u></p>
<blockquote>
<p>详见代码中注释</p>
</blockquote>
<h2 id="ac代码-7">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

vector&lt;string&gt; v; 

bool cmp(const string &amp;s1,const string &amp;s2)
{
    /*
    若用s1 &gt; s2,则结果为321 32 -&gt;32132,但最大应为32321
    使用s1+s2 &gt; s2+s1则可避免这种32132&gt;32321的情况 
    */
    return s1+s2 &gt; s2+s1;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i = 0;i &lt; n;i++)
    {
        string str;
        cin &gt;&gt; str;
        v.push_back(str);
    }
    sort(v.begin(),v.end(),cmp);
    for(auto i:v)
        cout &lt;&lt; i;
    return 0;
} 
</code></pre>
<h1 id="t8-烤鸡">T8 烤鸡</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P2089">洛谷P2089</a></p>
<h2 id="题目解析-8">题目解析</h2>
<p>直接暴力枚举10种配料的所有搭配方案，若质量总和等于n则保存，等待输出。注意每种配料的质量都不能为0。<br>
(由于配料质量和的最大值只有30，所以n &gt; 30的可以直接输出0)</p>
<h2 id="ac代码-8">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;vector&gt;
using namespace std;
//typedef long long ll;

vector&lt;vector&lt;int&gt; &gt; v;
vector&lt;int&gt; vs;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    
    int cnt = 0;
    for(int q = 1;q &lt;= 3;q++)
    for(int w = 1;w &lt;= 3;w++)
    for(int e = 1;e &lt;= 3;e++)
    for(int r = 1;r &lt;= 3;r++)
    for(int t = 1;t &lt;= 3;t++)
    for(int y = 1;y &lt;= 3;y++)
    for(int u = 1;u &lt;= 3;u++)
    for(int i = 1;i &lt;= 3;i++)
    for(int o = 1;o &lt;= 3;o++)
    for(int p = 1;p &lt;= 3;p++)
        if(q+w+e+r+t+y+u+i+o+p == n)
        {
            vs.push_back(q);
            vs.push_back(w);
            vs.push_back(e);
            vs.push_back(r);
            vs.push_back(t);
            vs.push_back(y);
            vs.push_back(u);
            vs.push_back(i);
            vs.push_back(o);
            vs.push_back(p);
            v.push_back(vs);
            vs.clear();
            cnt++;
        }
    
    printf(&quot;%d\n&quot;,cnt);
    for(auto i:v)
    {
        for(auto j:i)
            printf(&quot;%d &quot;,j);
        printf(&quot;\n&quot;);
    }
    return 0;
} 
</code></pre>
<h1 id="t9-独木桥">T9 独木桥</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1007">洛谷P1007</a></p>
<h2 id="题目解析-9">题目解析</h2>
<p>首先，不用考虑题目中的这一因素的影响：</p>
<blockquote>
<p>但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。</p>
</blockquote>
<p>引用洛谷题解中很形象的两个例子：</p>
<blockquote>
<p>首先自行脑补一下，假装你正在20000米高空的轰炸机上用高倍显微镜望远镜默默欣赏士兵离开，你会发现什么东西？一堆花花绿绿的迷彩服在移动。（不是鬼片！不是鬼片！不是鬼片！重要的事情说三遍）<br>
那么当两个士兵撞在一起时，从你的视角看会发生什么？当然他们认为他们都掉头了，但因为你在特高的地方，你会认为他们“穿过”了对方。换言之，这与他们相互穿过并没有任何区别。</p>
</blockquote>
<blockquote>
<p>两个人相遇转身，相当于交换灵魂后继续走</p>
</blockquote>
<p>那么问题就很简单了，最大值就是最靠近端点的两个人各自向对方方向走下桥,时间较长的那个人的时间，最小值就是所有人走完桥的时间的最小值的最大值。</p>
<h2 id="ac代码-9">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int l,n;
    scanf(&quot;%d %d&quot;,&amp;l,&amp;n);
    
    int pos[n]={0};
    for(int i = 0;i &lt; n;i++)
        scanf(&quot;%d&quot;,&amp;pos[i]);
    sort(pos,pos+n,greater&lt;int&gt;());
    int ma = max(pos[0],l-pos[n-1]+1);
    int mi = 0;
    for(int i = 0;i &lt; n;i++)
    {
        int tmp = min(pos[i],l-pos[i]+1);
        mi = max(tmp,mi);
    }
    printf(&quot;%d %d&quot;,mi,ma);
    return 0;
} 
</code></pre>
<h1 id="t10-first-step-ファーストステップ">T10 First Step (ファーストステップ)</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3654">洛谷P3654</a></p>
<h2 id="题目解析-10">题目解析</h2>
<p>枚举每个可站点，判断该点向右方和向下方各有多少种站位方式<br>
要注意k=1的情况下，横着站和竖着站一样，因而要进行特判，此时站位方式数量就是可站点的数量。</p>
<h2 id="ac代码-10">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int r,c,k;
    scanf(&quot;%d %d %d&quot;,&amp;r,&amp;c,&amp;k);

    int po = 0;
    char gym[r][c];
    for(int i = 0; i &lt; r; i++)
        for(int j = 0; j &lt; c; j++)
        {
            scanf(&quot; %c&quot;,&amp;gym[i][j]);
            if(gym[i][j] == '.')
                po++;
        }

    if(k == 1)
    {
        printf(&quot;%d&quot;,po);
        return 0;
    }
    int cnt = 0,sum = 0;
    for(int i = 0; i &lt; r; i++)
    {
        for(int j = 0; j &lt; c; j++)
        {
            if(gym[i][j] == '.')
            {
                if(i &lt; r-1)
                {
                    sum = 0;
                    for(int q = j; q &lt; c; q++)
                    {
                        if(gym[i][q] == '.')
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                    sum = 0;
                    for(int q = i; q &lt; r; q++)
                    {
                        if(gym[q][j] == '.')
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                }
                else
                {
                    sum = 0;
                    for(int q = j; q &lt; c; q++)
                    {
                        if(gym[i][q] == '.')
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                }
            }
        }
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
}
</code></pre>
<h1 id="t11-蜜蜂路线">T11 蜜蜂路线</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P2437">洛谷P2437</a></p>
<h2 id="题目解析-11">题目解析</h2>
<blockquote>
<p>类似题目 T4数楼梯：<a href="https://www.luogu.com.cn/problem/P1255">洛谷P1255</a></p>
</blockquote>
<p>本题需用到<strong>高精度</strong>和<strong>斐波那契数列</strong><br>
不同的是本题中最终结果并不是从斐波那契数列第一项加起，它的起始项(左端点)是变化的。</p>
<h2 id="ac代码-11">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;cstring&gt;
using namespace std;
//typedef long long ll;

const int MAXN = 5010;

int a[MAXN]= {1,1},b[MAXN]= {1},c[MAXN];

int main()
{
    int m,n;
    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);

    for(int i = m+1; i &lt;= n; i++)
    {
        for(int j = 0; j &lt;= a[0]; j++)
            c[j] = a[j];
        for(int j = 1; j &lt;= a[0]; j++)
        {
            a[j] += b[j];
            a[j+1] += a[j]/10;
            a[j] %= 10;
        }
        while(a[a[0]+1]&gt;0)
            a[0]++;
        memset(b,sizeof(b),0);
        for(int j = 0; j &lt;= c[0]; j++)
            b[j] = c[j];
    }
    for(int i = a[0]; i &gt;= 1; i--)
        printf(&quot;%d&quot;,a[i]);
    return 0;
}
</code></pre>
<h1 id="t12-最大公约数和最小公倍数问题">T12 最大公约数和最小公倍数问题</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1029">洛谷P1029</a></p>
<h2 id="题目解析-12">题目解析</h2>
<p>以x,y为端点进行O(n^2) 枚举,由于本题数据范围是10^5,为了防止TLE需要进行优化，只用枚举max(x,y)的所有因子即可。</p>
<h2 id="ac代码-12">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
//typedef long long ll;

vector&lt;int&gt; v;
void getnum(int a);

int main()
{
    int x,y;
    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);
    
    getnum(max(x,y));
    
    int cnt = 0,size = v.size();
    for(int i = 0;i &lt; size;i++)
    {
        for(int j = size-1;j &gt;= 0;j--)
        {
            int gnum = __gcd(v[i],v[j]);
            int LCD = (v[i] * v[j]) / gnum;
            if(gnum == x &amp;&amp; LCD == y)
                cnt++;
        }
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
}

void getnum(int a)
{
    for(int i = 1;i &lt;= a;i++)
        if(a % i == 0)
            v.push_back(i);
}
</code></pre>
<h1 id="t13-种田">T13 种田</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P2660">洛谷P2660</a></p>
<h2 id="题目解析-13">题目解析</h2>
<blockquote>
<p>类似题目 第四周题单-统计方形：<a href="https://www.luogu.com.cn/problem/P2241">洛谷P2241</a></p>
</blockquote>
<p>不同的是，上题是统计所有方形的数量，而这题是每次切割最大正方形，每次以最短边为边长切割，体力值即为每次所切割的正方形的周长之和。但单单这样写会在最后一个测试点被10^16的数据卡TLE，只能拿90分，因而要进行优化，不能一个正方形一个正方形的切，要一次切多个，也就是切max(x,y)/min(x,y)个。</p>
<h2 id="ac代码-13">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
typedef long long ll;

int main()
{
    ll n,m;
    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);

    ll res = 0;
    while(n != 0 &amp;&amp; m != 0)
    {
        ll mi = min(n,m);
        if(n &lt; m)
        {
            res += 4 * (m/mi) * mi;
            m %= mi;
        }
        else
        {
            res += 4 * (n/mi) * mi;
            n %= mi;
        }
    }
    printf(&quot;%lld&quot;,res);
    return 0;
}
</code></pre>
<h1 id="t14-混合牛奶-mixing-milk">T14 混合牛奶 Mixing Milk</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1208">洛谷P1208</a></p>
<h2 id="题目解析-14">题目解析</h2>
<p>用结构体存储每位农民的单价和最大量，按单价从低到高进行排序，依次购买直至购买量等于所需量时即求出最小费用。</p>
<h2 id="ac代码-14">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

struct farmer{
    int price,sum;	
};

bool cmp(const farmer &amp;f1,const farmer &amp;f2)
{
    return f1.price &lt; f2.price;
}

int main()
{
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    struct farmer f[m];
    
    for(int i = 0;i &lt; m;i++)
        scanf(&quot;%d %d&quot;,&amp;f[i].price,&amp;f[i].sum);
    sort(f,f+m,cmp);
    
    int su = 0,money = 0;
    for(int i = 0;i &lt; m;i++)
    {
        if(su + f[i].sum &lt;= n)
        {
            su += f[i].sum;
            money += f[i].price * f[i].sum;
        }
        else
        {
            money += f[i].price * (n - su);
            break;
        }
    }
    printf(&quot;%d&quot;,money);
    return 0;
} 
</code></pre>
<h1 id="t15-排队">T15 排队</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5412">洛谷P5412</a></p>
<h2 id="题目解析-15">题目解析</h2>
<p>结构体存储按身高从矮到高排序，最后用cout输出即可。</p>
<h2 id="ac代码-15">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

struct stu
{
    int sex;
    double height;
};

bool cmp(const stu &amp;s1,const stu &amp;s2)
{
    return s1.height &lt; s2.height;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        struct stu s[n];
        for(int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;,&amp;s[i].sex);
        for(int i = 0; i &lt; n; i++)
            scanf(&quot;%lf&quot;,&amp;s[i].height);
        
        sort(s,s+n,cmp);
        for(int i = 0; i &lt; n; i++)
            if(s[i].sex == 0)
                cout &lt;&lt; s[i].height &lt;&lt; ' ';
        printf(&quot;\n&quot;);
        for(int i = 0; i &lt; n; i++)
            if(s[i].sex == 1)
                cout &lt;&lt; s[i].height &lt;&lt; ' ';
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="t16-小a的糖果">T16 小A的糖果</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3817">洛谷P3817</a></p>
<h2 id="题目解析-16">题目解析</h2>
<p>从左到右依次遍历，若左右之和大于x则将<strong>右侧数</strong>减去<strong>两数之和与x的差</strong> ，结果即为每次该差的总和。</p>
<h2 id="ac代码-16">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
typedef long long ll;

int main()
{
    ll n,x;
    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;x);
    ll num[n] = {0};
    
    for(int i = 0;i &lt; n;i++)
        scanf(&quot;%lld&quot;,&amp;num[i]);
        
    ll cnt = 0;
    for(ll i = 0;i &lt; n-1;i++)
    {
        if(num[i] + num[i+1] &gt; x)
        {
            cnt += num[i]+num[i+1]-x;
            num[i+1] -= num[i]+num[i+1]-x;
        }
    }
    printf(&quot;%lld&quot;,cnt);
    return 0;
} 
</code></pre>
<h1 id="t17-阶乘之和">T17 阶乘之和</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1009">洛谷P1009</a></p>
<h2 id="题目解析-17">题目解析</h2>
<p><strong>高精度加法</strong>与<strong>高精度乘法</strong>结合</p>
<h2 id="ac代码-17">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

const int MAXN = 2e3;

int a[MAXN]= {1},b[MAXN];

void plu(int a[],int b[])
{
    int more = 0;
    for(int i = 0; i &lt; 1000; i++)
    {
        b[i] += a[i] + more;
        more = b[i]/10;
        b[i] %= 10;
    }
}

void mul(int a[],int b)
{
    int more = 0;
    for(int i = 0; i &lt; 1000; i++)
    {
        a[i] = a[i] * b + more;
        more = a[i]/10;
        a[i] %= 10;
    }
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i = 1; i &lt;= n; i++)
    {
        mul(a,i);
        plu(a,b);
    }

    int flag = 0;
    for(int i = 999; i &gt;= 0; i--)
    {
        if(b[i])
            flag = 1;
        if(flag)
            printf(&quot;%d&quot;,b[i]);
    }
    return 0;
}
</code></pre>
<h1 id="t18-找筷子">T18   找筷子</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1469">洛谷P1469</a></p>
<h2 id="题目解析-18">题目解析</h2>
<p>利用位运算异或的性质即可，偶数个相同的数异或结果为0，因而将所有筷子长度异或起来的结果即为落单的筷子的长度。</p>
<h2 id="ac代码-18">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int len,res;
    for(int i = 0;i &lt; n;i++)
    {
        scanf(&quot;%d&quot;,&amp;len);
        if(i &gt; 0)
            res ^= len;
        else if(i == 0)
            res = len;
    }
    printf(&quot;%d&quot;,res);
    return 0;
} 
</code></pre>
<h1 id="t19-两只塔姆沃斯牛-the-tamworth-two">T19 两只塔姆沃斯牛 The Tamworth Two</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1518">洛谷P1518</a></p>
<h2 id="题目解析-19">题目解析</h2>
<p>结构体存储坐标和方向，不断循环即可，若某次移动结束后坐标重合即相遇，输出时间（即循环次数），若循环次数过大时（例10^6次）仍未相遇，即可判定永远不会相遇。</p>
<h2 id="ac代码-19">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

char map[10][10];

struct farmer
{
    int x,y;
    char dire = 'n';//East South West North
} f;

struct cow
{
    int x,y;
    char dire = 'n';
} c;

int main()
{
    for(int i = 0; i &lt; 10; i++)
        for(int j = 0; j &lt; 10; j++)
        {
            scanf(&quot; %c&quot;,&amp;map[i][j]);
            if(map[i][j] == 'F')
            {
                f.x = i;
                f.y = j;
            }
            else if(map[i][j] == 'C')
            {
                c.x = i;
                c.y = j;
            }
        }

    int cnt = 0;
    while(!(f.x == c.x &amp;&amp; f.y == c.y))
    {
        switch(f.dire)
        {
            case 'n':
                if(f.x != 0)
                {
                    if(map[f.x-1][f.y] != '*')
                        f.x--;
                    else
                        f.dire = 'e';
                }
                else
                    f.dire = 'e';
                break;
            case 'e':
                if(f.y != 9)
                {
                    if(map[f.x][f.y+1] != '*')
                        f.y++;
                    else
                        f.dire = 's';
                }
                else
                    f.dire = 's';
                break;
            case 's':
                if(f.x != 9)
                {
                    if(map[f.x+1][f.y] != '*')
                        f.x++;
                    else
                        f.dire = 'w';
                }
                else
                    f.dire = 'w';
                break;
            case 'w':
                if(f.y != 0)
                {
                    if(map[f.x][f.y-1] != '*')
                        f.y--;
                    else
                        f.dire = 'n';
                }
                else
                    f.dire = 'n';
                break;
        }
        switch(c.dire)
        {
            case 'n':
                if(c.x != 0)
                {
                    if(map[c.x-1][c.y] != '*')
                        c.x--;
                    else
                        c.dire = 'e';
                }
                else
                    c.dire = 'e';
                break;
            case 'e':
                if(c.y != 9)
                {
                    if(map[c.x][c.y+1] != '*')
                        c.y++;
                    else
                        c.dire = 's';
                }
                else
                    c.dire = 's';
                break;
            case 's':
                if(c.x != 9)
                {
                    if(map[c.x+1][c.y] != '*')
                        c.x++;
                    else
                        c.dire = 'w';
                }
                else
                    c.dire = 'w';
                break;
            case 'w':
                if(c.y != 0)
                {
                    if(map[c.x][c.y-1] != '*')
                        c.y--;
                    else
                        c.dire = 'n';
                }
                else
                    c.dire = 'n';
                break;
        }
        cnt++;
        if(cnt &gt; 1e6)
        {
            printf(&quot;0&quot;);
            return 0;
        }
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
}
</code></pre>
<h1 id="t20-编码">T20 编码</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1246">洛谷P1246</a></p>
<h2 id="题目解析-20">题目解析</h2>
<p>暴力枚举判断是否相等即可，要注意字母按升序排列，也就是不可能出现zoo之类的单词<br>
<s>刚刚才发现我读入字符串写的竟然是scanf(&quot;%s&quot;,&amp;str);竟然还AC了，离谱，编译器之前竟然没报警告</s></p>
<h2 id="ac代码-20">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;cstring&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int cnt = 1;
    char str[7],s[7];
    
    scanf(&quot;%s&quot;,str);
    
    for(char i = 'a'; i &lt;= 'z'; i++)
    {
        s[1] = '\0';
        s[0] = i;
        if(strcmp(str,s) == 0)
        {
            printf(&quot;%d&quot;,cnt);
            return 0;
        }
        cnt++;
    }

    for(char i = 'a'; i &lt;= 'y'; i++)
        for(char j = i+1; j &lt;= 'z'; j++)
        {
            s[2] = '\0';
            s[1] = j;
            s[0] = i;
            if(strcmp(str,s) == 0)
            {
                printf(&quot;%d&quot;,cnt);
                return 0;
            }
            cnt++;
        }

    for(char i = 'a'; i &lt;= 'x'; i++)
        for(char j = i+1; j &lt;= 'y'; j++)
            for(char k = j+1; k &lt;= 'z'; k++)
            {
                s[3] = '\0';
                s[2] = k;
                s[1] = j;
                s[0] = i;
                if(strcmp(str,s) == 0)
                {
                    printf(&quot;%d&quot;,cnt);
                    return 0;
                }
                cnt++;
            }

    for(char i = 'a'; i &lt;= 'w'; i++)
        for(char j = i+1; j &lt;= 'x'; j++)
            for(char k = j+1; k &lt;= 'y'; k++)
                for(char q = k+1; q &lt;= 'z'; q++)
                {
                    s[4] = '\0';
                    s[3] = q;
                    s[2] = k;
                    s[1] = j;
                    s[0] = i;
                    if(strcmp(str,s) == 0)
                    {
                        printf(&quot;%d&quot;,cnt);
                        return 0;
                    }
                    cnt++;
                }


    for(char i = 'a'; i &lt;= 'v'; i++)
        for(char j = i+1; j &lt;= 'w'; j++)
            for(char k = j+1; k &lt;= 'x'; k++)
                for(char q = k+1; q &lt;= 'y'; q++)
                    for(char w = q+1; w &lt;= 'z'; w++)
                    {
                        s[5] = '\0';
                        s[4] = w;
                        s[3] = q;
                        s[2] = k;
                        s[1] = j;
                        s[0] = i;
                        if(strcmp(str,s) == 0)
                        {
                            printf(&quot;%d&quot;,cnt);
                            return 0;
                        }
                        cnt++;
                    }

    for(char i = 'a'; i &lt;= 'u'; i++)
        for(char j = i+1; j &lt;= 'v'; j++)
            for(char k = j+1; k &lt;= 'w'; k++)
                for(char q = k+1; q &lt;= 'x'; q++)
                    for(char w = q+1; w &lt;= 'y'; w++)
                        for(char e = w+1; e &lt;= 'z'; e++)
                        {
                            s[6] = '\0';
                            s[5] = e;
                            s[4] = w;
                            s[3] = q;
                            s[2] = k;
                            s[1] = j;
                            s[0] = i;
                            if(strcmp(str,s) == 0)
                            {
                                printf(&quot;%d&quot;,cnt);
                                return 0;
                            }
                            cnt++;
                        }
    printf(&quot;0&quot;);
    return 0;
}
</code></pre>
<h1 id="t21-帮贡排序">T21 帮贡排序</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1786">洛谷P1786</a></p>
<h2 id="题目解析-21">题目解析</h2>
<p>按照题意即可，要注意调整职位和输出时的排序方式不同，要写两个cmp函数，调整职位和输出前要分别调用一次sort函数。<br>
<s>一定要注意职位的大小写，不然一个字母的差别就是全WA与全AC的差别</s></p>
<h2 id="ac代码-21">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

enum prof
{
    BangZhong,JingYing,TangZhu,ZhangLao,HuFa,FuBangZhu,BangZhu
};

struct org
{
    string name;
    int pro,con,level,index;
};

bool cmp1(const org &amp;o1,const org &amp;o2)
{
    if(o1.con != o2.con)
        return o1.con &gt; o2.con;
    else
        return o1.index &lt; o2.index;
}

bool cmp2(const org &amp;o1,const org &amp;o2)
{
    if(o1.pro != o2.pro)
        return o1.pro &gt; o2.pro;
    else if(o1.level != o2.level)
        return o1.level &gt; o2.level;
    else
        return o1.index &lt; o2.index;
}

int bz,fbz,hf,zl,tz,jy,baz;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    struct org o[n];
    for(int i = 0; i &lt; n; i++)
    {
        string pr;
        cin &gt;&gt; o[i].name &gt;&gt; pr;
        scanf(&quot;%d %d&quot;,&amp;o[i].con,&amp;o[i].level);
        o[i].index = i;
        if(pr == &quot;BangZhu&quot;)
            o[i].pro = BangZhu;
        else if(pr == &quot;FuBangZhu&quot;)
            o[i].pro = FuBangZhu;
        else if(pr == &quot;HuFa&quot;)
            o[i].pro = HuFa;
        else if(pr == &quot;ZhangLao&quot;)
            o[i].pro = ZhangLao;
        else if(pr == &quot;TangZhu&quot;)
            o[i].pro = TangZhu;
        else if(pr == &quot;JingYing&quot;)
            o[i].pro = JingYing;
        else if(pr == &quot;BangZhong&quot;)
            o[i].pro = BangZhong;
    }
    
    sort(o,o+n,cmp1);
    for(int i = 0; i &lt; n; i++)
    {
        if(o[i].pro &lt;= HuFa &amp;&amp; o[i].name != &quot;absi2011&quot;)
        {
            if(hf &lt; 2)
            {
                o[i].pro = HuFa;
                hf++;
            }
            else if(zl &lt; 4)
            {
                o[i].pro = ZhangLao;
                zl++;
            }
            else if(tz &lt; 7)
            {
                o[i].pro = TangZhu;
                tz++;
            }
            else if(jy &lt; 25)
            {
                o[i].pro = JingYing;
                jy++;
            }
            else
            {
                o[i].pro = BangZhong;
                baz++;
            }
        }
    }
    
    sort(o,o+n,cmp2);
    for(auto i:o)
    {
        cout &lt;&lt; i.name &lt;&lt; &quot; &quot;;
        switch(i.pro)
        {
            case BangZhu:
                printf(&quot;BangZhu&quot;);/*打成Bangzhu导致全WA，改正后全AC*/
                break;
            case FuBangZhu:
                printf(&quot;FuBangZhu&quot;);
                break;
            case HuFa:
                printf(&quot;HuFa&quot;);
                break;
            case ZhangLao:
                printf(&quot;ZhangLao&quot;);
                break;
            case TangZhu:
                printf(&quot;TangZhu&quot;);
                break;
            case JingYing:
                printf(&quot;JingYing&quot;);
                break;
            case BangZhong:
                printf(&quot;BangZhong&quot;);
                break;
        }
        printf(&quot; %d\n&quot;,i.level);
    }
    return 0;
}
</code></pre>
<h1 id="t22-数列找不同">T22 数列找不同</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3901">洛谷P3901</a></p>
<h2 id="题目解析-22">题目解析</h2>
<p>预处理不断循环找出每个区间内各数互不相同的最长区间，每次固定右端点找出最小左端点，若询问的左端点小于对应的最小左端点即可判断存在相同的数。</p>
<h2 id="ac代码-22">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

const int MAXN = 1e6;

int num[MAXN],a[MAXN];//num[i]-&gt;以第i个数为右端点时左端点的最小值

int main()
{
    int n,q;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;q);

    int k;
    for(int i = 1; i &lt;= n; i++)
    {
        scanf(&quot;%d&quot;,&amp;k);
        num[i] = max(num[i-1],a[k]+1);
        a[k] = i;
    }
    while(q--)
    {
        int l,r;
        scanf(&quot;%d %d&quot;,&amp;l,&amp;r);
        if(num[r] &lt;= l)
            printf(&quot;Yes\n&quot;);
        else
            printf(&quot;No\n&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="t23-倒水">T23 倒水</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1582">洛谷P1582</a></p>
<h2 id="题目解析-23">题目解析</h2>
<p><a href="https://www.luogu.com.cn/problem/solution/P1582"><s>洛谷题解里果然都是神犇</s></a></p>
<p>新增知识点：</p>
<blockquote>
<p>C语言内置函数： __builtin__popcount(); 返回参数在二进制下1的个数</p>
</blockquote>
<p>复习知识点：</p>
<blockquote>
<p>位运算中 n&amp;-n 表示n在二进制中最后一个1所代表的值</p>
</blockquote>
<p>因为所有的水都是由两份相同的水合并而成的，因此每瓶水的体积一定是2^i（i ∈ N）升，最后保留k个瓶子，那么最后总的升数的二进制表示中，1的个数一定&lt;=k。</p>
<table>
<thead>
<tr>
<th>合并前</th>
<th>二进制</th>
<th>合并后</th>
</tr>
</thead>
<tbody>
<tr>
<td>1个瓶子</td>
<td>1</td>
<td>1个瓶子</td>
</tr>
<tr>
<td>2个瓶子</td>
<td>10</td>
<td>2个瓶子</td>
</tr>
<tr>
<td>3个瓶子</td>
<td>11</td>
<td>3个瓶子</td>
</tr>
<tr>
<td>4个瓶子</td>
<td>100</td>
<td>4个瓶子</td>
</tr>
<tr>
<td>5个瓶子</td>
<td>101</td>
<td>5个瓶子</td>
</tr>
<tr>
<td>6个瓶子</td>
<td>110</td>
<td>6个瓶子</td>
</tr>
<tr>
<td>7个瓶子</td>
<td>111</td>
<td>7个瓶子</td>
</tr>
<tr>
<td>8个瓶子</td>
<td>1000</td>
<td>8个瓶子</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
<p>由图显然，n个有水的瓶子，最后合并成的瓶子个数，就是这个数转成二进制1的个数。</p>
<h2 id="ac代码-23">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n,k,res = 0;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);
    while(__builtin_popcount(n) &gt; k)
    {
        res += n&amp;(-n);
        n += n&amp;(-n);
    }
    printf(&quot;%d&quot;,res);
    return 0;
}
</code></pre>
<h1 id="t24-cities-and-states-s">T24 Cities and States S</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3405">洛谷P3405</a></p>
<h2 id="题目解析-24">题目解析</h2>
<p>题目中<strong>特殊的一对</strong>类似于成对的飞地，显然在一对飞地中，其中一方的CS（City State）代码等于另一方的SC（State City）代码，进而存储一方的CS就可被另一方的SC吻合读取，特殊对数加一。要注意City代码与State代码相等的<s>本地</s>特殊城市。</p>
<h2 id="ac代码-24">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;map&gt;
using namespace std;
//typedef long long ll;

map&lt;string,int&gt; mp;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    
    int cnt = 0;
    string city,state,cs,sc;
    for(int i = 0;i &lt; n;i++)
    {
        cin &gt;&gt; city &gt;&gt; state;
        cs = city.substr(0,2) + state;
        sc = state + city.substr(0,2);
        cnt += mp[sc];
        if(cs == sc)
            cnt -= mp[cs];
        mp[cs]++;
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
} 
</code></pre>
<h1 id="t25-dreamoon-and-sets">T25 Dreamoon and Sets</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/CF476D">洛谷CF476D</a></p>
<h2 id="题目解析-25">题目解析</h2>
<p><s>第一道紫题</s><br>
<s>我觉得我得重读小学二年级</s><br>
枚举失败的我从洛谷题解中获取到了一些奇怪的知识：</p>
<blockquote>
<p>互质的一组数中a,b,c,d的值越接近,就能使最大值越小。<br>
相邻的两个正整数数是互质的，相邻的两个奇数也是互质的。<br>
连续n个正整数必有一个数能被n整除，不考虑1,2</p>
</blockquote>
<ul>
<li>a,b,c,d互质，所以a,b,c,d中最多有一个偶数 为了让四个数的值更接近，我们不妨先假设有1个偶数，3个奇数。</li>
<li>进一步转换，我们可以将a,b,c,d设为x,x+m1,x+m2,x+m3.</li>
<li>因此我们先尝试令m1=1,m2=2,即四元组中前三个数为x,x+1,x+2。由于四元组中最多只有一个偶数，故x为奇数，根据以上易证的结论可知这三个数一定互质。</li>
<li>考虑x是奇数，那么(x,x+1,x+2,x+4)<strong>一定</strong>满足要求，且不能更小。考虑x是偶数，那么(x,x+1,x+3,x+5)<strong>不一定</strong>满足要求，而且不能更小。显然x取奇数时是最优的。</li>
<li>最大数为 (n*6-1)*k</li>
<li>第一个数从1开始选，同时要保证所以四元组的第一个数为基数，每隔6个确定一个x就好了。x的通项公式即为(i-1)*6+1</li>
</ul>
<h2 id="ac代码-25">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int main()
{
    int n,k;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);
    printf(&quot;%d\n&quot;,(n*6-1) * k);
    for(int i = 1;i &lt;= n;i++)
    {
        int num = (i-1)*6+1;
        printf(&quot;%d %d %d %d\n&quot;,num*k,(num+1)*k,(num+2)*k,(num+4)*k);
    }
    return 0;
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac键盘符号和快捷键说明]]></title>
        <id>https://czyx007.top/post/mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming/</id>
        <link href="https://czyx007.top/post/mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming/">
        </link>
        <updated>2020-11-14T09:41:52.000Z</updated>
        <summary type="html"><![CDATA[<p>⌘  Command<br>
⇧  Shift<br>
⇪  CapsLock<br>
⌥  Option<br>
⌃  Control</p>
]]></summary>
        <content type="html"><![CDATA[<p>⌘  Command<br>
⇧  Shift<br>
⇪  CapsLock<br>
⌥  Option<br>
⌃  Control</p>
<!-- more -->
<p>↩  Return/Enter<br>
⌫  Delete<br>
⌦  向前删除键(Fn + Delete)<br>
↑  上箭头<br>
↓  下箭头<br>
←  左箭头<br>
→  右箭头<br>
⇞  PageUp(Fn + ↑)<br>
⇟  PageDown(Fn + ↓)<br>
Home  Fn + ←<br>
End  Fn + →<br>
⇥  右制表符(Tpb键)<br>
⇤  左制表符(Shift + Tpb)<br>
⎋  Escape(Esc)</p>
<h2 id="searchreplace查询替换">Search/Replace(查询/替换)</h2>
<p>Double Shift(⇧)  查询任何东西<br>
Command(⌘) + F  文件内查找<br>
Command(⌘) + G  查找模式下，向下查找<br>
Command(⌘) + Shift(⇧) + G  查找模式下，向上查找<br>
Command(⌘) + R  文件内替换<br>
Command(⌘) + Shift(⇧) + F  全局查找(根据路径)<br>
Command(⌘) + Shift(⇧) + R  全局替换(根据路径)<br>
Command(⌘) + Shift(⇧) + S  查询结构(Ultimate Edition 版专用，需要在Keymap中设置)<br>
Command(⌘) + Shift(⇧) + M  替换结构(Ultimate Edition 版专用，需要在Keymap中设置)</p>
<h2 id="usage-search使用查询">Usage Search(使用查询)</h2>
<p>Option(⌥) + F7 / Command(⌘) + F7  在文件中查找用法 / 在类中查找用法<br>
Command(⌘) + Shift(⇧) + F7  在文件中突出显示的用法<br>
Command(⌘) + Option(⌥) + F7  显示用法</p>
<h2 id="compile-and-run编译和运行">Compile and Run(编译和运行)</h2>
<p>Command(⌘) + F  编译Project<br>
Command(⌘) + Shift(⇧) + F9  编译选择的文件、包或模块<br>
Control(⌃) + Option(⌥) + R  弹出 Run 的可选择菜单<br>
Control(⌃) + Option(⌥) + D  弹出 Debug 的可选择菜单<br>
Control(⌃) + R  运行<br>
Control(⌃) + D  调试<br>
Control(⌃) + Shift(⇧) + R, Control(⌃) + Shift(⇧) + D  从编辑器运行上下文环境配置</p>
<h2 id="通用">通用</h2>
<p>Command(⌘) + C  复制<br>
Command(⌘) + V  粘贴</p>
<h3 id="剪切">   剪切</h3>
<p>   Step 1:Command(⌘) + C  复制<br>
   Step 2:在需要转移的文件夹位置使用Command(⌘) + Option(⌥) + V。(如果操作后悔了，还可以 Command(⌘) + Z 撤销。)</p>
<p>Command(⌘) + A  全选<br>
Command(⌘) + S  保存<br>
Command(⌘) + F  查找(Find)<br>
Command(⌘) + M  最小化窗口<br>
Command(⌘) + N  新建文件<br>
Command(⌘) + O  打开<br>
Command(⌘) + H  隐藏窗口<br>
Command(⌘) + Shift(⇧) + S  另存<br>
Command(⌘) + W  关闭<br>
Command(⌘) + Q  退出<br>
Command(⌘) + Z  撤销(如果是safari浏览器，就是恢复刚关闭的页面)<br>
Command(⌘) + Shift(⇧) + Z  重做，也就是撤销的逆向操作<br>
Command(⌘) + Option(⌥) + Esc  强制退出程序(类似于window下的任务管理器)<br>
自带的输入法(Capslock 短按中英文切换，长按英文大写)<br>
Command(⌘) + Shift(⇧) + 4  截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口<br>
Command(⌘) + Delete  将文件移至废纸篓(Windows键盘是 Win + Backspace)<br>
Command(⌘) + Shift(⇧) + Delete  清倒废纸篓(Windows键盘是 Win + Shift + Backspace)<br>
Space  快速查看选中的文件，也就是预览功能<br>
Command(⌘) + ↑  打开包含当前文件夹的文件夹，相当于Windows里的“向上”<br>
Command(⌘) + Tab  在应用程序间切换(应用处于打开且在桌面的情况)</p>
<h2 id="浏览器">浏览器</h2>
<p>Command(⌘) + L  光标直接跳至地址栏(可能被Windows响应锁屏)<br>
Command(⌘) + '+' / '='  放大页面<br>
Command(⌘) + '-'  缩小页面<br>
Control(⌃) + Tab  转向下一个标签页<br>
Control(⌃) + Shift(⇧) + Tab  转向上一个标签页<br>
Command(⌘) + R  刷新<br>
Command(⌘) + T  新建一个选项卡<br>
PageDown  向下滚动屏幕<br>
PageUp  向上滚动屏幕<br>
按下箭头键 向上、向下、向左或向右滚动<br>
按下箭头键时按住Option(⌥)键大幅度滚动<br>
enter即回车  重命名<br>
Command(⌘) + 鼠标点击  多选不连续的文件或文件夹</p>
<h2 id="其他">其他</h2>
<p>选中多个连续的文件或文件夹<br>
按住Shift(⇧)键不放，使用鼠标依次点击(或按住鼠标后拖动)希望选择的文件或者文件夹即可<br>
文件可以右键重命名<br>
如果桌面的文件不对齐排列，可以右键整理<br>
Shift(⇧) + Command(⌘) + C  打开“电脑”窗口<br>
文件右键有一个“制作替身”，相当于新建一个快捷方式</p>
]]></content>
    </entry>
</feed>