<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="君绾墨的博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>寒假回归大礼包题解 | 君绾墨的blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1610193832884">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



  <meta name="description" content="寒假回归大礼包题解" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>君绾墨的blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">君绾墨</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>在校大学生一枚</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://czyx007.top/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/zyx006">
              <i class="fa fa-github-alt" title="Github:zyx006"></i>
            </a>
          
            <a href="https://qm.qq.com/cgi-bin/qm/qr?k=I2jkn0dziL9o-T2Xcm7NG16jZzvoP7fy&amp;noverify=0">
              <i class="fa fa-qq" title="QQ:1029606625"></i>
            </a>
          
        
        
      </div>
    </div>
  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#t1-%E6%A0%87%E9%A2%98%E7%BB%9F%E8%AE%A1">T1 标题统计</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81">AC代码</a></li>
</ul>
</li>
<li><a href="#t2-davor">T2 Davor</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-2">AC代码</a></li>
</ul>
</li>
<li><a href="#t3-%E8%AF%AD%E5%8F%A5%E8%A7%A3%E6%9E%90">T3 语句解析</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-3">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-3">AC代码</a></li>
</ul>
</li>
<li><a href="#t4-%E6%95%B0%E6%A5%BC%E6%A2%AF">T4 数楼梯</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-4">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-4">AC代码</a></li>
</ul>
</li>
<li><a href="#t5-%E5%88%86%E6%95%B0%E7%BA%BF%E5%88%92%E5%AE%9A">T5 分数线划定</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-5">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-5">AC代码</a></li>
</ul>
</li>
<li><a href="#t6-%E6%B6%82%E5%9B%BD%E6%97%97">T6 涂国旗</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-6">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-6">AC代码</a></li>
</ul>
</li>
<li><a href="#t7-%E6%8B%BC%E6%95%B0">T7 拼数</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-7">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-7">AC代码</a></li>
</ul>
</li>
<li><a href="#t8-%E7%83%A4%E9%B8%A1">T8 烤鸡</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-8">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-8">AC代码</a></li>
</ul>
</li>
<li><a href="#t9-%E7%8B%AC%E6%9C%A8%E6%A1%A5">T9 独木桥</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-9">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-9">AC代码</a></li>
</ul>
</li>
<li><a href="#t10-first-step-%E3%83%95%E3%82%A1%E3%83%BC%E3%82%B9%E3%83%88%E3%82%B9%E3%83%86%E3%83%83%E3%83%97">T10 First Step (ファーストステップ)</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-10">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-10">AC代码</a></li>
</ul>
</li>
<li><a href="#t11-%E8%9C%9C%E8%9C%82%E8%B7%AF%E7%BA%BF">T11 蜜蜂路线</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-11">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-11">AC代码</a></li>
</ul>
</li>
<li><a href="#t12-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98">T12 最大公约数和最小公倍数问题</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-12">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-12">AC代码</a></li>
</ul>
</li>
<li><a href="#t13-%E7%A7%8D%E7%94%B0">T13 种田</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-13">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-13">AC代码</a></li>
</ul>
</li>
<li><a href="#t14-%E6%B7%B7%E5%90%88%E7%89%9B%E5%A5%B6-mixing-milk">T14 混合牛奶 Mixing Milk</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-14">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-14">AC代码</a></li>
</ul>
</li>
<li><a href="#t15-%E6%8E%92%E9%98%9F">T15 排队</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-15">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-15">AC代码</a></li>
</ul>
</li>
<li><a href="#t16-%E5%B0%8Fa%E7%9A%84%E7%B3%96%E6%9E%9C">T16 小A的糖果</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-16">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-16">AC代码</a></li>
</ul>
</li>
<li><a href="#t17-%E9%98%B6%E4%B9%98%E4%B9%8B%E5%92%8C">T17 阶乘之和</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-17">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-17">AC代码</a></li>
</ul>
</li>
<li><a href="#t18-%E6%89%BE%E7%AD%B7%E5%AD%90">T18   找筷子</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-18">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-18">AC代码</a></li>
</ul>
</li>
<li><a href="#t19-%E4%B8%A4%E5%8F%AA%E5%A1%94%E5%A7%86%E6%B2%83%E6%96%AF%E7%89%9B-the-tamworth-two">T19 两只塔姆沃斯牛 The Tamworth Two</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-19">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-19">AC代码</a></li>
</ul>
</li>
<li><a href="#t20-%E7%BC%96%E7%A0%81">T20 编码</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-20">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-20">AC代码</a></li>
</ul>
</li>
<li><a href="#t21-%E5%B8%AE%E8%B4%A1%E6%8E%92%E5%BA%8F">T21 帮贡排序</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-21">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-21">AC代码</a></li>
</ul>
</li>
<li><a href="#t22-%E6%95%B0%E5%88%97%E6%89%BE%E4%B8%8D%E5%90%8C">T22 数列找不同</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-22">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-22">AC代码</a></li>
</ul>
</li>
<li><a href="#t23-%E5%80%92%E6%B0%B4">T23 倒水</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-23">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-23">AC代码</a></li>
</ul>
</li>
<li><a href="#t24-cities-and-states-s">T24 Cities and States S</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-24">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-24">AC代码</a></li>
</ul>
</li>
<li><a href="#t25-dreamoon-and-sets">T25 Dreamoon and Sets</a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-25">题目解析</a></li>
<li><a href="#ac%E4%BB%A3%E7%A0%81-25">AC代码</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://czyx007.top/post/han-jia-hui-gui-da-li-bao-ti-jie/">
      寒假回归大礼包题解
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-01-06</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>34分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>6542<span class="pc-show">字数</span></span>
    </span>
    
    
    
    <span id="/post/han-jia-hui-gui-da-li-bao-ti-jie/" data-flag-title="寒假回归大礼包题解" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span>浏览量：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <p>时间跨度：01-04 17:46:10 - 01-06 23:01:46</p>
<p>关键知识点：<strong>高精度</strong>，斐波那契数列</p>
<p>部分新增知识点：</p>
<ul>
<li>C语言内置函数__builtin__popcount();</li>
<li><strong>数字之间的关系</strong>，<strong>质数的性质</strong>（数论？）</li>
</ul>
<!-- more -->
<h1 id="t1-标题统计">T1 标题统计</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5015">洛谷P5015</a></p>
<h2 id="题目解析">题目解析</h2>
<p>获取一整行字符串后计算除空格和换行符以外的字符数即可</p>
<h2 id="ac代码">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    string str;
    getline(cin,str);
    
    int cnt = 0;
    for(auto i:str)
    if(i != ' ' &amp;&amp; i != '\n')
        cnt++;
    printf(&quot;%d&quot;,cnt);
    return 0;
} 
</code></pre>
<h1 id="t2-davor">T2 Davor</h1>
<p>题目链接:<a href="https://www.luogu.com.cn/problem/P4956">洛谷P4956</a></p>
<h2 id="题目解析-2">题目解析</h2>
<p>用等差数列求出每星期筹到的金钱总额乘以总周数52，若刚好等于n则输出并中断。<br>
为了满足 x 尽可能大，k 尽可能小，应使x从100开始倒序循环。</p>
<h2 id="ac代码-2">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);

    for(int x = 100; x &gt;= 1; x--)
    {
        for(int k = 1;k &lt; 3000; k++)
        {
            int cnt = 52 * (x + x+6*k)*7/2;
            if(cnt == n)
            {
                printf(&quot;%d\n%d&quot;,x,k);
                return 0;
            }
        }
    }
    return 0;
}
</code></pre>
<h1 id="t3-语句解析">T3 语句解析</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1597">洛谷P1597</a></p>
<h2 id="题目解析-3">题目解析</h2>
<p>按照题面所给的语句格式</p>
<blockquote>
<p>变量 := 变量或一位整数;</p>
</blockquote>
<p>逐字扫描判断，以分号作为分隔符进行逐句赋值，未赋值的变量以初始值0作为终值。</p>
<h2 id="ac代码-3">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    string str;
    cin &gt;&gt; str;

    int a = 0,b = 0,c = 0;
    for(int i = 0; i &lt; str.length(); i++)
    {
        if(str[i] == 'a')
        {
            int j = i;
            while(str[j] !=';')j++;
            if(str[j-1] &gt;= '0' &amp;&amp; str[j-1] &lt;= '9')
                a = (str[j-1]-'0');
            else
            {
                if(str[j-1] == 'b')
                    a = b;
                else if(str[j-1] == 'c')
                    a = c;
            }
            i = j;
        }
        else if(str[i] == 'b')
        {
            int j = i;
            while(str[j] !=';')j++;
            if(str[j-1] &gt;= '0' &amp;&amp; str[j-1] &lt;= '9')
                b = (str[j-1]-'0');
            else
            {
                if(str[j-1] == 'a')
                    b = a;
                else if(str[j-1] == 'c')
                    b = c;
            }
            i = j;
        }
        else if(str[i] == 'c')
        {
            int j = i;
            while(str[j] !=';')j++;
            if(str[j-1] &gt;= '0' &amp;&amp; str[j-1] &lt;= '9')
                c = (str[j-1]-'0');
            else
            {
                if(str[j-1] == 'a')
                    c = a;
                else if(str[j-1] == 'b')
                    c = b;
            }
            i = j;
        }
    }
    printf(&quot;%d %d %d&quot;,a,b,c);
    return 0;
}
</code></pre>
<h1 id="t4-数楼梯">T4 数楼梯</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1255">洛谷P1255</a></p>
<h2 id="题目解析-4">题目解析</h2>
<p>本题关键知识点：<strong>高精度</strong>，<strong>斐波那契数列</strong><br>
从前几阶楼梯可以发现，上到每节楼梯的走法数分别为1,2,3,5，……，显然就是去掉第一项后的斐波那契列<br>
但题目数据范围N &lt;= 5000,斐波那契数列的值呈指数级爆炸增长，因而要使用高精度防止数据溢出。</p>
<h2 id="ac代码-4">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

const int MAXN = 5010;

int a[MAXN],b[MAXN],c[MAXN];

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);

    if(n &lt; 3)
        printf(&quot;%d&quot;,n);
    else
    {
        int cnt = 1;
        a[1] = 1,b[1] = 2;
        for(int i = 3; i &lt;= n; i++)
        {
            for(int j = 1; j &lt;= cnt; j++)
                c[j] = a[j]+b[j];
            for(int j = 1; j &lt;= cnt; j++)
            {
                if(c[j] &gt; 9)
                {
                    c[j+1] += c[j]/10;
                    c[j] %= 10;
                    if(j+1 &gt; cnt)
                        cnt++;
                }
            }
            for(int j = 1; j &lt;= cnt; j++)
                a[j] = b[j];
            for(int j = 1; j &lt;= cnt; j++)
                b[j] = c[j];
        }
        for(int i = cnt;i &gt; 0;i--)
            printf(&quot;%d&quot;,b[i]);
    }
    return 0;
}
</code></pre>
<h1 id="t5-分数线划定">T5 分数线划定</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1068">洛谷P1068</a></p>
<h2 id="题目解析-5">题目解析</h2>
<p>用结构体存储每名选手的报名号和成绩，然后依照提议解题即可，要注意cmp函数的写法。</p>
<h2 id="ac代码-5">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

struct peo
{
    int id,score;
};

bool cmp(const peo &amp;p1,const peo &amp;p2)
{
    if(p1.score != p2.score)
        return p1.score &gt; p2.score;
    else
        return p1.id &lt; p2.id;
}

int main()
{
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    int num = m * 1.5;
    struct peo p[n];

    for(int i = 0; i &lt; n; i++)
        scanf(&quot;%d %d&quot;,&amp;p[i].id,&amp;p[i].score);
    sort(p,p+n,cmp);

    int line = p[num-1].score,cnt = 0;
    for(int i = 0; p[i].score &gt;= line; i++)
        cnt++;
    printf(&quot;%d %d\n&quot;,line,cnt);
    for(int i = 0; i &lt; cnt; i++)
        printf(&quot;%d %d\n&quot;,p[i].id,p[i].score);

    return 0;
}
</code></pre>
<h1 id="t6-涂国旗">T6 涂国旗</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3392">洛谷P3392</a></p>
<h2 id="题目解析-6">题目解析</h2>
<p>预处理存储每行R/W/B三种颜色的块数，之后暴力O(n^2)枚举前两种颜色的行数(第三种颜色为剩下的行数)，用m减去某行某颜色的块数既得该行的成本，取得每次成本总和的最小值即可。</p>
<h2 id="ac代码-6">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

struct color
{
    int white,blue,red;
};

int main()
{
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    
    char ch[n][m];
    struct color c[n];

    for(int i = 0; i &lt; n; i++)
    {
        int w = 0,b = 0,r = 0;
        for(int j = 0; j &lt; m; j++)
        {
            scanf(&quot; %c&quot;,&amp;ch[i][j]);
            switch(ch[i][j])
            {
                case 'W':
                    w++;
                    break;
                case 'R':
                    r++;
                    break;
                case 'B':
                    b++;
                    break;
            }
        }
        c[i].white = w;
        c[i].blue = b;
        c[i].red = r;
    }

    int cnt = 1e7;
    for(int i = 1; i &lt;= n-2; i++)
    {
        for(int j = i+1; j &lt;= n-1; j++)
        {
            int sum = 0;
            for(int k = 1; k &lt;= i; k++)
                sum += (m-c[k-1].white);
            for(int k = i+1; k &lt;= j; k++)
                sum += (m-c[k-1].blue);
            for(int k = j+1; k &lt;= n; k++)
                sum += (m-c[k-1].red);
            cnt = min(cnt,sum);
        }
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
}
</code></pre>
<h1 id="t7-拼数">T7 拼数</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1012">洛谷P1012</a></p>
<h2 id="题目解析-7">题目解析</h2>
<p>将所有数字按字典序顺序降序排列后拼接即可。要注意cmp函数不能直接判断两字符串<br>
<s>return s1 &gt; s2;</s><br>
<u>return s1+s2 &gt; s2+s1;</u></p>
<blockquote>
<p>详见代码中注释</p>
</blockquote>
<h2 id="ac代码-7">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

vector&lt;string&gt; v; 

bool cmp(const string &amp;s1,const string &amp;s2)
{
    /*
    若用s1 &gt; s2,则结果为321 32 -&gt;32132,但最大应为32321
    使用s1+s2 &gt; s2+s1则可避免这种32132&gt;32321的情况 
    */
    return s1+s2 &gt; s2+s1;
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i = 0;i &lt; n;i++)
    {
        string str;
        cin &gt;&gt; str;
        v.push_back(str);
    }
    sort(v.begin(),v.end(),cmp);
    for(auto i:v)
        cout &lt;&lt; i;
    return 0;
} 
</code></pre>
<h1 id="t8-烤鸡">T8 烤鸡</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P2089">洛谷P2089</a></p>
<h2 id="题目解析-8">题目解析</h2>
<p>直接暴力枚举10种配料的所有搭配方案，若质量总和等于n则保存，等待输出。注意每种配料的质量都不能为0。<br>
(由于配料质量和的最大值只有30，所以n &gt; 30的可以直接输出0)</p>
<h2 id="ac代码-8">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;vector&gt;
using namespace std;
//typedef long long ll;

vector&lt;vector&lt;int&gt; &gt; v;
vector&lt;int&gt; vs;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    
    int cnt = 0;
    for(int q = 1;q &lt;= 3;q++)
    for(int w = 1;w &lt;= 3;w++)
    for(int e = 1;e &lt;= 3;e++)
    for(int r = 1;r &lt;= 3;r++)
    for(int t = 1;t &lt;= 3;t++)
    for(int y = 1;y &lt;= 3;y++)
    for(int u = 1;u &lt;= 3;u++)
    for(int i = 1;i &lt;= 3;i++)
    for(int o = 1;o &lt;= 3;o++)
    for(int p = 1;p &lt;= 3;p++)
        if(q+w+e+r+t+y+u+i+o+p == n)
        {
            vs.push_back(q);
            vs.push_back(w);
            vs.push_back(e);
            vs.push_back(r);
            vs.push_back(t);
            vs.push_back(y);
            vs.push_back(u);
            vs.push_back(i);
            vs.push_back(o);
            vs.push_back(p);
            v.push_back(vs);
            vs.clear();
            cnt++;
        }
    
    printf(&quot;%d\n&quot;,cnt);
    for(auto i:v)
    {
        for(auto j:i)
            printf(&quot;%d &quot;,j);
        printf(&quot;\n&quot;);
    }
    return 0;
} 
</code></pre>
<h1 id="t9-独木桥">T9 独木桥</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1007">洛谷P1007</a></p>
<h2 id="题目解析-9">题目解析</h2>
<p>首先，不用考虑题目中的这一因素的影响：</p>
<blockquote>
<p>但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。</p>
</blockquote>
<p>引用洛谷题解中很形象的两个例子：</p>
<blockquote>
<p>首先自行脑补一下，假装你正在20000米高空的轰炸机上用高倍显微镜望远镜默默欣赏士兵离开，你会发现什么东西？一堆花花绿绿的迷彩服在移动。（不是鬼片！不是鬼片！不是鬼片！重要的事情说三遍）<br>
那么当两个士兵撞在一起时，从你的视角看会发生什么？当然他们认为他们都掉头了，但因为你在特高的地方，你会认为他们“穿过”了对方。换言之，这与他们相互穿过并没有任何区别。</p>
</blockquote>
<blockquote>
<p>两个人相遇转身，相当于交换灵魂后继续走</p>
</blockquote>
<p>那么问题就很简单了，最大值就是最靠近端点的两个人各自向对方方向走下桥,时间较长的那个人的时间，最小值就是所有人走完桥的时间的最小值的最大值。</p>
<h2 id="ac代码-9">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int l,n;
    scanf(&quot;%d %d&quot;,&amp;l,&amp;n);
    
    int pos[n]={0};
    for(int i = 0;i &lt; n;i++)
        scanf(&quot;%d&quot;,&amp;pos[i]);
    sort(pos,pos+n,greater&lt;int&gt;());
    int ma = max(pos[0],l-pos[n-1]+1);
    int mi = 0;
    for(int i = 0;i &lt; n;i++)
    {
        int tmp = min(pos[i],l-pos[i]+1);
        mi = max(tmp,mi);
    }
    printf(&quot;%d %d&quot;,mi,ma);
    return 0;
} 
</code></pre>
<h1 id="t10-first-step-ファーストステップ">T10 First Step (ファーストステップ)</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3654">洛谷P3654</a></p>
<h2 id="题目解析-10">题目解析</h2>
<p>枚举每个可站点，判断该点向右方和向下方各有多少种站位方式<br>
要注意k=1的情况下，横着站和竖着站一样，因而要进行特判，此时站位方式数量就是可站点的数量。</p>
<h2 id="ac代码-10">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int r,c,k;
    scanf(&quot;%d %d %d&quot;,&amp;r,&amp;c,&amp;k);

    int po = 0;
    char gym[r][c];
    for(int i = 0; i &lt; r; i++)
        for(int j = 0; j &lt; c; j++)
        {
            scanf(&quot; %c&quot;,&amp;gym[i][j]);
            if(gym[i][j] == '.')
                po++;
        }

    if(k == 1)
    {
        printf(&quot;%d&quot;,po);
        return 0;
    }
    int cnt = 0,sum = 0;
    for(int i = 0; i &lt; r; i++)
    {
        for(int j = 0; j &lt; c; j++)
        {
            if(gym[i][j] == '.')
            {
                if(i &lt; r-1)
                {
                    sum = 0;
                    for(int q = j; q &lt; c; q++)
                    {
                        if(gym[i][q] == '.')
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                    sum = 0;
                    for(int q = i; q &lt; r; q++)
                    {
                        if(gym[q][j] == '.')
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                }
                else
                {
                    sum = 0;
                    for(int q = j; q &lt; c; q++)
                    {
                        if(gym[i][q] == '.')
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                }
            }
        }
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
}
</code></pre>
<h1 id="t11-蜜蜂路线">T11 蜜蜂路线</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P2437">洛谷P2437</a></p>
<h2 id="题目解析-11">题目解析</h2>
<blockquote>
<p>类似题目 T4数楼梯：<a href="https://www.luogu.com.cn/problem/P1255">洛谷P1255</a></p>
</blockquote>
<p>本题需用到<strong>高精度</strong>和<strong>斐波那契数列</strong><br>
不同的是本题中最终结果并不是从斐波那契数列第一项加起，它的起始项(左端点)是变化的。</p>
<h2 id="ac代码-11">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;cstring&gt;
using namespace std;
//typedef long long ll;

const int MAXN = 5010;

int a[MAXN]= {1,1},b[MAXN]= {1},c[MAXN];

int main()
{
    int m,n;
    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);

    for(int i = m+1; i &lt;= n; i++)
    {
        for(int j = 0; j &lt;= a[0]; j++)
            c[j] = a[j];
        for(int j = 1; j &lt;= a[0]; j++)
        {
            a[j] += b[j];
            a[j+1] += a[j]/10;
            a[j] %= 10;
        }
        while(a[a[0]+1]&gt;0)
            a[0]++;
        memset(b,sizeof(b),0);
        for(int j = 0; j &lt;= c[0]; j++)
            b[j] = c[j];
    }
    for(int i = a[0]; i &gt;= 1; i--)
        printf(&quot;%d&quot;,a[i]);
    return 0;
}
</code></pre>
<h1 id="t12-最大公约数和最小公倍数问题">T12 最大公约数和最小公倍数问题</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1029">洛谷P1029</a></p>
<h2 id="题目解析-12">题目解析</h2>
<p>以x,y为端点进行O(n^2) 枚举,由于本题数据范围是10^5,为了防止TLE需要进行优化，只用枚举max(x,y)的所有因子即可。</p>
<h2 id="ac代码-12">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
//typedef long long ll;

vector&lt;int&gt; v;
void getnum(int a);

int main()
{
    int x,y;
    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);
    
    getnum(max(x,y));
    
    int cnt = 0,size = v.size();
    for(int i = 0;i &lt; size;i++)
    {
        for(int j = size-1;j &gt;= 0;j--)
        {
            int gnum = __gcd(v[i],v[j]);
            int LCD = (v[i] * v[j]) / gnum;
            if(gnum == x &amp;&amp; LCD == y)
                cnt++;
        }
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
}

void getnum(int a)
{
    for(int i = 1;i &lt;= a;i++)
        if(a % i == 0)
            v.push_back(i);
}
</code></pre>
<h1 id="t13-种田">T13 种田</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P2660">洛谷P2660</a></p>
<h2 id="题目解析-13">题目解析</h2>
<blockquote>
<p>类似题目 第四周题单-统计方形：<a href="https://www.luogu.com.cn/problem/P2241">洛谷P2241</a></p>
</blockquote>
<p>不同的是，上题是统计所有方形的数量，而这题是每次切割最大正方形，每次以最短边为边长切割，体力值即为每次所切割的正方形的周长之和。但单单这样写会在最后一个测试点被10^16的数据卡TLE，只能拿90分，因而要进行优化，不能一个正方形一个正方形的切，要一次切多个，也就是切max(x,y)/min(x,y)个。</p>
<h2 id="ac代码-13">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
typedef long long ll;

int main()
{
    ll n,m;
    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);

    ll res = 0;
    while(n != 0 &amp;&amp; m != 0)
    {
        ll mi = min(n,m);
        if(n &lt; m)
        {
            res += 4 * (m/mi) * mi;
            m %= mi;
        }
        else
        {
            res += 4 * (n/mi) * mi;
            n %= mi;
        }
    }
    printf(&quot;%lld&quot;,res);
    return 0;
}
</code></pre>
<h1 id="t14-混合牛奶-mixing-milk">T14 混合牛奶 Mixing Milk</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1208">洛谷P1208</a></p>
<h2 id="题目解析-14">题目解析</h2>
<p>用结构体存储每位农民的单价和最大量，按单价从低到高进行排序，依次购买直至购买量等于所需量时即求出最小费用。</p>
<h2 id="ac代码-14">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

struct farmer{
    int price,sum;	
};

bool cmp(const farmer &amp;f1,const farmer &amp;f2)
{
    return f1.price &lt; f2.price;
}

int main()
{
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    struct farmer f[m];
    
    for(int i = 0;i &lt; m;i++)
        scanf(&quot;%d %d&quot;,&amp;f[i].price,&amp;f[i].sum);
    sort(f,f+m,cmp);
    
    int su = 0,money = 0;
    for(int i = 0;i &lt; m;i++)
    {
        if(su + f[i].sum &lt;= n)
        {
            su += f[i].sum;
            money += f[i].price * f[i].sum;
        }
        else
        {
            money += f[i].price * (n - su);
            break;
        }
    }
    printf(&quot;%d&quot;,money);
    return 0;
} 
</code></pre>
<h1 id="t15-排队">T15 排队</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P5412">洛谷P5412</a></p>
<h2 id="题目解析-15">题目解析</h2>
<p>结构体存储按身高从矮到高排序，最后用cout输出即可。</p>
<h2 id="ac代码-15">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

struct stu
{
    int sex;
    double height;
};

bool cmp(const stu &amp;s1,const stu &amp;s2)
{
    return s1.height &lt; s2.height;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        struct stu s[n];
        for(int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;,&amp;s[i].sex);
        for(int i = 0; i &lt; n; i++)
            scanf(&quot;%lf&quot;,&amp;s[i].height);
        
        sort(s,s+n,cmp);
        for(int i = 0; i &lt; n; i++)
            if(s[i].sex == 0)
                cout &lt;&lt; s[i].height &lt;&lt; ' ';
        printf(&quot;\n&quot;);
        for(int i = 0; i &lt; n; i++)
            if(s[i].sex == 1)
                cout &lt;&lt; s[i].height &lt;&lt; ' ';
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="t16-小a的糖果">T16 小A的糖果</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3817">洛谷P3817</a></p>
<h2 id="题目解析-16">题目解析</h2>
<p>从左到右依次遍历，若左右之和大于x则将<strong>右侧数</strong>减去<strong>两数之和与x的差</strong> ，结果即为每次该差的总和。</p>
<h2 id="ac代码-16">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
typedef long long ll;

int main()
{
    ll n,x;
    scanf(&quot;%lld %lld&quot;,&amp;n,&amp;x);
    ll num[n] = {0};
    
    for(int i = 0;i &lt; n;i++)
        scanf(&quot;%lld&quot;,&amp;num[i]);
        
    ll cnt = 0;
    for(ll i = 0;i &lt; n-1;i++)
    {
        if(num[i] + num[i+1] &gt; x)
        {
            cnt += num[i]+num[i+1]-x;
            num[i+1] -= num[i]+num[i+1]-x;
        }
    }
    printf(&quot;%lld&quot;,cnt);
    return 0;
} 
</code></pre>
<h1 id="t17-阶乘之和">T17 阶乘之和</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1009">洛谷P1009</a></p>
<h2 id="题目解析-17">题目解析</h2>
<p><strong>高精度加法</strong>与<strong>高精度乘法</strong>结合</p>
<h2 id="ac代码-17">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

const int MAXN = 2e3;

int a[MAXN]= {1},b[MAXN];

void plu(int a[],int b[])
{
    int more = 0;
    for(int i = 0; i &lt; 1000; i++)
    {
        b[i] += a[i] + more;
        more = b[i]/10;
        b[i] %= 10;
    }
}

void mul(int a[],int b)
{
    int more = 0;
    for(int i = 0; i &lt; 1000; i++)
    {
        a[i] = a[i] * b + more;
        more = a[i]/10;
        a[i] %= 10;
    }
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i = 1; i &lt;= n; i++)
    {
        mul(a,i);
        plu(a,b);
    }

    int flag = 0;
    for(int i = 999; i &gt;= 0; i--)
    {
        if(b[i])
            flag = 1;
        if(flag)
            printf(&quot;%d&quot;,b[i]);
    }
    return 0;
}
</code></pre>
<h1 id="t18-找筷子">T18   找筷子</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1469">洛谷P1469</a></p>
<h2 id="题目解析-18">题目解析</h2>
<p>利用位运算异或的性质即可，偶数个相同的数异或结果为0，因而将所有筷子长度异或起来的结果即为落单的筷子的长度。</p>
<h2 id="ac代码-18">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int len,res;
    for(int i = 0;i &lt; n;i++)
    {
        scanf(&quot;%d&quot;,&amp;len);
        if(i &gt; 0)
            res ^= len;
        else if(i == 0)
            res = len;
    }
    printf(&quot;%d&quot;,res);
    return 0;
} 
</code></pre>
<h1 id="t19-两只塔姆沃斯牛-the-tamworth-two">T19 两只塔姆沃斯牛 The Tamworth Two</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1518">洛谷P1518</a></p>
<h2 id="题目解析-19">题目解析</h2>
<p>结构体存储坐标和方向，不断循环即可，若某次移动结束后坐标重合即相遇，输出时间（即循环次数），若循环次数过大时（例10^6次）仍未相遇，即可判定永远不会相遇。</p>
<h2 id="ac代码-19">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

char map[10][10];

struct farmer
{
    int x,y;
    char dire = 'n';//East South West North
} f;

struct cow
{
    int x,y;
    char dire = 'n';
} c;

int main()
{
    for(int i = 0; i &lt; 10; i++)
        for(int j = 0; j &lt; 10; j++)
        {
            scanf(&quot; %c&quot;,&amp;map[i][j]);
            if(map[i][j] == 'F')
            {
                f.x = i;
                f.y = j;
            }
            else if(map[i][j] == 'C')
            {
                c.x = i;
                c.y = j;
            }
        }

    int cnt = 0;
    while(!(f.x == c.x &amp;&amp; f.y == c.y))
    {
        switch(f.dire)
        {
            case 'n':
                if(f.x != 0)
                {
                    if(map[f.x-1][f.y] != '*')
                        f.x--;
                    else
                        f.dire = 'e';
                }
                else
                    f.dire = 'e';
                break;
            case 'e':
                if(f.y != 9)
                {
                    if(map[f.x][f.y+1] != '*')
                        f.y++;
                    else
                        f.dire = 's';
                }
                else
                    f.dire = 's';
                break;
            case 's':
                if(f.x != 9)
                {
                    if(map[f.x+1][f.y] != '*')
                        f.x++;
                    else
                        f.dire = 'w';
                }
                else
                    f.dire = 'w';
                break;
            case 'w':
                if(f.y != 0)
                {
                    if(map[f.x][f.y-1] != '*')
                        f.y--;
                    else
                        f.dire = 'n';
                }
                else
                    f.dire = 'n';
                break;
        }
        switch(c.dire)
        {
            case 'n':
                if(c.x != 0)
                {
                    if(map[c.x-1][c.y] != '*')
                        c.x--;
                    else
                        c.dire = 'e';
                }
                else
                    c.dire = 'e';
                break;
            case 'e':
                if(c.y != 9)
                {
                    if(map[c.x][c.y+1] != '*')
                        c.y++;
                    else
                        c.dire = 's';
                }
                else
                    c.dire = 's';
                break;
            case 's':
                if(c.x != 9)
                {
                    if(map[c.x+1][c.y] != '*')
                        c.x++;
                    else
                        c.dire = 'w';
                }
                else
                    c.dire = 'w';
                break;
            case 'w':
                if(c.y != 0)
                {
                    if(map[c.x][c.y-1] != '*')
                        c.y--;
                    else
                        c.dire = 'n';
                }
                else
                    c.dire = 'n';
                break;
        }
        cnt++;
        if(cnt &gt; 1e6)
        {
            printf(&quot;0&quot;);
            return 0;
        }
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
}
</code></pre>
<h1 id="t20-编码">T20 编码</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1246">洛谷P1246</a></p>
<h2 id="题目解析-20">题目解析</h2>
<p>暴力枚举判断是否相等即可，要注意字母按升序排列，也就是不可能出现zoo之类的单词<br>
<s>刚刚才发现我读入字符串写的竟然是scanf(&quot;%s&quot;,&amp;str);竟然还AC了，离谱，编译器之前竟然没报警告</s></p>
<h2 id="ac代码-20">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;cstring&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int cnt = 1;
    char str[7],s[7];
    
    scanf(&quot;%s&quot;,str);
    
    for(char i = 'a'; i &lt;= 'z'; i++)
    {
        s[1] = '\0';
        s[0] = i;
        if(strcmp(str,s) == 0)
        {
            printf(&quot;%d&quot;,cnt);
            return 0;
        }
        cnt++;
    }

    for(char i = 'a'; i &lt;= 'y'; i++)
        for(char j = i+1; j &lt;= 'z'; j++)
        {
            s[2] = '\0';
            s[1] = j;
            s[0] = i;
            if(strcmp(str,s) == 0)
            {
                printf(&quot;%d&quot;,cnt);
                return 0;
            }
            cnt++;
        }

    for(char i = 'a'; i &lt;= 'x'; i++)
        for(char j = i+1; j &lt;= 'y'; j++)
            for(char k = j+1; k &lt;= 'z'; k++)
            {
                s[3] = '\0';
                s[2] = k;
                s[1] = j;
                s[0] = i;
                if(strcmp(str,s) == 0)
                {
                    printf(&quot;%d&quot;,cnt);
                    return 0;
                }
                cnt++;
            }

    for(char i = 'a'; i &lt;= 'w'; i++)
        for(char j = i+1; j &lt;= 'x'; j++)
            for(char k = j+1; k &lt;= 'y'; k++)
                for(char q = k+1; q &lt;= 'z'; q++)
                {
                    s[4] = '\0';
                    s[3] = q;
                    s[2] = k;
                    s[1] = j;
                    s[0] = i;
                    if(strcmp(str,s) == 0)
                    {
                        printf(&quot;%d&quot;,cnt);
                        return 0;
                    }
                    cnt++;
                }


    for(char i = 'a'; i &lt;= 'v'; i++)
        for(char j = i+1; j &lt;= 'w'; j++)
            for(char k = j+1; k &lt;= 'x'; k++)
                for(char q = k+1; q &lt;= 'y'; q++)
                    for(char w = q+1; w &lt;= 'z'; w++)
                    {
                        s[5] = '\0';
                        s[4] = w;
                        s[3] = q;
                        s[2] = k;
                        s[1] = j;
                        s[0] = i;
                        if(strcmp(str,s) == 0)
                        {
                            printf(&quot;%d&quot;,cnt);
                            return 0;
                        }
                        cnt++;
                    }

    for(char i = 'a'; i &lt;= 'u'; i++)
        for(char j = i+1; j &lt;= 'v'; j++)
            for(char k = j+1; k &lt;= 'w'; k++)
                for(char q = k+1; q &lt;= 'x'; q++)
                    for(char w = q+1; w &lt;= 'y'; w++)
                        for(char e = w+1; e &lt;= 'z'; e++)
                        {
                            s[6] = '\0';
                            s[5] = e;
                            s[4] = w;
                            s[3] = q;
                            s[2] = k;
                            s[1] = j;
                            s[0] = i;
                            if(strcmp(str,s) == 0)
                            {
                                printf(&quot;%d&quot;,cnt);
                                return 0;
                            }
                            cnt++;
                        }
    printf(&quot;0&quot;);
    return 0;
}
</code></pre>
<h1 id="t21-帮贡排序">T21 帮贡排序</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1786">洛谷P1786</a></p>
<h2 id="题目解析-21">题目解析</h2>
<p>按照题意即可，要注意调整职位和输出时的排序方式不同，要写两个cmp函数，调整职位和输出前要分别调用一次sort函数。<br>
<s>一定要注意职位的大小写，不然一个字母的差别就是全WA与全AC的差别</s></p>
<h2 id="ac代码-21">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

enum prof
{
    BangZhong,JingYing,TangZhu,ZhangLao,HuFa,FuBangZhu,BangZhu
};

struct org
{
    string name;
    int pro,con,level,index;
};

bool cmp1(const org &amp;o1,const org &amp;o2)
{
    if(o1.con != o2.con)
        return o1.con &gt; o2.con;
    else
        return o1.index &lt; o2.index;
}

bool cmp2(const org &amp;o1,const org &amp;o2)
{
    if(o1.pro != o2.pro)
        return o1.pro &gt; o2.pro;
    else if(o1.level != o2.level)
        return o1.level &gt; o2.level;
    else
        return o1.index &lt; o2.index;
}

int bz,fbz,hf,zl,tz,jy,baz;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    struct org o[n];
    for(int i = 0; i &lt; n; i++)
    {
        string pr;
        cin &gt;&gt; o[i].name &gt;&gt; pr;
        scanf(&quot;%d %d&quot;,&amp;o[i].con,&amp;o[i].level);
        o[i].index = i;
        if(pr == &quot;BangZhu&quot;)
            o[i].pro = BangZhu;
        else if(pr == &quot;FuBangZhu&quot;)
            o[i].pro = FuBangZhu;
        else if(pr == &quot;HuFa&quot;)
            o[i].pro = HuFa;
        else if(pr == &quot;ZhangLao&quot;)
            o[i].pro = ZhangLao;
        else if(pr == &quot;TangZhu&quot;)
            o[i].pro = TangZhu;
        else if(pr == &quot;JingYing&quot;)
            o[i].pro = JingYing;
        else if(pr == &quot;BangZhong&quot;)
            o[i].pro = BangZhong;
    }
    
    sort(o,o+n,cmp1);
    for(int i = 0; i &lt; n; i++)
    {
        if(o[i].pro &lt;= HuFa &amp;&amp; o[i].name != &quot;absi2011&quot;)
        {
            if(hf &lt; 2)
            {
                o[i].pro = HuFa;
                hf++;
            }
            else if(zl &lt; 4)
            {
                o[i].pro = ZhangLao;
                zl++;
            }
            else if(tz &lt; 7)
            {
                o[i].pro = TangZhu;
                tz++;
            }
            else if(jy &lt; 25)
            {
                o[i].pro = JingYing;
                jy++;
            }
            else
            {
                o[i].pro = BangZhong;
                baz++;
            }
        }
    }
    
    sort(o,o+n,cmp2);
    for(auto i:o)
    {
        cout &lt;&lt; i.name &lt;&lt; &quot; &quot;;
        switch(i.pro)
        {
            case BangZhu:
                printf(&quot;BangZhu&quot;);/*打成Bangzhu导致全WA，改正后全AC*/
                break;
            case FuBangZhu:
                printf(&quot;FuBangZhu&quot;);
                break;
            case HuFa:
                printf(&quot;HuFa&quot;);
                break;
            case ZhangLao:
                printf(&quot;ZhangLao&quot;);
                break;
            case TangZhu:
                printf(&quot;TangZhu&quot;);
                break;
            case JingYing:
                printf(&quot;JingYing&quot;);
                break;
            case BangZhong:
                printf(&quot;BangZhong&quot;);
                break;
        }
        printf(&quot; %d\n&quot;,i.level);
    }
    return 0;
}
</code></pre>
<h1 id="t22-数列找不同">T22 数列找不同</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3901">洛谷P3901</a></p>
<h2 id="题目解析-22">题目解析</h2>
<p>预处理不断循环找出每个区间内各数互不相同的最长区间，每次固定右端点找出最小左端点，若询问的左端点小于对应的最小左端点即可判断存在相同的数。</p>
<h2 id="ac代码-22">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
//typedef long long ll;

const int MAXN = 1e6;

int num[MAXN],a[MAXN];//num[i]-&gt;以第i个数为右端点时左端点的最小值

int main()
{
    int n,q;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;q);

    int k;
    for(int i = 1; i &lt;= n; i++)
    {
        scanf(&quot;%d&quot;,&amp;k);
        num[i] = max(num[i-1],a[k]+1);
        a[k] = i;
    }
    while(q--)
    {
        int l,r;
        scanf(&quot;%d %d&quot;,&amp;l,&amp;r);
        if(num[r] &lt;= l)
            printf(&quot;Yes\n&quot;);
        else
            printf(&quot;No\n&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="t23-倒水">T23 倒水</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1582">洛谷P1582</a></p>
<h2 id="题目解析-23">题目解析</h2>
<p><a href="https://www.luogu.com.cn/problem/solution/P1582"><s>洛谷题解里果然都是神犇</s></a></p>
<p>新增知识点：</p>
<blockquote>
<p>C语言内置函数： __builtin__popcount(); 返回参数在二进制下1的个数</p>
</blockquote>
<p>复习知识点：</p>
<blockquote>
<p>位运算中 n&amp;-n 表示n在二进制中最后一个1所代表的值</p>
</blockquote>
<p>因为所有的水都是由两份相同的水合并而成的，因此每瓶水的体积一定是2^i（i ∈ N）升，最后保留k个瓶子，那么最后总的升数的二进制表示中，1的个数一定&lt;=k。</p>
<table>
<thead>
<tr>
<th>合并前</th>
<th>二进制</th>
<th>合并后</th>
</tr>
</thead>
<tbody>
<tr>
<td>1个瓶子</td>
<td>1</td>
<td>1个瓶子</td>
</tr>
<tr>
<td>2个瓶子</td>
<td>10</td>
<td>2个瓶子</td>
</tr>
<tr>
<td>3个瓶子</td>
<td>11</td>
<td>3个瓶子</td>
</tr>
<tr>
<td>4个瓶子</td>
<td>100</td>
<td>4个瓶子</td>
</tr>
<tr>
<td>5个瓶子</td>
<td>101</td>
<td>5个瓶子</td>
</tr>
<tr>
<td>6个瓶子</td>
<td>110</td>
<td>6个瓶子</td>
</tr>
<tr>
<td>7个瓶子</td>
<td>111</td>
<td>7个瓶子</td>
</tr>
<tr>
<td>8个瓶子</td>
<td>1000</td>
<td>8个瓶子</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
<p>由图显然，n个有水的瓶子，最后合并成的瓶子个数，就是这个数转成二进制1的个数。</p>
<h2 id="ac代码-23">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n,k,res = 0;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);
    while(__builtin_popcount(n) &gt; k)
    {
        res += n&amp;(-n);
        n += n&amp;(-n);
    }
    printf(&quot;%d&quot;,res);
    return 0;
}
</code></pre>
<h1 id="t24-cities-and-states-s">T24 Cities and States S</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3405">洛谷P3405</a></p>
<h2 id="题目解析-24">题目解析</h2>
<p>题目中<strong>特殊的一对</strong>类似于成对的飞地，显然在一对飞地中，其中一方的CS（City State）代码等于另一方的SC（State City）代码，进而存储一方的CS就可被另一方的SC吻合读取，特殊对数加一。要注意City代码与State代码相等的<s>本地</s>特殊城市。</p>
<h2 id="ac代码-24">AC代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;map&gt;
using namespace std;
//typedef long long ll;

map&lt;string,int&gt; mp;

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    
    int cnt = 0;
    string city,state,cs,sc;
    for(int i = 0;i &lt; n;i++)
    {
        cin &gt;&gt; city &gt;&gt; state;
        cs = city.substr(0,2) + state;
        sc = state + city.substr(0,2);
        cnt += mp[sc];
        if(cs == sc)
            cnt -= mp[cs];
        mp[cs]++;
    }
    printf(&quot;%d&quot;,cnt);
    return 0;
} 
</code></pre>
<h1 id="t25-dreamoon-and-sets">T25 Dreamoon and Sets</h1>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/CF476D">洛谷CF476D</a></p>
<h2 id="题目解析-25">题目解析</h2>
<p><s>第一道紫题</s><br>
<s>我觉得我得重读小学二年级</s><br>
枚举失败的我从洛谷题解中获取到了一些奇怪的知识：</p>
<blockquote>
<p>互质的一组数中a,b,c,d的值越接近,就能使最大值越小。<br>
相邻的两个正整数数是互质的，相邻的两个奇数也是互质的。<br>
连续n个正整数必有一个数能被n整除，不考虑1,2</p>
</blockquote>
<ul>
<li>a,b,c,d互质，所以a,b,c,d中最多有一个偶数 为了让四个数的值更接近，我们不妨先假设有1个偶数，3个奇数。</li>
<li>进一步转换，我们可以将a,b,c,d设为x,x+m1,x+m2,x+m3.</li>
<li>因此我们先尝试令m1=1,m2=2,即四元组中前三个数为x,x+1,x+2。由于四元组中最多只有一个偶数，故x为奇数，根据以上易证的结论可知这三个数一定互质。</li>
<li>考虑x是奇数，那么(x,x+1,x+2,x+4)<strong>一定</strong>满足要求，且不能更小。考虑x是偶数，那么(x,x+1,x+3,x+5)<strong>不一定</strong>满足要求，而且不能更小。显然x取奇数时是最优的。</li>
<li>最大数为 (n*6-1)*k</li>
<li>第一个数从1开始选，同时要保证所以四元组的第一个数为基数，每隔6个确定一个x就好了。x的通项公式即为(i-1)*6+1</li>
</ul>
<h2 id="ac代码-25">AC代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int main()
{
    int n,k;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);
    printf(&quot;%d\n&quot;,(n*6-1) * k);
    for(int i = 1;i &lt;= n;i++)
    {
        int num = (i-1)*6+1;
        printf(&quot;%d %d %d %d\n&quot;,num*k,(num+1)*k,(num+2)*k,(num+4)*k);
    }
    return 0;
}</code></pre>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      君绾墨
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://czyx007.top/post/han-jia-hui-gui-da-li-bao-ti-jie/" title="寒假回归大礼包题解">https://czyx007.top/post/han-jia-hui-gui-da-li-bao-ti-jie/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="数学专题一题解" href="https://czyx007.top/post/shu-xue-zhuan-ti-yi-ti-jie/">数学专题一题解</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="数学专题一题解" href="https://czyx007.top/post/shu-xue-zhuan-ti-yi-ti-jie/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Mac键盘符号和快捷键说明" href="https://czyx007.top/post/mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming/">Mac键盘符号和快捷键说明</a>
        <a class="nav-mobile-next" title="Mac键盘符号和快捷键说明" href="https://czyx007.top/post/mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.4/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('https://upimage.alexhchu.com/2020/04/21/47eda59424daa.gif');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'I2glXAwPdvDE1Re5gNIXP4gz-gzGzoHsz',
    appKey: 'c6Sjq0TH6GiGiKzO1DOOTvqY',
    avatar: '',
    placeholder: '撰写评论…',
    pageSize: '',
    lang: 'zh-cn',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      ©2020-2021 君绾墨
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    <div class="bg-img">
      <img src="https://gitee.com/gentlemans_ink/blogimage/raw/master/img/20210103124339.jpg" />
    </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://czyx007.top/post/shu-xue-zhuan-ti-yi-ti-jie/"" data-c="
          &lt;p&gt;时间跨度：01-07 15:52:16 - 01-09 18:19:02&lt;br&gt;
&lt;s&gt;(8号摸鱼去了)&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;强化知识点：&lt;br&gt;
&lt;strong&gt;埃氏筛&lt;/strong&gt;，&lt;strong&gt;分解质因数&lt;/strong&gt;，&lt;strong&gt;快速幂&lt;/strong&gt;，&lt;strong&gt;逆元&lt;/strong&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;t1-快速幂取余运算&#34;&gt;T1 快速幂||取余运算&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1226&#34;&gt;洛谷P1226&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;快速幂模板题，按题意最后取余即可&lt;/p&gt;
&lt;h2 id=&#34;ac代码&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

ll fastpow(ll x,ll y,ll mod)
{
    x %= mod;
    ll res = 1;
    while(y)
    {
        if(y&amp;amp;1)
            res = res * x % mod;
        y &amp;gt;&amp;gt;= 1;
        x = x * x % mod;  
    }
    return res;
}

int main()
{
    ll b,p,k;
    scanf(&amp;quot;%lld %lld %lld&amp;quot;,&amp;amp;b,&amp;amp;p,&amp;amp;k);
    printf(&amp;quot;%lld^%lld mod %lld=%lld&amp;quot;,b,p,k,fastpow(b,p,k)%k);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t2-线性筛素数&#34;&gt;T2 线性筛素数&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3383&#34;&gt;洛谷P3383&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-2&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;埃氏筛优化，保证每个合数只被筛一遍。将每个素数依次存入数组中，第k小的素数即为数组中第k-1个元素。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-2&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e8+10;
int prime[MAXN];
ll num[MAXN];

void isPrime(ll n)
{
    ll cnt = 0;
    prime[0] = prime[1] = 1;
    for(ll i = 2; i &amp;lt;= n; i++)
    {
        if(!prime[i])
            num[cnt++] = i;
        for(ll j = 0; j &amp;lt; cnt &amp;amp;&amp;amp; i*num[j] &amp;lt; MAXN; j++)
        {
            prime[i*num[j]] = 1;
            if(i%num[j] == 0)
                break;
        }
    }
}

int main()
{

    int n,q;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;q);

    isPrime(n);
    int k;
    while(q--)
    {
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);
        printf(&amp;quot;%lld\n&amp;quot;,num[k-1]);
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t3-乘法逆元&#34;&gt;T3 乘法逆元&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3811&#34;&gt;洛谷P3811&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-3&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;需用到逆元递推公式：inv[i] = (p-p/i) * inv[p%i] % p;&lt;/p&gt;
&lt;h2 id=&#34;ac代码-3&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e7;

ll inv[MAXN];

int main()
{
    ll n,p;
    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;p);
    
    inv[1] = 1;
    printf(&amp;quot;1\n&amp;quot;);
    for(int i = 2; i &amp;lt;= n; i++)
    {
        inv[i] = (p-p/i) * inv[p%i] % p;
        printf(&amp;quot;%lld\n&amp;quot;,inv[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t4-乘法逆元2&#34;&gt;T4 乘法逆元2&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P5431&#34;&gt;洛谷P5431&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-4&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;先通分后取模，每次k乘上k本身（k,k&lt;sup&gt;2,k&lt;/sup&gt;3，不用快速幂），通分求和后分子乘上分母的逆元再取模即为结果。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-4&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

ll p;

const int MAXN = 5e6+10;
ll num[MAXN];

ll fastpow(ll x,ll y)
{
    x %= p;
    ll res = 1;
    while(y)
    {
        if(y&amp;amp;1)
            res = res * x % p;
        y &amp;gt;&amp;gt;= 1;
        x = x * x % p;
    }
    return res;
}

ll inv(ll x)
{
    return fastpow(x,p-2);
}

int main()
{
    ll n,k;
    scanf(&amp;quot;%lld %lld %lld&amp;quot;,&amp;amp;n,&amp;amp;p,&amp;amp;k);
    ll t = k%p;	
    
    ll up = 0,down = 1;
    for(ll i = 0; i &amp;lt; n; i++)
    {
        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;num[i]);
        up = (up*num[i]+down*t)%p;
        down = down * num[i] % p;
        t = t * k % p;
    }
    printf(&amp;quot;%lld&amp;quot;,up*inv(down)%p);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t5-质数口袋&#34;&gt;T5 质数口袋&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P5723&#34;&gt;洛谷P5723&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-5&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;埃氏筛打表后每次从头遍历即可，注意打表数组要开bool型数组，不然会MLE。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-5&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e5;
bool prime[MAXN];

void isPrime()
{
    prime[0] = prime[1] = true;
    for(ll i = 2; i*i &amp;lt;= MAXN; i++)
    {
        if(!prime[i])
            for(ll j = i*i; j &amp;lt;= MAXN; j += i)
                prime[j] = true;
    }
}

int main()
{
    int L;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;L);

    isPrime();
    int sum = 0,cnt = 0;
    for(int i = 2;; i++)
    {
        if(!prime[i])
        {
            if(sum + i &amp;lt;= L)
            {
                sum += i;
                cnt++;
                printf(&amp;quot;%d\n&amp;quot;,i);
            }
            else
                break;
        }
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t6-回文质数&#34;&gt;T6 回文质数&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1217&#34;&gt;洛谷P1217&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-6&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;这道题我是用提前打表写的，打表后直接查询遍历输出即可。&lt;/p&gt;
&lt;h4 id=&#34;打表代码&#34;&gt;打表代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

const int MAXN = 100000010;
bool prime[MAXN];

void isPrime()
{
    prime[0] = prime[1] = true;
    for(ll i = 2;i*i &amp;lt;= MAXN;i++)
    {
        if(!prime[i])
            for(ll j = i*i;j &amp;lt;= MAXN;j += i)
                prime[j] = true;
    }
}

ll reverse( ll number )
{
    ll num = 0,flag = 0;
    if(number &amp;lt; 0)
    {
        number = -number;
        flag = 1;
    }
    while(number)
    {
        num += number % 10;
        if((number &amp;gt; 10) || (number % 10 == 0))
            num *= 10;
        number /= 10;
    }
    if(flag)
        num = -num;
    return num;
}

int main()
{
    FILE *fp;
    fp = fopen(&amp;quot;1.txt&amp;quot;,&amp;quot;w&amp;quot;);
    isPrime();
    for(ll i = 0;i &amp;lt;= MAXN;i++)
        if(!prime[i])
        {
            if(i == reverse(i))
                fprintf(fp,&amp;quot;%lld,&amp;quot;,i);
        }
    fclose(fp);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ac代码-6&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
//typedef long long ll;

int prime[] = {5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899};

int main()
{
    int a,b;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;a,&amp;amp;b);
    for(auto i:prime)
        if(i &amp;gt;= a &amp;amp;&amp;amp; i &amp;lt;= b)
            printf(&amp;quot;%d\n&amp;quot;,i);
        else if(i &amp;gt; b)
            break;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t7-哥德巴赫猜想升级版&#34;&gt;T7 哥德巴赫猜想（升级版）&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1579&#34;&gt;洛谷P1579&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-7&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;埃氏筛打表后双重循环找出符合条件的一组输出即可。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-7&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e6+10;
int prime[MAXN];

void isPrime()
{
    prime[0] = prime[1] = 1;
    for (ll i = 2; i * i &amp;lt; MAXN; i++)
    {
        if (!prime[i])
        {
            for (ll j = i * i; j &amp;lt; MAXN; j += i)
                prime[j] = 1;
        }
    }
}

int main()
{
    isPrime();

    int n;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
    for(int i = 2; i &amp;lt; n-1; i++)
        for(int j = 2; j &amp;lt; n-1-i; j++)
        {
            int k = n-i-j;
            if(prime[i] == 0 &amp;amp;&amp;amp; prime[j] == 0 &amp;amp;&amp;amp; prime[k] == 0)
                if(i+j+k == n)
                {
                    printf(&amp;quot;%d %d %d&amp;quot;, i, j, k);
                    return 0;
                }
        }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t8-a-b-problem&#34;&gt;T8 A % B Problem&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1865&#34;&gt;洛谷P1865&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-8&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;埃氏筛打表后每次在区间内遍历即可，注意判断区间是否成立。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-8&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e6+10;
bool prime[MAXN];

void isPrime()
{
    prime[0] = prime[1] = true;
    for(ll i = 2;i*i &amp;lt;= MAXN;i++)
    {
        if(!prime[i])
            for(ll j = i*i;j &amp;lt;= MAXN;j += i)
                prime[j] = true;
    }
}

int main()
{
    int n,m;
    int l,r;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);
    
    isPrime();
    while(n--)
    {
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;r);
        if(l &amp;gt;= 1 &amp;amp;&amp;amp; l &amp;lt;= m &amp;amp;&amp;amp; r &amp;gt;= 1 &amp;amp;&amp;amp; r &amp;lt;= m &amp;amp;&amp;amp; l &amp;lt;= r)
        {
            int cnt = 0;
            for(int i = l;i &amp;lt;= r;i++)
                if(!prime[i])
                    cnt++;
            printf(&amp;quot;%d\n&amp;quot;,cnt);
        }
        else
            printf(&amp;quot;Crossing the line\n&amp;quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t9-素数个数&#34;&gt;T9 素数个数&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3912&#34;&gt;洛谷P3912&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-9&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;埃氏筛打表时统计素数个数，打表完成后直接输出个数即可。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-9&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

const int MAXN = 1e8+10;
bool prime[MAXN];

void isPrime(ll n)
{
    ll cnt = 0;
    prime[0] = prime[1] = 1;
    for(ll i = 2;i &amp;lt;= n;i++)
    {
        if(!prime[i])
        {
            cnt++;
            for(ll j = i*i;j &amp;lt;= n;j += i)
                prime[j] = true;
        }
    }
    printf(&amp;quot;%lld&amp;quot;,cnt); 
}

int main()
{
    ll n;
    scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n);
    isPrime(n);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t10-因子和&#34;&gt;T10 因子和&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1593&#34;&gt;洛谷P1593&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-10&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;逐渐看不懂的题解&lt;/s&gt;&lt;br&gt;
分解质因数并记录每个质因数的个数（记为幂数一起存储），结果为所有质因数等比数列求和再相乘。&lt;br&gt;
（要注意特判逆元为0的情况）&lt;br&gt;
&lt;img src=&#34;https://gitee.com/gentlemans_ink/blogimage/raw/master/img/20210109193417.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ac代码-10&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

const int mod = 9901,MAXN = 1e6;
ll num[MAXN][2],sum[MAXN];

ll fastpow(ll x,ll y)
{
    x %= mod;
    ll res = 1;
    while(y)
    {
        if(y&amp;amp;1)
            res = res * x % mod;
        y &amp;gt;&amp;gt;= 1;
        x = x * x % mod;
    }
    return res;
}

ll inv(ll x)
{
    return fastpow(x,mod-2)%mod;
}

int main()
{
    ll a,b;
    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;a,&amp;amp;b);
    ll t = a;
    
    ll cnt = 0;
    for(ll i = 2;i*i &amp;lt;= a;i++)
    {
        if(t%i == 0)
            num[++cnt][0] = i;
        while(t%i == 0)
        {
            num[cnt][1]++;
            t /= i;
        }
    }
    if(t != 1)
    {
        num[++cnt][0] = t;
        num[cnt][1] = 1;
    }
    
    ll res = 1;
    for(ll i = 1;i &amp;lt;= cnt;i++)
    {
        sum[i] = (fastpow(num[i][0],num[i][1]*b+1)-1)*inv(num[i][0]-1)%mod;
        if(sum[i] == 0)
            sum[i] = num[i][1]*b+1;
        res = res * sum[i] % mod;
    }
    printf(&amp;quot;%lld&amp;quot;,(res%mod+mod)%mod);
    return 0;
}&lt;/code&gt;&lt;/pre&gt;
">数学专题一题解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://czyx007.top/post/han-jia-hui-gui-da-li-bao-ti-jie/"" data-c="
          &lt;p&gt;时间跨度：01-04 17:46:10 - 01-06 23:01:46&lt;/p&gt;
&lt;p&gt;关键知识点：&lt;strong&gt;高精度&lt;/strong&gt;，斐波那契数列&lt;/p&gt;
&lt;p&gt;部分新增知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C语言内置函数__builtin__popcount();&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字之间的关系&lt;/strong&gt;，&lt;strong&gt;质数的性质&lt;/strong&gt;（数论？）&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;t1-标题统计&#34;&gt;T1 标题统计&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P5015&#34;&gt;洛谷P5015&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;获取一整行字符串后计算除空格和换行符以外的字符数即可&lt;/p&gt;
&lt;h2 id=&#34;ac代码&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    string str;
    getline(cin,str);
    
    int cnt = 0;
    for(auto i:str)
    if(i != &#39; &#39; &amp;amp;&amp;amp; i != &#39;\n&#39;)
        cnt++;
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t2-davor&#34;&gt;T2 Davor&lt;/h1&gt;
&lt;p&gt;题目链接:&lt;a href=&#34;https://www.luogu.com.cn/problem/P4956&#34;&gt;洛谷P4956&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-2&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;用等差数列求出每星期筹到的金钱总额乘以总周数52，若刚好等于n则输出并中断。&lt;br&gt;
为了满足 x 尽可能大，k 尽可能小，应使x从100开始倒序循环。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-2&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);

    for(int x = 100; x &amp;gt;= 1; x--)
    {
        for(int k = 1;k &amp;lt; 3000; k++)
        {
            int cnt = 52 * (x + x+6*k)*7/2;
            if(cnt == n)
            {
                printf(&amp;quot;%d\n%d&amp;quot;,x,k);
                return 0;
            }
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t3-语句解析&#34;&gt;T3 语句解析&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1597&#34;&gt;洛谷P1597&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-3&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;按照题面所给的语句格式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;变量 := 变量或一位整数;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;逐字扫描判断，以分号作为分隔符进行逐句赋值，未赋值的变量以初始值0作为终值。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-3&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    string str;
    cin &amp;gt;&amp;gt; str;

    int a = 0,b = 0,c = 0;
    for(int i = 0; i &amp;lt; str.length(); i++)
    {
        if(str[i] == &#39;a&#39;)
        {
            int j = i;
            while(str[j] !=&#39;;&#39;)j++;
            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)
                a = (str[j-1]-&#39;0&#39;);
            else
            {
                if(str[j-1] == &#39;b&#39;)
                    a = b;
                else if(str[j-1] == &#39;c&#39;)
                    a = c;
            }
            i = j;
        }
        else if(str[i] == &#39;b&#39;)
        {
            int j = i;
            while(str[j] !=&#39;;&#39;)j++;
            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)
                b = (str[j-1]-&#39;0&#39;);
            else
            {
                if(str[j-1] == &#39;a&#39;)
                    b = a;
                else if(str[j-1] == &#39;c&#39;)
                    b = c;
            }
            i = j;
        }
        else if(str[i] == &#39;c&#39;)
        {
            int j = i;
            while(str[j] !=&#39;;&#39;)j++;
            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)
                c = (str[j-1]-&#39;0&#39;);
            else
            {
                if(str[j-1] == &#39;a&#39;)
                    c = a;
                else if(str[j-1] == &#39;b&#39;)
                    c = b;
            }
            i = j;
        }
    }
    printf(&amp;quot;%d %d %d&amp;quot;,a,b,c);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t4-数楼梯&#34;&gt;T4 数楼梯&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1255&#34;&gt;洛谷P1255&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-4&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;本题关键知识点：&lt;strong&gt;高精度&lt;/strong&gt;，&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;br&gt;
从前几阶楼梯可以发现，上到每节楼梯的走法数分别为1,2,3,5，……，显然就是去掉第一项后的斐波那契列&lt;br&gt;
但题目数据范围N &amp;lt;= 5000,斐波那契数列的值呈指数级爆炸增长，因而要使用高精度防止数据溢出。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-4&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

const int MAXN = 5010;

int a[MAXN],b[MAXN],c[MAXN];

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);

    if(n &amp;lt; 3)
        printf(&amp;quot;%d&amp;quot;,n);
    else
    {
        int cnt = 1;
        a[1] = 1,b[1] = 2;
        for(int i = 3; i &amp;lt;= n; i++)
        {
            for(int j = 1; j &amp;lt;= cnt; j++)
                c[j] = a[j]+b[j];
            for(int j = 1; j &amp;lt;= cnt; j++)
            {
                if(c[j] &amp;gt; 9)
                {
                    c[j+1] += c[j]/10;
                    c[j] %= 10;
                    if(j+1 &amp;gt; cnt)
                        cnt++;
                }
            }
            for(int j = 1; j &amp;lt;= cnt; j++)
                a[j] = b[j];
            for(int j = 1; j &amp;lt;= cnt; j++)
                b[j] = c[j];
        }
        for(int i = cnt;i &amp;gt; 0;i--)
            printf(&amp;quot;%d&amp;quot;,b[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t5-分数线划定&#34;&gt;T5 分数线划定&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1068&#34;&gt;洛谷P1068&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-5&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;用结构体存储每名选手的报名号和成绩，然后依照提议解题即可，要注意cmp函数的写法。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-5&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

struct peo
{
    int id,score;
};

bool cmp(const peo &amp;amp;p1,const peo &amp;amp;p2)
{
    if(p1.score != p2.score)
        return p1.score &amp;gt; p2.score;
    else
        return p1.id &amp;lt; p2.id;
}

int main()
{
    int n,m;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);
    int num = m * 1.5;
    struct peo p[n];

    for(int i = 0; i &amp;lt; n; i++)
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;p[i].id,&amp;amp;p[i].score);
    sort(p,p+n,cmp);

    int line = p[num-1].score,cnt = 0;
    for(int i = 0; p[i].score &amp;gt;= line; i++)
        cnt++;
    printf(&amp;quot;%d %d\n&amp;quot;,line,cnt);
    for(int i = 0; i &amp;lt; cnt; i++)
        printf(&amp;quot;%d %d\n&amp;quot;,p[i].id,p[i].score);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t6-涂国旗&#34;&gt;T6 涂国旗&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3392&#34;&gt;洛谷P3392&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-6&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;预处理存储每行R/W/B三种颜色的块数，之后暴力O(n^2)枚举前两种颜色的行数(第三种颜色为剩下的行数)，用m减去某行某颜色的块数既得该行的成本，取得每次成本总和的最小值即可。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-6&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

struct color
{
    int white,blue,red;
};

int main()
{
    int n,m;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);
    
    char ch[n][m];
    struct color c[n];

    for(int i = 0; i &amp;lt; n; i++)
    {
        int w = 0,b = 0,r = 0;
        for(int j = 0; j &amp;lt; m; j++)
        {
            scanf(&amp;quot; %c&amp;quot;,&amp;amp;ch[i][j]);
            switch(ch[i][j])
            {
                case &#39;W&#39;:
                    w++;
                    break;
                case &#39;R&#39;:
                    r++;
                    break;
                case &#39;B&#39;:
                    b++;
                    break;
            }
        }
        c[i].white = w;
        c[i].blue = b;
        c[i].red = r;
    }

    int cnt = 1e7;
    for(int i = 1; i &amp;lt;= n-2; i++)
    {
        for(int j = i+1; j &amp;lt;= n-1; j++)
        {
            int sum = 0;
            for(int k = 1; k &amp;lt;= i; k++)
                sum += (m-c[k-1].white);
            for(int k = i+1; k &amp;lt;= j; k++)
                sum += (m-c[k-1].blue);
            for(int k = j+1; k &amp;lt;= n; k++)
                sum += (m-c[k-1].red);
            cnt = min(cnt,sum);
        }
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t7-拼数&#34;&gt;T7 拼数&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1012&#34;&gt;洛谷P1012&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-7&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;将所有数字按字典序顺序降序排列后拼接即可。要注意cmp函数不能直接判断两字符串&lt;br&gt;
&lt;s&gt;return s1 &amp;gt; s2;&lt;/s&gt;&lt;br&gt;
&lt;u&gt;return s1+s2 &amp;gt; s2+s1;&lt;/u&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;详见代码中注释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ac代码-7&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

vector&amp;lt;string&amp;gt; v; 

bool cmp(const string &amp;amp;s1,const string &amp;amp;s2)
{
    /*
    若用s1 &amp;gt; s2,则结果为321 32 -&amp;gt;32132,但最大应为32321
    使用s1+s2 &amp;gt; s2+s1则可避免这种32132&amp;gt;32321的情况 
    */
    return s1+s2 &amp;gt; s2+s1;
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    for(int i = 0;i &amp;lt; n;i++)
    {
        string str;
        cin &amp;gt;&amp;gt; str;
        v.push_back(str);
    }
    sort(v.begin(),v.end(),cmp);
    for(auto i:v)
        cout &amp;lt;&amp;lt; i;
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t8-烤鸡&#34;&gt;T8 烤鸡&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P2089&#34;&gt;洛谷P2089&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-8&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;直接暴力枚举10种配料的所有搭配方案，若质量总和等于n则保存，等待输出。注意每种配料的质量都不能为0。&lt;br&gt;
(由于配料质量和的最大值只有30，所以n &amp;gt; 30的可以直接输出0)&lt;/p&gt;
&lt;h2 id=&#34;ac代码-8&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
//typedef long long ll;

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; v;
vector&amp;lt;int&amp;gt; vs;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    
    int cnt = 0;
    for(int q = 1;q &amp;lt;= 3;q++)
    for(int w = 1;w &amp;lt;= 3;w++)
    for(int e = 1;e &amp;lt;= 3;e++)
    for(int r = 1;r &amp;lt;= 3;r++)
    for(int t = 1;t &amp;lt;= 3;t++)
    for(int y = 1;y &amp;lt;= 3;y++)
    for(int u = 1;u &amp;lt;= 3;u++)
    for(int i = 1;i &amp;lt;= 3;i++)
    for(int o = 1;o &amp;lt;= 3;o++)
    for(int p = 1;p &amp;lt;= 3;p++)
        if(q+w+e+r+t+y+u+i+o+p == n)
        {
            vs.push_back(q);
            vs.push_back(w);
            vs.push_back(e);
            vs.push_back(r);
            vs.push_back(t);
            vs.push_back(y);
            vs.push_back(u);
            vs.push_back(i);
            vs.push_back(o);
            vs.push_back(p);
            v.push_back(vs);
            vs.clear();
            cnt++;
        }
    
    printf(&amp;quot;%d\n&amp;quot;,cnt);
    for(auto i:v)
    {
        for(auto j:i)
            printf(&amp;quot;%d &amp;quot;,j);
        printf(&amp;quot;\n&amp;quot;);
    }
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t9-独木桥&#34;&gt;T9 独木桥&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1007&#34;&gt;洛谷P1007&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-9&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;首先，不用考虑题目中的这一因素的影响：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引用洛谷题解中很形象的两个例子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先自行脑补一下，假装你正在20000米高空的轰炸机上用高倍显微镜望远镜默默欣赏士兵离开，你会发现什么东西？一堆花花绿绿的迷彩服在移动。（不是鬼片！不是鬼片！不是鬼片！重要的事情说三遍）&lt;br&gt;
那么当两个士兵撞在一起时，从你的视角看会发生什么？当然他们认为他们都掉头了，但因为你在特高的地方，你会认为他们“穿过”了对方。换言之，这与他们相互穿过并没有任何区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;两个人相遇转身，相当于交换灵魂后继续走&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么问题就很简单了，最大值就是最靠近端点的两个人各自向对方方向走下桥,时间较长的那个人的时间，最小值就是所有人走完桥的时间的最小值的最大值。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-9&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int l,n;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;n);
    
    int pos[n]={0};
    for(int i = 0;i &amp;lt; n;i++)
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;pos[i]);
    sort(pos,pos+n,greater&amp;lt;int&amp;gt;());
    int ma = max(pos[0],l-pos[n-1]+1);
    int mi = 0;
    for(int i = 0;i &amp;lt; n;i++)
    {
        int tmp = min(pos[i],l-pos[i]+1);
        mi = max(tmp,mi);
    }
    printf(&amp;quot;%d %d&amp;quot;,mi,ma);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t10-first-step-ファーストステップ&#34;&gt;T10 First Step (ファーストステップ)&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3654&#34;&gt;洛谷P3654&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-10&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;枚举每个可站点，判断该点向右方和向下方各有多少种站位方式&lt;br&gt;
要注意k=1的情况下，横着站和竖着站一样，因而要进行特判，此时站位方式数量就是可站点的数量。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-10&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int r,c,k;
    scanf(&amp;quot;%d %d %d&amp;quot;,&amp;amp;r,&amp;amp;c,&amp;amp;k);

    int po = 0;
    char gym[r][c];
    for(int i = 0; i &amp;lt; r; i++)
        for(int j = 0; j &amp;lt; c; j++)
        {
            scanf(&amp;quot; %c&amp;quot;,&amp;amp;gym[i][j]);
            if(gym[i][j] == &#39;.&#39;)
                po++;
        }

    if(k == 1)
    {
        printf(&amp;quot;%d&amp;quot;,po);
        return 0;
    }
    int cnt = 0,sum = 0;
    for(int i = 0; i &amp;lt; r; i++)
    {
        for(int j = 0; j &amp;lt; c; j++)
        {
            if(gym[i][j] == &#39;.&#39;)
            {
                if(i &amp;lt; r-1)
                {
                    sum = 0;
                    for(int q = j; q &amp;lt; c; q++)
                    {
                        if(gym[i][q] == &#39;.&#39;)
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                    sum = 0;
                    for(int q = i; q &amp;lt; r; q++)
                    {
                        if(gym[q][j] == &#39;.&#39;)
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                }
                else
                {
                    sum = 0;
                    for(int q = j; q &amp;lt; c; q++)
                    {
                        if(gym[i][q] == &#39;.&#39;)
                            sum++;
                        else
                            break;
                        if(sum == k)
                        {
                            cnt++;
                            break;
                        }
                    }
                }
            }
        }
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t11-蜜蜂路线&#34;&gt;T11 蜜蜂路线&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P2437&#34;&gt;洛谷P2437&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-11&#34;&gt;题目解析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;类似题目 T4数楼梯：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1255&#34;&gt;洛谷P1255&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本题需用到&lt;strong&gt;高精度&lt;/strong&gt;和&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;br&gt;
不同的是本题中最终结果并不是从斐波那契数列第一项加起，它的起始项(左端点)是变化的。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-11&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
//typedef long long ll;

const int MAXN = 5010;

int a[MAXN]= {1,1},b[MAXN]= {1},c[MAXN];

int main()
{
    int m,n;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;m,&amp;amp;n);

    for(int i = m+1; i &amp;lt;= n; i++)
    {
        for(int j = 0; j &amp;lt;= a[0]; j++)
            c[j] = a[j];
        for(int j = 1; j &amp;lt;= a[0]; j++)
        {
            a[j] += b[j];
            a[j+1] += a[j]/10;
            a[j] %= 10;
        }
        while(a[a[0]+1]&amp;gt;0)
            a[0]++;
        memset(b,sizeof(b),0);
        for(int j = 0; j &amp;lt;= c[0]; j++)
            b[j] = c[j];
    }
    for(int i = a[0]; i &amp;gt;= 1; i--)
        printf(&amp;quot;%d&amp;quot;,a[i]);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t12-最大公约数和最小公倍数问题&#34;&gt;T12 最大公约数和最小公倍数问题&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1029&#34;&gt;洛谷P1029&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-12&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;以x,y为端点进行O(n^2) 枚举,由于本题数据范围是10^5,为了防止TLE需要进行优化，只用枚举max(x,y)的所有因子即可。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-12&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
//typedef long long ll;

vector&amp;lt;int&amp;gt; v;
void getnum(int a);

int main()
{
    int x,y;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x,&amp;amp;y);
    
    getnum(max(x,y));
    
    int cnt = 0,size = v.size();
    for(int i = 0;i &amp;lt; size;i++)
    {
        for(int j = size-1;j &amp;gt;= 0;j--)
        {
            int gnum = __gcd(v[i],v[j]);
            int LCD = (v[i] * v[j]) / gnum;
            if(gnum == x &amp;amp;&amp;amp; LCD == y)
                cnt++;
        }
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
}

void getnum(int a)
{
    for(int i = 1;i &amp;lt;= a;i++)
        if(a % i == 0)
            v.push_back(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t13-种田&#34;&gt;T13 种田&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P2660&#34;&gt;洛谷P2660&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-13&#34;&gt;题目解析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;类似题目 第四周题单-统计方形：&lt;a href=&#34;https://www.luogu.com.cn/problem/P2241&#34;&gt;洛谷P2241&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同的是，上题是统计所有方形的数量，而这题是每次切割最大正方形，每次以最短边为边长切割，体力值即为每次所切割的正方形的周长之和。但单单这样写会在最后一个测试点被10^16的数据卡TLE，只能拿90分，因而要进行优化，不能一个正方形一个正方形的切，要一次切多个，也就是切max(x,y)/min(x,y)个。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-13&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef long long ll;

int main()
{
    ll n,m;
    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;m);

    ll res = 0;
    while(n != 0 &amp;amp;&amp;amp; m != 0)
    {
        ll mi = min(n,m);
        if(n &amp;lt; m)
        {
            res += 4 * (m/mi) * mi;
            m %= mi;
        }
        else
        {
            res += 4 * (n/mi) * mi;
            n %= mi;
        }
    }
    printf(&amp;quot;%lld&amp;quot;,res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t14-混合牛奶-mixing-milk&#34;&gt;T14 混合牛奶 Mixing Milk&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1208&#34;&gt;洛谷P1208&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-14&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;用结构体存储每位农民的单价和最大量，按单价从低到高进行排序，依次购买直至购买量等于所需量时即求出最小费用。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-14&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

struct farmer{
    int price,sum;	
};

bool cmp(const farmer &amp;amp;f1,const farmer &amp;amp;f2)
{
    return f1.price &amp;lt; f2.price;
}

int main()
{
    int n,m;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);
    struct farmer f[m];
    
    for(int i = 0;i &amp;lt; m;i++)
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;f[i].price,&amp;amp;f[i].sum);
    sort(f,f+m,cmp);
    
    int su = 0,money = 0;
    for(int i = 0;i &amp;lt; m;i++)
    {
        if(su + f[i].sum &amp;lt;= n)
        {
            su += f[i].sum;
            money += f[i].price * f[i].sum;
        }
        else
        {
            money += f[i].price * (n - su);
            break;
        }
    }
    printf(&amp;quot;%d&amp;quot;,money);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t15-排队&#34;&gt;T15 排队&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P5412&#34;&gt;洛谷P5412&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-15&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;结构体存储按身高从矮到高排序，最后用cout输出即可。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-15&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

struct stu
{
    int sex;
    double height;
};

bool cmp(const stu &amp;amp;s1,const stu &amp;amp;s2)
{
    return s1.height &amp;lt; s2.height;
}

int main()
{
    int t;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
    while(t--)
    {
        int n;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
        struct stu s[n];
        for(int i = 0; i &amp;lt; n; i++)
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;s[i].sex);
        for(int i = 0; i &amp;lt; n; i++)
            scanf(&amp;quot;%lf&amp;quot;,&amp;amp;s[i].height);
        
        sort(s,s+n,cmp);
        for(int i = 0; i &amp;lt; n; i++)
            if(s[i].sex == 0)
                cout &amp;lt;&amp;lt; s[i].height &amp;lt;&amp;lt; &#39; &#39;;
        printf(&amp;quot;\n&amp;quot;);
        for(int i = 0; i &amp;lt; n; i++)
            if(s[i].sex == 1)
                cout &amp;lt;&amp;lt; s[i].height &amp;lt;&amp;lt; &#39; &#39;;
        printf(&amp;quot;\n&amp;quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t16-小a的糖果&#34;&gt;T16 小A的糖果&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3817&#34;&gt;洛谷P3817&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-16&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;从左到右依次遍历，若左右之和大于x则将&lt;strong&gt;右侧数&lt;/strong&gt;减去&lt;strong&gt;两数之和与x的差&lt;/strong&gt; ，结果即为每次该差的总和。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-16&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
typedef long long ll;

int main()
{
    ll n,x;
    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;x);
    ll num[n] = {0};
    
    for(int i = 0;i &amp;lt; n;i++)
        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;num[i]);
        
    ll cnt = 0;
    for(ll i = 0;i &amp;lt; n-1;i++)
    {
        if(num[i] + num[i+1] &amp;gt; x)
        {
            cnt += num[i]+num[i+1]-x;
            num[i+1] -= num[i]+num[i+1]-x;
        }
    }
    printf(&amp;quot;%lld&amp;quot;,cnt);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t17-阶乘之和&#34;&gt;T17 阶乘之和&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1009&#34;&gt;洛谷P1009&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-17&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;高精度加法&lt;/strong&gt;与&lt;strong&gt;高精度乘法&lt;/strong&gt;结合&lt;/p&gt;
&lt;h2 id=&#34;ac代码-17&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

const int MAXN = 2e3;

int a[MAXN]= {1},b[MAXN];

void plu(int a[],int b[])
{
    int more = 0;
    for(int i = 0; i &amp;lt; 1000; i++)
    {
        b[i] += a[i] + more;
        more = b[i]/10;
        b[i] %= 10;
    }
}

void mul(int a[],int b)
{
    int more = 0;
    for(int i = 0; i &amp;lt; 1000; i++)
    {
        a[i] = a[i] * b + more;
        more = a[i]/10;
        a[i] %= 10;
    }
}

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    for(int i = 1; i &amp;lt;= n; i++)
    {
        mul(a,i);
        plu(a,b);
    }

    int flag = 0;
    for(int i = 999; i &amp;gt;= 0; i--)
    {
        if(b[i])
            flag = 1;
        if(flag)
            printf(&amp;quot;%d&amp;quot;,b[i]);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t18-找筷子&#34;&gt;T18   找筷子&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1469&#34;&gt;洛谷P1469&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-18&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;利用位运算异或的性质即可，偶数个相同的数异或结果为0，因而将所有筷子长度异或起来的结果即为落单的筷子的长度。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-18&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    int len,res;
    for(int i = 0;i &amp;lt; n;i++)
    {
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;len);
        if(i &amp;gt; 0)
            res ^= len;
        else if(i == 0)
            res = len;
    }
    printf(&amp;quot;%d&amp;quot;,res);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t19-两只塔姆沃斯牛-the-tamworth-two&#34;&gt;T19 两只塔姆沃斯牛 The Tamworth Two&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1518&#34;&gt;洛谷P1518&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-19&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;结构体存储坐标和方向，不断循环即可，若某次移动结束后坐标重合即相遇，输出时间（即循环次数），若循环次数过大时（例10^6次）仍未相遇，即可判定永远不会相遇。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-19&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

char map[10][10];

struct farmer
{
    int x,y;
    char dire = &#39;n&#39;;//East South West North
} f;

struct cow
{
    int x,y;
    char dire = &#39;n&#39;;
} c;

int main()
{
    for(int i = 0; i &amp;lt; 10; i++)
        for(int j = 0; j &amp;lt; 10; j++)
        {
            scanf(&amp;quot; %c&amp;quot;,&amp;amp;map[i][j]);
            if(map[i][j] == &#39;F&#39;)
            {
                f.x = i;
                f.y = j;
            }
            else if(map[i][j] == &#39;C&#39;)
            {
                c.x = i;
                c.y = j;
            }
        }

    int cnt = 0;
    while(!(f.x == c.x &amp;amp;&amp;amp; f.y == c.y))
    {
        switch(f.dire)
        {
            case &#39;n&#39;:
                if(f.x != 0)
                {
                    if(map[f.x-1][f.y] != &#39;*&#39;)
                        f.x--;
                    else
                        f.dire = &#39;e&#39;;
                }
                else
                    f.dire = &#39;e&#39;;
                break;
            case &#39;e&#39;:
                if(f.y != 9)
                {
                    if(map[f.x][f.y+1] != &#39;*&#39;)
                        f.y++;
                    else
                        f.dire = &#39;s&#39;;
                }
                else
                    f.dire = &#39;s&#39;;
                break;
            case &#39;s&#39;:
                if(f.x != 9)
                {
                    if(map[f.x+1][f.y] != &#39;*&#39;)
                        f.x++;
                    else
                        f.dire = &#39;w&#39;;
                }
                else
                    f.dire = &#39;w&#39;;
                break;
            case &#39;w&#39;:
                if(f.y != 0)
                {
                    if(map[f.x][f.y-1] != &#39;*&#39;)
                        f.y--;
                    else
                        f.dire = &#39;n&#39;;
                }
                else
                    f.dire = &#39;n&#39;;
                break;
        }
        switch(c.dire)
        {
            case &#39;n&#39;:
                if(c.x != 0)
                {
                    if(map[c.x-1][c.y] != &#39;*&#39;)
                        c.x--;
                    else
                        c.dire = &#39;e&#39;;
                }
                else
                    c.dire = &#39;e&#39;;
                break;
            case &#39;e&#39;:
                if(c.y != 9)
                {
                    if(map[c.x][c.y+1] != &#39;*&#39;)
                        c.y++;
                    else
                        c.dire = &#39;s&#39;;
                }
                else
                    c.dire = &#39;s&#39;;
                break;
            case &#39;s&#39;:
                if(c.x != 9)
                {
                    if(map[c.x+1][c.y] != &#39;*&#39;)
                        c.x++;
                    else
                        c.dire = &#39;w&#39;;
                }
                else
                    c.dire = &#39;w&#39;;
                break;
            case &#39;w&#39;:
                if(c.y != 0)
                {
                    if(map[c.x][c.y-1] != &#39;*&#39;)
                        c.y--;
                    else
                        c.dire = &#39;n&#39;;
                }
                else
                    c.dire = &#39;n&#39;;
                break;
        }
        cnt++;
        if(cnt &amp;gt; 1e6)
        {
            printf(&amp;quot;0&amp;quot;);
            return 0;
        }
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t20-编码&#34;&gt;T20 编码&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1246&#34;&gt;洛谷P1246&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-20&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;暴力枚举判断是否相等即可，要注意字母按升序排列，也就是不可能出现zoo之类的单词&lt;br&gt;
&lt;s&gt;刚刚才发现我读入字符串写的竟然是scanf(&amp;quot;%s&amp;quot;,&amp;amp;str);竟然还AC了，离谱，编译器之前竟然没报警告&lt;/s&gt;&lt;/p&gt;
&lt;h2 id=&#34;ac代码-20&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;cstring&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int cnt = 1;
    char str[7],s[7];
    
    scanf(&amp;quot;%s&amp;quot;,str);
    
    for(char i = &#39;a&#39;; i &amp;lt;= &#39;z&#39;; i++)
    {
        s[1] = &#39;\0&#39;;
        s[0] = i;
        if(strcmp(str,s) == 0)
        {
            printf(&amp;quot;%d&amp;quot;,cnt);
            return 0;
        }
        cnt++;
    }

    for(char i = &#39;a&#39;; i &amp;lt;= &#39;y&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;z&#39;; j++)
        {
            s[2] = &#39;\0&#39;;
            s[1] = j;
            s[0] = i;
            if(strcmp(str,s) == 0)
            {
                printf(&amp;quot;%d&amp;quot;,cnt);
                return 0;
            }
            cnt++;
        }

    for(char i = &#39;a&#39;; i &amp;lt;= &#39;x&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;y&#39;; j++)
            for(char k = j+1; k &amp;lt;= &#39;z&#39;; k++)
            {
                s[3] = &#39;\0&#39;;
                s[2] = k;
                s[1] = j;
                s[0] = i;
                if(strcmp(str,s) == 0)
                {
                    printf(&amp;quot;%d&amp;quot;,cnt);
                    return 0;
                }
                cnt++;
            }

    for(char i = &#39;a&#39;; i &amp;lt;= &#39;w&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;x&#39;; j++)
            for(char k = j+1; k &amp;lt;= &#39;y&#39;; k++)
                for(char q = k+1; q &amp;lt;= &#39;z&#39;; q++)
                {
                    s[4] = &#39;\0&#39;;
                    s[3] = q;
                    s[2] = k;
                    s[1] = j;
                    s[0] = i;
                    if(strcmp(str,s) == 0)
                    {
                        printf(&amp;quot;%d&amp;quot;,cnt);
                        return 0;
                    }
                    cnt++;
                }


    for(char i = &#39;a&#39;; i &amp;lt;= &#39;v&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;w&#39;; j++)
            for(char k = j+1; k &amp;lt;= &#39;x&#39;; k++)
                for(char q = k+1; q &amp;lt;= &#39;y&#39;; q++)
                    for(char w = q+1; w &amp;lt;= &#39;z&#39;; w++)
                    {
                        s[5] = &#39;\0&#39;;
                        s[4] = w;
                        s[3] = q;
                        s[2] = k;
                        s[1] = j;
                        s[0] = i;
                        if(strcmp(str,s) == 0)
                        {
                            printf(&amp;quot;%d&amp;quot;,cnt);
                            return 0;
                        }
                        cnt++;
                    }

    for(char i = &#39;a&#39;; i &amp;lt;= &#39;u&#39;; i++)
        for(char j = i+1; j &amp;lt;= &#39;v&#39;; j++)
            for(char k = j+1; k &amp;lt;= &#39;w&#39;; k++)
                for(char q = k+1; q &amp;lt;= &#39;x&#39;; q++)
                    for(char w = q+1; w &amp;lt;= &#39;y&#39;; w++)
                        for(char e = w+1; e &amp;lt;= &#39;z&#39;; e++)
                        {
                            s[6] = &#39;\0&#39;;
                            s[5] = e;
                            s[4] = w;
                            s[3] = q;
                            s[2] = k;
                            s[1] = j;
                            s[0] = i;
                            if(strcmp(str,s) == 0)
                            {
                                printf(&amp;quot;%d&amp;quot;,cnt);
                                return 0;
                            }
                            cnt++;
                        }
    printf(&amp;quot;0&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t21-帮贡排序&#34;&gt;T21 帮贡排序&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1786&#34;&gt;洛谷P1786&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-21&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;按照题意即可，要注意调整职位和输出时的排序方式不同，要写两个cmp函数，调整职位和输出前要分别调用一次sort函数。&lt;br&gt;
&lt;s&gt;一定要注意职位的大小写，不然一个字母的差别就是全WA与全AC的差别&lt;/s&gt;&lt;/p&gt;
&lt;h2 id=&#34;ac代码-21&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

enum prof
{
    BangZhong,JingYing,TangZhu,ZhangLao,HuFa,FuBangZhu,BangZhu
};

struct org
{
    string name;
    int pro,con,level,index;
};

bool cmp1(const org &amp;amp;o1,const org &amp;amp;o2)
{
    if(o1.con != o2.con)
        return o1.con &amp;gt; o2.con;
    else
        return o1.index &amp;lt; o2.index;
}

bool cmp2(const org &amp;amp;o1,const org &amp;amp;o2)
{
    if(o1.pro != o2.pro)
        return o1.pro &amp;gt; o2.pro;
    else if(o1.level != o2.level)
        return o1.level &amp;gt; o2.level;
    else
        return o1.index &amp;lt; o2.index;
}

int bz,fbz,hf,zl,tz,jy,baz;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    struct org o[n];
    for(int i = 0; i &amp;lt; n; i++)
    {
        string pr;
        cin &amp;gt;&amp;gt; o[i].name &amp;gt;&amp;gt; pr;
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;o[i].con,&amp;amp;o[i].level);
        o[i].index = i;
        if(pr == &amp;quot;BangZhu&amp;quot;)
            o[i].pro = BangZhu;
        else if(pr == &amp;quot;FuBangZhu&amp;quot;)
            o[i].pro = FuBangZhu;
        else if(pr == &amp;quot;HuFa&amp;quot;)
            o[i].pro = HuFa;
        else if(pr == &amp;quot;ZhangLao&amp;quot;)
            o[i].pro = ZhangLao;
        else if(pr == &amp;quot;TangZhu&amp;quot;)
            o[i].pro = TangZhu;
        else if(pr == &amp;quot;JingYing&amp;quot;)
            o[i].pro = JingYing;
        else if(pr == &amp;quot;BangZhong&amp;quot;)
            o[i].pro = BangZhong;
    }
    
    sort(o,o+n,cmp1);
    for(int i = 0; i &amp;lt; n; i++)
    {
        if(o[i].pro &amp;lt;= HuFa &amp;amp;&amp;amp; o[i].name != &amp;quot;absi2011&amp;quot;)
        {
            if(hf &amp;lt; 2)
            {
                o[i].pro = HuFa;
                hf++;
            }
            else if(zl &amp;lt; 4)
            {
                o[i].pro = ZhangLao;
                zl++;
            }
            else if(tz &amp;lt; 7)
            {
                o[i].pro = TangZhu;
                tz++;
            }
            else if(jy &amp;lt; 25)
            {
                o[i].pro = JingYing;
                jy++;
            }
            else
            {
                o[i].pro = BangZhong;
                baz++;
            }
        }
    }
    
    sort(o,o+n,cmp2);
    for(auto i:o)
    {
        cout &amp;lt;&amp;lt; i.name &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        switch(i.pro)
        {
            case BangZhu:
                printf(&amp;quot;BangZhu&amp;quot;);/*打成Bangzhu导致全WA，改正后全AC*/
                break;
            case FuBangZhu:
                printf(&amp;quot;FuBangZhu&amp;quot;);
                break;
            case HuFa:
                printf(&amp;quot;HuFa&amp;quot;);
                break;
            case ZhangLao:
                printf(&amp;quot;ZhangLao&amp;quot;);
                break;
            case TangZhu:
                printf(&amp;quot;TangZhu&amp;quot;);
                break;
            case JingYing:
                printf(&amp;quot;JingYing&amp;quot;);
                break;
            case BangZhong:
                printf(&amp;quot;BangZhong&amp;quot;);
                break;
        }
        printf(&amp;quot; %d\n&amp;quot;,i.level);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t22-数列找不同&#34;&gt;T22 数列找不同&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3901&#34;&gt;洛谷P3901&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-22&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;预处理不断循环找出每个区间内各数互不相同的最长区间，每次固定右端点找出最小左端点，若询问的左端点小于对应的最小左端点即可判断存在相同的数。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-22&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;
//typedef long long ll;

const int MAXN = 1e6;

int num[MAXN],a[MAXN];//num[i]-&amp;gt;以第i个数为右端点时左端点的最小值

int main()
{
    int n,q;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;q);

    int k;
    for(int i = 1; i &amp;lt;= n; i++)
    {
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);
        num[i] = max(num[i-1],a[k]+1);
        a[k] = i;
    }
    while(q--)
    {
        int l,r;
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;r);
        if(num[r] &amp;lt;= l)
            printf(&amp;quot;Yes\n&amp;quot;);
        else
            printf(&amp;quot;No\n&amp;quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t23-倒水&#34;&gt;T23 倒水&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1582&#34;&gt;洛谷P1582&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-23&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/solution/P1582&#34;&gt;&lt;s&gt;洛谷题解里果然都是神犇&lt;/s&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新增知识点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C语言内置函数： __builtin__popcount(); 返回参数在二进制下1的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复习知识点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;位运算中 n&amp;amp;-n 表示n在二进制中最后一个1所代表的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为所有的水都是由两份相同的水合并而成的，因此每瓶水的体积一定是2^i（i ∈ N）升，最后保留k个瓶子，那么最后总的升数的二进制表示中，1的个数一定&amp;lt;=k。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;合并前&lt;/th&gt;
&lt;th&gt;二进制&lt;/th&gt;
&lt;th&gt;合并后&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1个瓶子&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2个瓶子&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;2个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3个瓶子&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;3个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4个瓶子&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5个瓶子&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;5个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6个瓶子&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;td&gt;6个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7个瓶子&lt;/td&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;td&gt;7个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8个瓶子&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;8个瓶子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;……&lt;/td&gt;
&lt;td&gt;……&lt;/td&gt;
&lt;td&gt;……&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由图显然，n个有水的瓶子，最后合并成的瓶子个数，就是这个数转成二进制1的个数。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-23&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
using namespace std;
//typedef long long ll;

int main()
{
    int n,k,res = 0;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;k);
    while(__builtin_popcount(n) &amp;gt; k)
    {
        res += n&amp;amp;(-n);
        n += n&amp;amp;(-n);
    }
    printf(&amp;quot;%d&amp;quot;,res);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t24-cities-and-states-s&#34;&gt;T24 Cities and States S&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3405&#34;&gt;洛谷P3405&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-24&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;题目中&lt;strong&gt;特殊的一对&lt;/strong&gt;类似于成对的飞地，显然在一对飞地中，其中一方的CS（City State）代码等于另一方的SC（State City）代码，进而存储一方的CS就可被另一方的SC吻合读取，特殊对数加一。要注意City代码与State代码相等的&lt;s&gt;本地&lt;/s&gt;特殊城市。&lt;/p&gt;
&lt;h2 id=&#34;ac代码-24&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;map&amp;gt;
using namespace std;
//typedef long long ll;

map&amp;lt;string,int&amp;gt; mp;

int main()
{
    int n;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
    
    int cnt = 0;
    string city,state,cs,sc;
    for(int i = 0;i &amp;lt; n;i++)
    {
        cin &amp;gt;&amp;gt; city &amp;gt;&amp;gt; state;
        cs = city.substr(0,2) + state;
        sc = state + city.substr(0,2);
        cnt += mp[sc];
        if(cs == sc)
            cnt -= mp[cs];
        mp[cs]++;
    }
    printf(&amp;quot;%d&amp;quot;,cnt);
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;t25-dreamoon-and-sets&#34;&gt;T25 Dreamoon and Sets&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;a href=&#34;https://www.luogu.com.cn/problem/CF476D&#34;&gt;洛谷CF476D&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题目解析-25&#34;&gt;题目解析&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;第一道紫题&lt;/s&gt;&lt;br&gt;
&lt;s&gt;我觉得我得重读小学二年级&lt;/s&gt;&lt;br&gt;
枚举失败的我从洛谷题解中获取到了一些奇怪的知识：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;互质的一组数中a,b,c,d的值越接近,就能使最大值越小。&lt;br&gt;
相邻的两个正整数数是互质的，相邻的两个奇数也是互质的。&lt;br&gt;
连续n个正整数必有一个数能被n整除，不考虑1,2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;a,b,c,d互质，所以a,b,c,d中最多有一个偶数 为了让四个数的值更接近，我们不妨先假设有1个偶数，3个奇数。&lt;/li&gt;
&lt;li&gt;进一步转换，我们可以将a,b,c,d设为x,x+m1,x+m2,x+m3.&lt;/li&gt;
&lt;li&gt;因此我们先尝试令m1=1,m2=2,即四元组中前三个数为x,x+1,x+2。由于四元组中最多只有一个偶数，故x为奇数，根据以上易证的结论可知这三个数一定互质。&lt;/li&gt;
&lt;li&gt;考虑x是奇数，那么(x,x+1,x+2,x+4)&lt;strong&gt;一定&lt;/strong&gt;满足要求，且不能更小。考虑x是偶数，那么(x,x+1,x+3,x+5)&lt;strong&gt;不一定&lt;/strong&gt;满足要求，而且不能更小。显然x取奇数时是最优的。&lt;/li&gt;
&lt;li&gt;最大数为 (n*6-1)*k&lt;/li&gt;
&lt;li&gt;第一个数从1开始选，同时要保证所以四元组的第一个数为基数，每隔6个确定一个x就好了。x的通项公式即为(i-1)*6+1&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ac代码-25&#34;&gt;AC代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main()
{
    int n,k;
    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;k);
    printf(&amp;quot;%d\n&amp;quot;,(n*6-1) * k);
    for(int i = 1;i &amp;lt;= n;i++)
    {
        int num = (i-1)*6+1;
        printf(&amp;quot;%d %d %d %d\n&amp;quot;,num*k,(num+1)*k,(num+2)*k,(num+4)*k);
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;
">寒假回归大礼包题解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://czyx007.top/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;本站使用Gridea博客系统，由vercel提供访问加速，在此感谢。&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀​&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://qm.qq.com/cgi-bin/qm/qr?k=I2jkn0dziL9o-T2Xcm7NG16jZzvoP7fy&amp;amp;noverify=0&#34;&gt;QQ：1029606625&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/zyx006&#34;&gt;Github：zyx006&lt;/a&gt;&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://czyx007.top/post/mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming/"" data-c="
          &lt;p&gt;⌘  Command&lt;br&gt;
⇧  Shift&lt;br&gt;
⇪  CapsLock&lt;br&gt;
⌥  Option&lt;br&gt;
⌃  Control&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;↩  Return/Enter&lt;br&gt;
⌫  Delete&lt;br&gt;
⌦  向前删除键(Fn + Delete)&lt;br&gt;
↑  上箭头&lt;br&gt;
↓  下箭头&lt;br&gt;
←  左箭头&lt;br&gt;
→  右箭头&lt;br&gt;
⇞  PageUp(Fn + ↑)&lt;br&gt;
⇟  PageDown(Fn + ↓)&lt;br&gt;
Home  Fn + ←&lt;br&gt;
End  Fn + →&lt;br&gt;
⇥  右制表符(Tpb键)&lt;br&gt;
⇤  左制表符(Shift + Tpb)&lt;br&gt;
⎋  Escape(Esc)&lt;/p&gt;
&lt;h2 id=&#34;searchreplace查询替换&#34;&gt;Search/Replace(查询/替换)&lt;/h2&gt;
&lt;p&gt;Double Shift(⇧)  查询任何东西&lt;br&gt;
Command(⌘) + F  文件内查找&lt;br&gt;
Command(⌘) + G  查找模式下，向下查找&lt;br&gt;
Command(⌘) + Shift(⇧) + G  查找模式下，向上查找&lt;br&gt;
Command(⌘) + R  文件内替换&lt;br&gt;
Command(⌘) + Shift(⇧) + F  全局查找(根据路径)&lt;br&gt;
Command(⌘) + Shift(⇧) + R  全局替换(根据路径)&lt;br&gt;
Command(⌘) + Shift(⇧) + S  查询结构(Ultimate Edition 版专用，需要在Keymap中设置)&lt;br&gt;
Command(⌘) + Shift(⇧) + M  替换结构(Ultimate Edition 版专用，需要在Keymap中设置)&lt;/p&gt;
&lt;h2 id=&#34;usage-search使用查询&#34;&gt;Usage Search(使用查询)&lt;/h2&gt;
&lt;p&gt;Option(⌥) + F7 / Command(⌘) + F7  在文件中查找用法 / 在类中查找用法&lt;br&gt;
Command(⌘) + Shift(⇧) + F7  在文件中突出显示的用法&lt;br&gt;
Command(⌘) + Option(⌥) + F7  显示用法&lt;/p&gt;
&lt;h2 id=&#34;compile-and-run编译和运行&#34;&gt;Compile and Run(编译和运行)&lt;/h2&gt;
&lt;p&gt;Command(⌘) + F  编译Project&lt;br&gt;
Command(⌘) + Shift(⇧) + F9  编译选择的文件、包或模块&lt;br&gt;
Control(⌃) + Option(⌥) + R  弹出 Run 的可选择菜单&lt;br&gt;
Control(⌃) + Option(⌥) + D  弹出 Debug 的可选择菜单&lt;br&gt;
Control(⌃) + R  运行&lt;br&gt;
Control(⌃) + D  调试&lt;br&gt;
Control(⌃) + Shift(⇧) + R, Control(⌃) + Shift(⇧) + D  从编辑器运行上下文环境配置&lt;/p&gt;
&lt;h2 id=&#34;通用&#34;&gt;通用&lt;/h2&gt;
&lt;p&gt;Command(⌘) + C  复制&lt;br&gt;
Command(⌘) + V  粘贴&lt;/p&gt;
&lt;h3 id=&#34;剪切&#34;&gt;   剪切&lt;/h3&gt;
&lt;p&gt;   Step 1:Command(⌘) + C  复制&lt;br&gt;
   Step 2:在需要转移的文件夹位置使用Command(⌘) + Option(⌥) + V。(如果操作后悔了，还可以 Command(⌘) + Z 撤销。)&lt;/p&gt;
&lt;p&gt;Command(⌘) + A  全选&lt;br&gt;
Command(⌘) + S  保存&lt;br&gt;
Command(⌘) + F  查找(Find)&lt;br&gt;
Command(⌘) + M  最小化窗口&lt;br&gt;
Command(⌘) + N  新建文件&lt;br&gt;
Command(⌘) + O  打开&lt;br&gt;
Command(⌘) + H  隐藏窗口&lt;br&gt;
Command(⌘) + Shift(⇧) + S  另存&lt;br&gt;
Command(⌘) + W  关闭&lt;br&gt;
Command(⌘) + Q  退出&lt;br&gt;
Command(⌘) + Z  撤销(如果是safari浏览器，就是恢复刚关闭的页面)&lt;br&gt;
Command(⌘) + Shift(⇧) + Z  重做，也就是撤销的逆向操作&lt;br&gt;
Command(⌘) + Option(⌥) + Esc  强制退出程序(类似于window下的任务管理器)&lt;br&gt;
自带的输入法(Capslock 短按中英文切换，长按英文大写)&lt;br&gt;
Command(⌘) + Shift(⇧) + 4  截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口&lt;br&gt;
Command(⌘) + Delete  将文件移至废纸篓(Windows键盘是 Win + Backspace)&lt;br&gt;
Command(⌘) + Shift(⇧) + Delete  清倒废纸篓(Windows键盘是 Win + Shift + Backspace)&lt;br&gt;
Space  快速查看选中的文件，也就是预览功能&lt;br&gt;
Command(⌘) + ↑  打开包含当前文件夹的文件夹，相当于Windows里的“向上”&lt;br&gt;
Command(⌘) + Tab  在应用程序间切换(应用处于打开且在桌面的情况)&lt;/p&gt;
&lt;h2 id=&#34;浏览器&#34;&gt;浏览器&lt;/h2&gt;
&lt;p&gt;Command(⌘) + L  光标直接跳至地址栏(可能被Windows响应锁屏)&lt;br&gt;
Command(⌘) + &#39;+&#39; / &#39;=&#39;  放大页面&lt;br&gt;
Command(⌘) + &#39;-&#39;  缩小页面&lt;br&gt;
Control(⌃) + Tab  转向下一个标签页&lt;br&gt;
Control(⌃) + Shift(⇧) + Tab  转向上一个标签页&lt;br&gt;
Command(⌘) + R  刷新&lt;br&gt;
Command(⌘) + T  新建一个选项卡&lt;br&gt;
PageDown  向下滚动屏幕&lt;br&gt;
PageUp  向上滚动屏幕&lt;br&gt;
按下箭头键 向上、向下、向左或向右滚动&lt;br&gt;
按下箭头键时按住Option(⌥)键大幅度滚动&lt;br&gt;
enter即回车  重命名&lt;br&gt;
Command(⌘) + 鼠标点击  多选不连续的文件或文件夹&lt;/p&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;p&gt;选中多个连续的文件或文件夹&lt;br&gt;
按住Shift(⇧)键不放，使用鼠标依次点击(或按住鼠标后拖动)希望选择的文件或者文件夹即可&lt;br&gt;
文件可以右键重命名&lt;br&gt;
如果桌面的文件不对齐排列，可以右键整理&lt;br&gt;
Shift(⇧) + Command(⌘) + C  打开“电脑”窗口&lt;br&gt;
文件右键有一个“制作替身”，相当于新建一个快捷方式&lt;/p&gt;
">Mac键盘符号和快捷键说明</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;时间跨度：01-07 15:52:16 - 01-09 18:19:02&lt;br&gt;\n&lt;s&gt;(8号摸鱼去了)&lt;/s&gt;&lt;/p&gt;\n&lt;p&gt;强化知识点：&lt;br&gt;\n&lt;strong&gt;埃氏筛&lt;/strong&gt;，&lt;strong&gt;分解质因数&lt;/strong&gt;，&lt;strong&gt;快速幂&lt;/strong&gt;，&lt;strong&gt;逆元&lt;/strong&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;t1-快速幂取余运算\&#34;&gt;T1 快速幂||取余运算&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1226\&#34;&gt;洛谷P1226&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;快速幂模板题，按题意最后取余即可&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nll fastpow(ll x,ll y,ll mod)\n{\n    x %= mod;\n    ll res = 1;\n    while(y)\n    {\n        if(y&amp;amp;1)\n            res = res * x % mod;\n        y &amp;gt;&amp;gt;= 1;\n        x = x * x % mod;  \n    }\n    return res;\n}\n\nint main()\n{\n    ll b,p,k;\n    scanf(&amp;quot;%lld %lld %lld&amp;quot;,&amp;amp;b,&amp;amp;p,&amp;amp;k);\n    printf(&amp;quot;%lld^%lld mod %lld=%lld&amp;quot;,b,p,k,fastpow(b,p,k)%k);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t2-线性筛素数\&#34;&gt;T2 线性筛素数&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3383\&#34;&gt;洛谷P3383&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-2\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;埃氏筛优化，保证每个合数只被筛一遍。将每个素数依次存入数组中，第k小的素数即为数组中第k-1个元素。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-2\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e8+10;\nint prime[MAXN];\nll num[MAXN];\n\nvoid isPrime(ll n)\n{\n    ll cnt = 0;\n    prime[0] = prime[1] = 1;\n    for(ll i = 2; i &amp;lt;= n; i++)\n    {\n        if(!prime[i])\n            num[cnt++] = i;\n        for(ll j = 0; j &amp;lt; cnt &amp;amp;&amp;amp; i*num[j] &amp;lt; MAXN; j++)\n        {\n            prime[i*num[j]] = 1;\n            if(i%num[j] == 0)\n                break;\n        }\n    }\n}\n\nint main()\n{\n\n    int n,q;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;q);\n\n    isPrime(n);\n    int k;\n    while(q--)\n    {\n        scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);\n        printf(&amp;quot;%lld\\n&amp;quot;,num[k-1]);\n    }\n\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t3-乘法逆元\&#34;&gt;T3 乘法逆元&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3811\&#34;&gt;洛谷P3811&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-3\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;需用到逆元递推公式：inv[i] = (p-p/i) * inv[p%i] % p;&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-3\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e7;\n\nll inv[MAXN];\n\nint main()\n{\n    ll n,p;\n    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;p);\n    \n    inv[1] = 1;\n    printf(&amp;quot;1\\n&amp;quot;);\n    for(int i = 2; i &amp;lt;= n; i++)\n    {\n        inv[i] = (p-p/i) * inv[p%i] % p;\n        printf(&amp;quot;%lld\\n&amp;quot;,inv[i]);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t4-乘法逆元2\&#34;&gt;T4 乘法逆元2&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P5431\&#34;&gt;洛谷P5431&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-4\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;先通分后取模，每次k乘上k本身（k,k&lt;sup&gt;2,k&lt;/sup&gt;3，不用快速幂），通分求和后分子乘上分母的逆元再取模即为结果。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-4\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nll p;\n\nconst int MAXN = 5e6+10;\nll num[MAXN];\n\nll fastpow(ll x,ll y)\n{\n    x %= p;\n    ll res = 1;\n    while(y)\n    {\n        if(y&amp;amp;1)\n            res = res * x % p;\n        y &amp;gt;&amp;gt;= 1;\n        x = x * x % p;\n    }\n    return res;\n}\n\nll inv(ll x)\n{\n    return fastpow(x,p-2);\n}\n\nint main()\n{\n    ll n,k;\n    scanf(&amp;quot;%lld %lld %lld&amp;quot;,&amp;amp;n,&amp;amp;p,&amp;amp;k);\n    ll t = k%p;\t\n    \n    ll up = 0,down = 1;\n    for(ll i = 0; i &amp;lt; n; i++)\n    {\n        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;num[i]);\n        up = (up*num[i]+down*t)%p;\n        down = down * num[i] % p;\n        t = t * k % p;\n    }\n    printf(&amp;quot;%lld&amp;quot;,up*inv(down)%p);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t5-质数口袋\&#34;&gt;T5 质数口袋&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P5723\&#34;&gt;洛谷P5723&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-5\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;埃氏筛打表后每次从头遍历即可，注意打表数组要开bool型数组，不然会MLE。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-5\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5;\nbool prime[MAXN];\n\nvoid isPrime()\n{\n    prime[0] = prime[1] = true;\n    for(ll i = 2; i*i &amp;lt;= MAXN; i++)\n    {\n        if(!prime[i])\n            for(ll j = i*i; j &amp;lt;= MAXN; j += i)\n                prime[j] = true;\n    }\n}\n\nint main()\n{\n    int L;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;L);\n\n    isPrime();\n    int sum = 0,cnt = 0;\n    for(int i = 2;; i++)\n    {\n        if(!prime[i])\n        {\n            if(sum + i &amp;lt;= L)\n            {\n                sum += i;\n                cnt++;\n                printf(&amp;quot;%d\\n&amp;quot;,i);\n            }\n            else\n                break;\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t6-回文质数\&#34;&gt;T6 回文质数&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1217\&#34;&gt;洛谷P1217&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-6\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;这道题我是用提前打表写的，打表后直接查询遍历输出即可。&lt;/p&gt;\n&lt;h4 id=\&#34;打表代码\&#34;&gt;打表代码&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 100000010;\nbool prime[MAXN];\n\nvoid isPrime()\n{\n    prime[0] = prime[1] = true;\n    for(ll i = 2;i*i &amp;lt;= MAXN;i++)\n    {\n        if(!prime[i])\n            for(ll j = i*i;j &amp;lt;= MAXN;j += i)\n                prime[j] = true;\n    }\n}\n\nll reverse( ll number )\n{\n    ll num = 0,flag = 0;\n    if(number &amp;lt; 0)\n    {\n        number = -number;\n        flag = 1;\n    }\n    while(number)\n    {\n        num += number % 10;\n        if((number &amp;gt; 10) || (number % 10 == 0))\n            num *= 10;\n        number /= 10;\n    }\n    if(flag)\n        num = -num;\n    return num;\n}\n\nint main()\n{\n    FILE *fp;\n    fp = fopen(&amp;quot;1.txt&amp;quot;,&amp;quot;w&amp;quot;);\n    isPrime();\n    for(ll i = 0;i &amp;lt;= MAXN;i++)\n        if(!prime[i])\n        {\n            if(i == reverse(i))\n                fprintf(fp,&amp;quot;%lld,&amp;quot;,i);\n        }\n    fclose(fp);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;ac代码-6\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint prime[] = {5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899};\n\nint main()\n{\n    int a,b;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;a,&amp;amp;b);\n    for(auto i:prime)\n        if(i &amp;gt;= a &amp;amp;&amp;amp; i &amp;lt;= b)\n            printf(&amp;quot;%d\\n&amp;quot;,i);\n        else if(i &amp;gt; b)\n            break;\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t7-哥德巴赫猜想升级版\&#34;&gt;T7 哥德巴赫猜想（升级版）&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1579\&#34;&gt;洛谷P1579&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-7\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;埃氏筛打表后双重循环找出符合条件的一组输出即可。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-7\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e6+10;\nint prime[MAXN];\n\nvoid isPrime()\n{\n    prime[0] = prime[1] = 1;\n    for (ll i = 2; i * i &amp;lt; MAXN; i++)\n    {\n        if (!prime[i])\n        {\n            for (ll j = i * i; j &amp;lt; MAXN; j += i)\n                prime[j] = 1;\n        }\n    }\n}\n\nint main()\n{\n    isPrime();\n\n    int n;\n    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);\n    for(int i = 2; i &amp;lt; n-1; i++)\n        for(int j = 2; j &amp;lt; n-1-i; j++)\n        {\n            int k = n-i-j;\n            if(prime[i] == 0 &amp;amp;&amp;amp; prime[j] == 0 &amp;amp;&amp;amp; prime[k] == 0)\n                if(i+j+k == n)\n                {\n                    printf(&amp;quot;%d %d %d&amp;quot;, i, j, k);\n                    return 0;\n                }\n        }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t8-a-b-problem\&#34;&gt;T8 A % B Problem&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1865\&#34;&gt;洛谷P1865&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-8\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;埃氏筛打表后每次在区间内遍历即可，注意判断区间是否成立。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-8\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e6+10;\nbool prime[MAXN];\n\nvoid isPrime()\n{\n    prime[0] = prime[1] = true;\n    for(ll i = 2;i*i &amp;lt;= MAXN;i++)\n    {\n        if(!prime[i])\n            for(ll j = i*i;j &amp;lt;= MAXN;j += i)\n                prime[j] = true;\n    }\n}\n\nint main()\n{\n    int n,m;\n    int l,r;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);\n    \n    isPrime();\n    while(n--)\n    {\n        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;r);\n        if(l &amp;gt;= 1 &amp;amp;&amp;amp; l &amp;lt;= m &amp;amp;&amp;amp; r &amp;gt;= 1 &amp;amp;&amp;amp; r &amp;lt;= m &amp;amp;&amp;amp; l &amp;lt;= r)\n        {\n            int cnt = 0;\n            for(int i = l;i &amp;lt;= r;i++)\n                if(!prime[i])\n                    cnt++;\n            printf(&amp;quot;%d\\n&amp;quot;,cnt);\n        }\n        else\n            printf(&amp;quot;Crossing the line\\n&amp;quot;);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t9-素数个数\&#34;&gt;T9 素数个数&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3912\&#34;&gt;洛谷P3912&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-9\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;埃氏筛打表时统计素数个数，打表完成后直接输出个数即可。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-9\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e8+10;\nbool prime[MAXN];\n\nvoid isPrime(ll n)\n{\n    ll cnt = 0;\n    prime[0] = prime[1] = 1;\n    for(ll i = 2;i &amp;lt;= n;i++)\n    {\n        if(!prime[i])\n        {\n            cnt++;\n            for(ll j = i*i;j &amp;lt;= n;j += i)\n                prime[j] = true;\n        }\n    }\n    printf(&amp;quot;%lld&amp;quot;,cnt); \n}\n\nint main()\n{\n    ll n;\n    scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n);\n    isPrime(n);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t10-因子和\&#34;&gt;T10 因子和&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1593\&#34;&gt;洛谷P1593&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-10\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;&lt;s&gt;逐渐看不懂的题解&lt;/s&gt;&lt;br&gt;\n分解质因数并记录每个质因数的个数（记为幂数一起存储），结果为所有质因数等比数列求和再相乘。&lt;br&gt;\n（要注意特判逆元为0的情况）&lt;br&gt;\n&lt;img src=\&#34;https://gitee.com/gentlemans_ink/blogimage/raw/master/img/20210109193417.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-10\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nconst int mod = 9901,MAXN = 1e6;\nll num[MAXN][2],sum[MAXN];\n\nll fastpow(ll x,ll y)\n{\n    x %= mod;\n    ll res = 1;\n    while(y)\n    {\n        if(y&amp;amp;1)\n            res = res * x % mod;\n        y &amp;gt;&amp;gt;= 1;\n        x = x * x % mod;\n    }\n    return res;\n}\n\nll inv(ll x)\n{\n    return fastpow(x,mod-2)%mod;\n}\n\nint main()\n{\n    ll a,b;\n    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;a,&amp;amp;b);\n    ll t = a;\n    \n    ll cnt = 0;\n    for(ll i = 2;i*i &amp;lt;= a;i++)\n    {\n        if(t%i == 0)\n            num[++cnt][0] = i;\n        while(t%i == 0)\n        {\n            num[cnt][1]++;\n            t /= i;\n        }\n    }\n    if(t != 1)\n    {\n        num[++cnt][0] = t;\n        num[cnt][1] = 1;\n    }\n    \n    ll res = 1;\n    for(ll i = 1;i &amp;lt;= cnt;i++)\n    {\n        sum[i] = (fastpow(num[i][0],num[i][1]*b+1)-1)*inv(num[i][0]-1)%mod;\n        if(sum[i] == 0)\n            sum[i] = num[i][1]*b+1;\n        res = res * sum[i] % mod;\n    }\n    printf(&amp;quot;%lld&amp;quot;,(res%mod+mod)%mod);\n    return 0;\n}&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;shu-xue-zhuan-ti-yi-ti-jie&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;时间跨度：01-07 15:52:16 - 01-09 18:19:02&lt;br&gt;\n&lt;s&gt;(8号摸鱼去了)&lt;/s&gt;&lt;/p&gt;\n&lt;p&gt;强化知识点：&lt;br&gt;\n&lt;strong&gt;埃氏筛&lt;/strong&gt;，&lt;strong&gt;分解质因数&lt;/strong&gt;，&lt;strong&gt;快速幂&lt;/strong&gt;，&lt;strong&gt;逆元&lt;/strong&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;数学专题一题解&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-01-09 18:21:45&#34;,&#34;dateFormat&#34;:&#34;2021-01-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://czyx007.top/post/shu-xue-zhuan-ti-yi-ti-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;15 min read&#34;,&#34;time&#34;:858000,&#34;words&#34;:2517,&#34;minutes&#34;:15},&#34;description&#34;:&#34;时间跨度：01-07 15:52:16 - 01-09 18:19:02\n(8号摸鱼去了)\n强化知识点：\n埃氏筛，分解质因数，快速幂，逆元\n\nT1 快速幂||取余运算\n题目链接：洛谷P1226\n题目解析\n快速幂模板题，按题意最后取余即可\nA...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#t1-%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97\&#34;&gt;T1 快速幂||取余运算&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t2-%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0\&#34;&gt;T2 线性筛素数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-2\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t3-%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83\&#34;&gt;T3 乘法逆元&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-3\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-3\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t4-%E4%B9%98%E6%B3%95%E9%80%86%E5%85%832\&#34;&gt;T4 乘法逆元2&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-4\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-4\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t5-%E8%B4%A8%E6%95%B0%E5%8F%A3%E8%A2%8B\&#34;&gt;T5 质数口袋&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-5\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-5\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t6-%E5%9B%9E%E6%96%87%E8%B4%A8%E6%95%B0\&#34;&gt;T6 回文质数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-6\&#34;&gt;题目解析&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%93%E8%A1%A8%E4%BB%A3%E7%A0%81\&#34;&gt;打表代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-6\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t7-%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%E5%8D%87%E7%BA%A7%E7%89%88\&#34;&gt;T7 哥德巴赫猜想（升级版）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-7\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-7\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t8-a-b-problem\&#34;&gt;T8 A % B Problem&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-8\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-8\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t9-%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0\&#34;&gt;T9 素数个数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-9\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-9\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t10-%E5%9B%A0%E5%AD%90%E5%92%8C\&#34;&gt;T10 因子和&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-10\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-10\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;时间跨度：01-04 17:46:10 - 01-06 23:01:46&lt;/p&gt;\n&lt;p&gt;关键知识点：&lt;strong&gt;高精度&lt;/strong&gt;，斐波那契数列&lt;/p&gt;\n&lt;p&gt;部分新增知识点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;C语言内置函数__builtin__popcount();&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;数字之间的关系&lt;/strong&gt;，&lt;strong&gt;质数的性质&lt;/strong&gt;（数论？）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;t1-标题统计\&#34;&gt;T1 标题统计&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P5015\&#34;&gt;洛谷P5015&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;获取一整行字符串后计算除空格和换行符以外的字符数即可&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    string str;\n    getline(cin,str);\n    \n    int cnt = 0;\n    for(auto i:str)\n    if(i != &#39; &#39; &amp;amp;&amp;amp; i != &#39;\\n&#39;)\n        cnt++;\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t2-davor\&#34;&gt;T2 Davor&lt;/h1&gt;\n&lt;p&gt;题目链接:&lt;a href=\&#34;https://www.luogu.com.cn/problem/P4956\&#34;&gt;洛谷P4956&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-2\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;用等差数列求出每星期筹到的金钱总额乘以总周数52，若刚好等于n则输出并中断。&lt;br&gt;\n为了满足 x 尽可能大，k 尽可能小，应使x从100开始倒序循环。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-2\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n\n    for(int x = 100; x &amp;gt;= 1; x--)\n    {\n        for(int k = 1;k &amp;lt; 3000; k++)\n        {\n            int cnt = 52 * (x + x+6*k)*7/2;\n            if(cnt == n)\n            {\n                printf(&amp;quot;%d\\n%d&amp;quot;,x,k);\n                return 0;\n            }\n        }\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t3-语句解析\&#34;&gt;T3 语句解析&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1597\&#34;&gt;洛谷P1597&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-3\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;按照题面所给的语句格式&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;变量 := 变量或一位整数;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;逐字扫描判断，以分号作为分隔符进行逐句赋值，未赋值的变量以初始值0作为终值。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-3\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    string str;\n    cin &amp;gt;&amp;gt; str;\n\n    int a = 0,b = 0,c = 0;\n    for(int i = 0; i &amp;lt; str.length(); i++)\n    {\n        if(str[i] == &#39;a&#39;)\n        {\n            int j = i;\n            while(str[j] !=&#39;;&#39;)j++;\n            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)\n                a = (str[j-1]-&#39;0&#39;);\n            else\n            {\n                if(str[j-1] == &#39;b&#39;)\n                    a = b;\n                else if(str[j-1] == &#39;c&#39;)\n                    a = c;\n            }\n            i = j;\n        }\n        else if(str[i] == &#39;b&#39;)\n        {\n            int j = i;\n            while(str[j] !=&#39;;&#39;)j++;\n            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)\n                b = (str[j-1]-&#39;0&#39;);\n            else\n            {\n                if(str[j-1] == &#39;a&#39;)\n                    b = a;\n                else if(str[j-1] == &#39;c&#39;)\n                    b = c;\n            }\n            i = j;\n        }\n        else if(str[i] == &#39;c&#39;)\n        {\n            int j = i;\n            while(str[j] !=&#39;;&#39;)j++;\n            if(str[j-1] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str[j-1] &amp;lt;= &#39;9&#39;)\n                c = (str[j-1]-&#39;0&#39;);\n            else\n            {\n                if(str[j-1] == &#39;a&#39;)\n                    c = a;\n                else if(str[j-1] == &#39;b&#39;)\n                    c = b;\n            }\n            i = j;\n        }\n    }\n    printf(&amp;quot;%d %d %d&amp;quot;,a,b,c);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t4-数楼梯\&#34;&gt;T4 数楼梯&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1255\&#34;&gt;洛谷P1255&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-4\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;本题关键知识点：&lt;strong&gt;高精度&lt;/strong&gt;，&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;br&gt;\n从前几阶楼梯可以发现，上到每节楼梯的走法数分别为1,2,3,5，……，显然就是去掉第一项后的斐波那契列&lt;br&gt;\n但题目数据范围N &amp;lt;= 5000,斐波那契数列的值呈指数级爆炸增长，因而要使用高精度防止数据溢出。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-4\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nconst int MAXN = 5010;\n\nint a[MAXN],b[MAXN],c[MAXN];\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n\n    if(n &amp;lt; 3)\n        printf(&amp;quot;%d&amp;quot;,n);\n    else\n    {\n        int cnt = 1;\n        a[1] = 1,b[1] = 2;\n        for(int i = 3; i &amp;lt;= n; i++)\n        {\n            for(int j = 1; j &amp;lt;= cnt; j++)\n                c[j] = a[j]+b[j];\n            for(int j = 1; j &amp;lt;= cnt; j++)\n            {\n                if(c[j] &amp;gt; 9)\n                {\n                    c[j+1] += c[j]/10;\n                    c[j] %= 10;\n                    if(j+1 &amp;gt; cnt)\n                        cnt++;\n                }\n            }\n            for(int j = 1; j &amp;lt;= cnt; j++)\n                a[j] = b[j];\n            for(int j = 1; j &amp;lt;= cnt; j++)\n                b[j] = c[j];\n        }\n        for(int i = cnt;i &amp;gt; 0;i--)\n            printf(&amp;quot;%d&amp;quot;,b[i]);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t5-分数线划定\&#34;&gt;T5 分数线划定&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1068\&#34;&gt;洛谷P1068&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-5\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;用结构体存储每名选手的报名号和成绩，然后依照提议解题即可，要注意cmp函数的写法。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-5\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nstruct peo\n{\n    int id,score;\n};\n\nbool cmp(const peo &amp;amp;p1,const peo &amp;amp;p2)\n{\n    if(p1.score != p2.score)\n        return p1.score &amp;gt; p2.score;\n    else\n        return p1.id &amp;lt; p2.id;\n}\n\nint main()\n{\n    int n,m;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);\n    int num = m * 1.5;\n    struct peo p[n];\n\n    for(int i = 0; i &amp;lt; n; i++)\n        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;p[i].id,&amp;amp;p[i].score);\n    sort(p,p+n,cmp);\n\n    int line = p[num-1].score,cnt = 0;\n    for(int i = 0; p[i].score &amp;gt;= line; i++)\n        cnt++;\n    printf(&amp;quot;%d %d\\n&amp;quot;,line,cnt);\n    for(int i = 0; i &amp;lt; cnt; i++)\n        printf(&amp;quot;%d %d\\n&amp;quot;,p[i].id,p[i].score);\n\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t6-涂国旗\&#34;&gt;T6 涂国旗&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3392\&#34;&gt;洛谷P3392&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-6\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;预处理存储每行R/W/B三种颜色的块数，之后暴力O(n^2)枚举前两种颜色的行数(第三种颜色为剩下的行数)，用m减去某行某颜色的块数既得该行的成本，取得每次成本总和的最小值即可。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-6\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nstruct color\n{\n    int white,blue,red;\n};\n\nint main()\n{\n    int n,m;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);\n    \n    char ch[n][m];\n    struct color c[n];\n\n    for(int i = 0; i &amp;lt; n; i++)\n    {\n        int w = 0,b = 0,r = 0;\n        for(int j = 0; j &amp;lt; m; j++)\n        {\n            scanf(&amp;quot; %c&amp;quot;,&amp;amp;ch[i][j]);\n            switch(ch[i][j])\n            {\n                case &#39;W&#39;:\n                    w++;\n                    break;\n                case &#39;R&#39;:\n                    r++;\n                    break;\n                case &#39;B&#39;:\n                    b++;\n                    break;\n            }\n        }\n        c[i].white = w;\n        c[i].blue = b;\n        c[i].red = r;\n    }\n\n    int cnt = 1e7;\n    for(int i = 1; i &amp;lt;= n-2; i++)\n    {\n        for(int j = i+1; j &amp;lt;= n-1; j++)\n        {\n            int sum = 0;\n            for(int k = 1; k &amp;lt;= i; k++)\n                sum += (m-c[k-1].white);\n            for(int k = i+1; k &amp;lt;= j; k++)\n                sum += (m-c[k-1].blue);\n            for(int k = j+1; k &amp;lt;= n; k++)\n                sum += (m-c[k-1].red);\n            cnt = min(cnt,sum);\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t7-拼数\&#34;&gt;T7 拼数&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1012\&#34;&gt;洛谷P1012&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-7\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;将所有数字按字典序顺序降序排列后拼接即可。要注意cmp函数不能直接判断两字符串&lt;br&gt;\n&lt;s&gt;return s1 &amp;gt; s2;&lt;/s&gt;&lt;br&gt;\n&lt;u&gt;return s1+s2 &amp;gt; s2+s1;&lt;/u&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;详见代码中注释&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;ac代码-7\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;vector&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nvector&amp;lt;string&amp;gt; v; \n\nbool cmp(const string &amp;amp;s1,const string &amp;amp;s2)\n{\n    /*\n    若用s1 &amp;gt; s2,则结果为321 32 -&amp;gt;32132,但最大应为32321\n    使用s1+s2 &amp;gt; s2+s1则可避免这种32132&amp;gt;32321的情况 \n    */\n    return s1+s2 &amp;gt; s2+s1;\n}\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    for(int i = 0;i &amp;lt; n;i++)\n    {\n        string str;\n        cin &amp;gt;&amp;gt; str;\n        v.push_back(str);\n    }\n    sort(v.begin(),v.end(),cmp);\n    for(auto i:v)\n        cout &amp;lt;&amp;lt; i;\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t8-烤鸡\&#34;&gt;T8 烤鸡&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P2089\&#34;&gt;洛谷P2089&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-8\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;直接暴力枚举10种配料的所有搭配方案，若质量总和等于n则保存，等待输出。注意每种配料的质量都不能为0。&lt;br&gt;\n(由于配料质量和的最大值只有30，所以n &amp;gt; 30的可以直接输出0)&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-8\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;vector&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nvector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; v;\nvector&amp;lt;int&amp;gt; vs;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    \n    int cnt = 0;\n    for(int q = 1;q &amp;lt;= 3;q++)\n    for(int w = 1;w &amp;lt;= 3;w++)\n    for(int e = 1;e &amp;lt;= 3;e++)\n    for(int r = 1;r &amp;lt;= 3;r++)\n    for(int t = 1;t &amp;lt;= 3;t++)\n    for(int y = 1;y &amp;lt;= 3;y++)\n    for(int u = 1;u &amp;lt;= 3;u++)\n    for(int i = 1;i &amp;lt;= 3;i++)\n    for(int o = 1;o &amp;lt;= 3;o++)\n    for(int p = 1;p &amp;lt;= 3;p++)\n        if(q+w+e+r+t+y+u+i+o+p == n)\n        {\n            vs.push_back(q);\n            vs.push_back(w);\n            vs.push_back(e);\n            vs.push_back(r);\n            vs.push_back(t);\n            vs.push_back(y);\n            vs.push_back(u);\n            vs.push_back(i);\n            vs.push_back(o);\n            vs.push_back(p);\n            v.push_back(vs);\n            vs.clear();\n            cnt++;\n        }\n    \n    printf(&amp;quot;%d\\n&amp;quot;,cnt);\n    for(auto i:v)\n    {\n        for(auto j:i)\n            printf(&amp;quot;%d &amp;quot;,j);\n        printf(&amp;quot;\\n&amp;quot;);\n    }\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t9-独木桥\&#34;&gt;T9 独木桥&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1007\&#34;&gt;洛谷P1007&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-9\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;首先，不用考虑题目中的这一因素的影响：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;引用洛谷题解中很形象的两个例子：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;首先自行脑补一下，假装你正在20000米高空的轰炸机上用高倍显微镜望远镜默默欣赏士兵离开，你会发现什么东西？一堆花花绿绿的迷彩服在移动。（不是鬼片！不是鬼片！不是鬼片！重要的事情说三遍）&lt;br&gt;\n那么当两个士兵撞在一起时，从你的视角看会发生什么？当然他们认为他们都掉头了，但因为你在特高的地方，你会认为他们“穿过”了对方。换言之，这与他们相互穿过并没有任何区别。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;两个人相遇转身，相当于交换灵魂后继续走&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;那么问题就很简单了，最大值就是最靠近端点的两个人各自向对方方向走下桥,时间较长的那个人的时间，最小值就是所有人走完桥的时间的最小值的最大值。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-9\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int l,n;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;n);\n    \n    int pos[n]={0};\n    for(int i = 0;i &amp;lt; n;i++)\n        scanf(&amp;quot;%d&amp;quot;,&amp;amp;pos[i]);\n    sort(pos,pos+n,greater&amp;lt;int&amp;gt;());\n    int ma = max(pos[0],l-pos[n-1]+1);\n    int mi = 0;\n    for(int i = 0;i &amp;lt; n;i++)\n    {\n        int tmp = min(pos[i],l-pos[i]+1);\n        mi = max(tmp,mi);\n    }\n    printf(&amp;quot;%d %d&amp;quot;,mi,ma);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t10-first-step-ファーストステップ\&#34;&gt;T10 First Step (ファーストステップ)&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3654\&#34;&gt;洛谷P3654&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-10\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;枚举每个可站点，判断该点向右方和向下方各有多少种站位方式&lt;br&gt;\n要注意k=1的情况下，横着站和竖着站一样，因而要进行特判，此时站位方式数量就是可站点的数量。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-10\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int r,c,k;\n    scanf(&amp;quot;%d %d %d&amp;quot;,&amp;amp;r,&amp;amp;c,&amp;amp;k);\n\n    int po = 0;\n    char gym[r][c];\n    for(int i = 0; i &amp;lt; r; i++)\n        for(int j = 0; j &amp;lt; c; j++)\n        {\n            scanf(&amp;quot; %c&amp;quot;,&amp;amp;gym[i][j]);\n            if(gym[i][j] == &#39;.&#39;)\n                po++;\n        }\n\n    if(k == 1)\n    {\n        printf(&amp;quot;%d&amp;quot;,po);\n        return 0;\n    }\n    int cnt = 0,sum = 0;\n    for(int i = 0; i &amp;lt; r; i++)\n    {\n        for(int j = 0; j &amp;lt; c; j++)\n        {\n            if(gym[i][j] == &#39;.&#39;)\n            {\n                if(i &amp;lt; r-1)\n                {\n                    sum = 0;\n                    for(int q = j; q &amp;lt; c; q++)\n                    {\n                        if(gym[i][q] == &#39;.&#39;)\n                            sum++;\n                        else\n                            break;\n                        if(sum == k)\n                        {\n                            cnt++;\n                            break;\n                        }\n                    }\n                    sum = 0;\n                    for(int q = i; q &amp;lt; r; q++)\n                    {\n                        if(gym[q][j] == &#39;.&#39;)\n                            sum++;\n                        else\n                            break;\n                        if(sum == k)\n                        {\n                            cnt++;\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    sum = 0;\n                    for(int q = j; q &amp;lt; c; q++)\n                    {\n                        if(gym[i][q] == &#39;.&#39;)\n                            sum++;\n                        else\n                            break;\n                        if(sum == k)\n                        {\n                            cnt++;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t11-蜜蜂路线\&#34;&gt;T11 蜜蜂路线&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P2437\&#34;&gt;洛谷P2437&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-11\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;类似题目 T4数楼梯：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1255\&#34;&gt;洛谷P1255&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;本题需用到&lt;strong&gt;高精度&lt;/strong&gt;和&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;br&gt;\n不同的是本题中最终结果并不是从斐波那契数列第一项加起，它的起始项(左端点)是变化的。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-11\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;cstring&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nconst int MAXN = 5010;\n\nint a[MAXN]= {1,1},b[MAXN]= {1},c[MAXN];\n\nint main()\n{\n    int m,n;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;m,&amp;amp;n);\n\n    for(int i = m+1; i &amp;lt;= n; i++)\n    {\n        for(int j = 0; j &amp;lt;= a[0]; j++)\n            c[j] = a[j];\n        for(int j = 1; j &amp;lt;= a[0]; j++)\n        {\n            a[j] += b[j];\n            a[j+1] += a[j]/10;\n            a[j] %= 10;\n        }\n        while(a[a[0]+1]&amp;gt;0)\n            a[0]++;\n        memset(b,sizeof(b),0);\n        for(int j = 0; j &amp;lt;= c[0]; j++)\n            b[j] = c[j];\n    }\n    for(int i = a[0]; i &amp;gt;= 1; i--)\n        printf(&amp;quot;%d&amp;quot;,a[i]);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t12-最大公约数和最小公倍数问题\&#34;&gt;T12 最大公约数和最小公倍数问题&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1029\&#34;&gt;洛谷P1029&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-12\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;以x,y为端点进行O(n^2) 枚举,由于本题数据范围是10^5,为了防止TLE需要进行优化，只用枚举max(x,y)的所有因子即可。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-12\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\n#include&amp;lt;vector&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nvector&amp;lt;int&amp;gt; v;\nvoid getnum(int a);\n\nint main()\n{\n    int x,y;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x,&amp;amp;y);\n    \n    getnum(max(x,y));\n    \n    int cnt = 0,size = v.size();\n    for(int i = 0;i &amp;lt; size;i++)\n    {\n        for(int j = size-1;j &amp;gt;= 0;j--)\n        {\n            int gnum = __gcd(v[i],v[j]);\n            int LCD = (v[i] * v[j]) / gnum;\n            if(gnum == x &amp;amp;&amp;amp; LCD == y)\n                cnt++;\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n}\n\nvoid getnum(int a)\n{\n    for(int i = 1;i &amp;lt;= a;i++)\n        if(a % i == 0)\n            v.push_back(i);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t13-种田\&#34;&gt;T13 种田&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P2660\&#34;&gt;洛谷P2660&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-13\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;类似题目 第四周题单-统计方形：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P2241\&#34;&gt;洛谷P2241&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;不同的是，上题是统计所有方形的数量，而这题是每次切割最大正方形，每次以最短边为边长切割，体力值即为每次所切割的正方形的周长之和。但单单这样写会在最后一个测试点被10^16的数据卡TLE，只能拿90分，因而要进行优化，不能一个正方形一个正方形的切，要一次切多个，也就是切max(x,y)/min(x,y)个。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-13\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    ll n,m;\n    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;m);\n\n    ll res = 0;\n    while(n != 0 &amp;amp;&amp;amp; m != 0)\n    {\n        ll mi = min(n,m);\n        if(n &amp;lt; m)\n        {\n            res += 4 * (m/mi) * mi;\n            m %= mi;\n        }\n        else\n        {\n            res += 4 * (n/mi) * mi;\n            n %= mi;\n        }\n    }\n    printf(&amp;quot;%lld&amp;quot;,res);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t14-混合牛奶-mixing-milk\&#34;&gt;T14 混合牛奶 Mixing Milk&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1208\&#34;&gt;洛谷P1208&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-14\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;用结构体存储每位农民的单价和最大量，按单价从低到高进行排序，依次购买直至购买量等于所需量时即求出最小费用。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-14\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nstruct farmer{\n    int price,sum;\t\n};\n\nbool cmp(const farmer &amp;amp;f1,const farmer &amp;amp;f2)\n{\n    return f1.price &amp;lt; f2.price;\n}\n\nint main()\n{\n    int n,m;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);\n    struct farmer f[m];\n    \n    for(int i = 0;i &amp;lt; m;i++)\n        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;f[i].price,&amp;amp;f[i].sum);\n    sort(f,f+m,cmp);\n    \n    int su = 0,money = 0;\n    for(int i = 0;i &amp;lt; m;i++)\n    {\n        if(su + f[i].sum &amp;lt;= n)\n        {\n            su += f[i].sum;\n            money += f[i].price * f[i].sum;\n        }\n        else\n        {\n            money += f[i].price * (n - su);\n            break;\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,money);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t15-排队\&#34;&gt;T15 排队&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P5412\&#34;&gt;洛谷P5412&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-15\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;结构体存储按身高从矮到高排序，最后用cout输出即可。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-15\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nstruct stu\n{\n    int sex;\n    double height;\n};\n\nbool cmp(const stu &amp;amp;s1,const stu &amp;amp;s2)\n{\n    return s1.height &amp;lt; s2.height;\n}\n\nint main()\n{\n    int t;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);\n    while(t--)\n    {\n        int n;\n        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n        struct stu s[n];\n        for(int i = 0; i &amp;lt; n; i++)\n            scanf(&amp;quot;%d&amp;quot;,&amp;amp;s[i].sex);\n        for(int i = 0; i &amp;lt; n; i++)\n            scanf(&amp;quot;%lf&amp;quot;,&amp;amp;s[i].height);\n        \n        sort(s,s+n,cmp);\n        for(int i = 0; i &amp;lt; n; i++)\n            if(s[i].sex == 0)\n                cout &amp;lt;&amp;lt; s[i].height &amp;lt;&amp;lt; &#39; &#39;;\n        printf(&amp;quot;\\n&amp;quot;);\n        for(int i = 0; i &amp;lt; n; i++)\n            if(s[i].sex == 1)\n                cout &amp;lt;&amp;lt; s[i].height &amp;lt;&amp;lt; &#39; &#39;;\n        printf(&amp;quot;\\n&amp;quot;);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t16-小a的糖果\&#34;&gt;T16 小A的糖果&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3817\&#34;&gt;洛谷P3817&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-16\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;从左到右依次遍历，若左右之和大于x则将&lt;strong&gt;右侧数&lt;/strong&gt;减去&lt;strong&gt;两数之和与x的差&lt;/strong&gt; ，结果即为每次该差的总和。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-16\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    ll n,x;\n    scanf(&amp;quot;%lld %lld&amp;quot;,&amp;amp;n,&amp;amp;x);\n    ll num[n] = {0};\n    \n    for(int i = 0;i &amp;lt; n;i++)\n        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;num[i]);\n        \n    ll cnt = 0;\n    for(ll i = 0;i &amp;lt; n-1;i++)\n    {\n        if(num[i] + num[i+1] &amp;gt; x)\n        {\n            cnt += num[i]+num[i+1]-x;\n            num[i+1] -= num[i]+num[i+1]-x;\n        }\n    }\n    printf(&amp;quot;%lld&amp;quot;,cnt);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t17-阶乘之和\&#34;&gt;T17 阶乘之和&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1009\&#34;&gt;洛谷P1009&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-17\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;高精度加法&lt;/strong&gt;与&lt;strong&gt;高精度乘法&lt;/strong&gt;结合&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-17\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nconst int MAXN = 2e3;\n\nint a[MAXN]= {1},b[MAXN];\n\nvoid plu(int a[],int b[])\n{\n    int more = 0;\n    for(int i = 0; i &amp;lt; 1000; i++)\n    {\n        b[i] += a[i] + more;\n        more = b[i]/10;\n        b[i] %= 10;\n    }\n}\n\nvoid mul(int a[],int b)\n{\n    int more = 0;\n    for(int i = 0; i &amp;lt; 1000; i++)\n    {\n        a[i] = a[i] * b + more;\n        more = a[i]/10;\n        a[i] %= 10;\n    }\n}\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    for(int i = 1; i &amp;lt;= n; i++)\n    {\n        mul(a,i);\n        plu(a,b);\n    }\n\n    int flag = 0;\n    for(int i = 999; i &amp;gt;= 0; i--)\n    {\n        if(b[i])\n            flag = 1;\n        if(flag)\n            printf(&amp;quot;%d&amp;quot;,b[i]);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t18-找筷子\&#34;&gt;T18   找筷子&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1469\&#34;&gt;洛谷P1469&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-18\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;利用位运算异或的性质即可，偶数个相同的数异或结果为0，因而将所有筷子长度异或起来的结果即为落单的筷子的长度。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-18\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    int len,res;\n    for(int i = 0;i &amp;lt; n;i++)\n    {\n        scanf(&amp;quot;%d&amp;quot;,&amp;amp;len);\n        if(i &amp;gt; 0)\n            res ^= len;\n        else if(i == 0)\n            res = len;\n    }\n    printf(&amp;quot;%d&amp;quot;,res);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t19-两只塔姆沃斯牛-the-tamworth-two\&#34;&gt;T19 两只塔姆沃斯牛 The Tamworth Two&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1518\&#34;&gt;洛谷P1518&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-19\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;结构体存储坐标和方向，不断循环即可，若某次移动结束后坐标重合即相遇，输出时间（即循环次数），若循环次数过大时（例10^6次）仍未相遇，即可判定永远不会相遇。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-19\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nchar map[10][10];\n\nstruct farmer\n{\n    int x,y;\n    char dire = &#39;n&#39;;//East South West North\n} f;\n\nstruct cow\n{\n    int x,y;\n    char dire = &#39;n&#39;;\n} c;\n\nint main()\n{\n    for(int i = 0; i &amp;lt; 10; i++)\n        for(int j = 0; j &amp;lt; 10; j++)\n        {\n            scanf(&amp;quot; %c&amp;quot;,&amp;amp;map[i][j]);\n            if(map[i][j] == &#39;F&#39;)\n            {\n                f.x = i;\n                f.y = j;\n            }\n            else if(map[i][j] == &#39;C&#39;)\n            {\n                c.x = i;\n                c.y = j;\n            }\n        }\n\n    int cnt = 0;\n    while(!(f.x == c.x &amp;amp;&amp;amp; f.y == c.y))\n    {\n        switch(f.dire)\n        {\n            case &#39;n&#39;:\n                if(f.x != 0)\n                {\n                    if(map[f.x-1][f.y] != &#39;*&#39;)\n                        f.x--;\n                    else\n                        f.dire = &#39;e&#39;;\n                }\n                else\n                    f.dire = &#39;e&#39;;\n                break;\n            case &#39;e&#39;:\n                if(f.y != 9)\n                {\n                    if(map[f.x][f.y+1] != &#39;*&#39;)\n                        f.y++;\n                    else\n                        f.dire = &#39;s&#39;;\n                }\n                else\n                    f.dire = &#39;s&#39;;\n                break;\n            case &#39;s&#39;:\n                if(f.x != 9)\n                {\n                    if(map[f.x+1][f.y] != &#39;*&#39;)\n                        f.x++;\n                    else\n                        f.dire = &#39;w&#39;;\n                }\n                else\n                    f.dire = &#39;w&#39;;\n                break;\n            case &#39;w&#39;:\n                if(f.y != 0)\n                {\n                    if(map[f.x][f.y-1] != &#39;*&#39;)\n                        f.y--;\n                    else\n                        f.dire = &#39;n&#39;;\n                }\n                else\n                    f.dire = &#39;n&#39;;\n                break;\n        }\n        switch(c.dire)\n        {\n            case &#39;n&#39;:\n                if(c.x != 0)\n                {\n                    if(map[c.x-1][c.y] != &#39;*&#39;)\n                        c.x--;\n                    else\n                        c.dire = &#39;e&#39;;\n                }\n                else\n                    c.dire = &#39;e&#39;;\n                break;\n            case &#39;e&#39;:\n                if(c.y != 9)\n                {\n                    if(map[c.x][c.y+1] != &#39;*&#39;)\n                        c.y++;\n                    else\n                        c.dire = &#39;s&#39;;\n                }\n                else\n                    c.dire = &#39;s&#39;;\n                break;\n            case &#39;s&#39;:\n                if(c.x != 9)\n                {\n                    if(map[c.x+1][c.y] != &#39;*&#39;)\n                        c.x++;\n                    else\n                        c.dire = &#39;w&#39;;\n                }\n                else\n                    c.dire = &#39;w&#39;;\n                break;\n            case &#39;w&#39;:\n                if(c.y != 0)\n                {\n                    if(map[c.x][c.y-1] != &#39;*&#39;)\n                        c.y--;\n                    else\n                        c.dire = &#39;n&#39;;\n                }\n                else\n                    c.dire = &#39;n&#39;;\n                break;\n        }\n        cnt++;\n        if(cnt &amp;gt; 1e6)\n        {\n            printf(&amp;quot;0&amp;quot;);\n            return 0;\n        }\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t20-编码\&#34;&gt;T20 编码&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1246\&#34;&gt;洛谷P1246&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-20\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;暴力枚举判断是否相等即可，要注意字母按升序排列，也就是不可能出现zoo之类的单词&lt;br&gt;\n&lt;s&gt;刚刚才发现我读入字符串写的竟然是scanf(&amp;quot;%s&amp;quot;,&amp;amp;str);竟然还AC了，离谱，编译器之前竟然没报警告&lt;/s&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-20\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;cstring&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int cnt = 1;\n    char str[7],s[7];\n    \n    scanf(&amp;quot;%s&amp;quot;,str);\n    \n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;z&#39;; i++)\n    {\n        s[1] = &#39;\\0&#39;;\n        s[0] = i;\n        if(strcmp(str,s) == 0)\n        {\n            printf(&amp;quot;%d&amp;quot;,cnt);\n            return 0;\n        }\n        cnt++;\n    }\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;y&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;z&#39;; j++)\n        {\n            s[2] = &#39;\\0&#39;;\n            s[1] = j;\n            s[0] = i;\n            if(strcmp(str,s) == 0)\n            {\n                printf(&amp;quot;%d&amp;quot;,cnt);\n                return 0;\n            }\n            cnt++;\n        }\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;x&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;y&#39;; j++)\n            for(char k = j+1; k &amp;lt;= &#39;z&#39;; k++)\n            {\n                s[3] = &#39;\\0&#39;;\n                s[2] = k;\n                s[1] = j;\n                s[0] = i;\n                if(strcmp(str,s) == 0)\n                {\n                    printf(&amp;quot;%d&amp;quot;,cnt);\n                    return 0;\n                }\n                cnt++;\n            }\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;w&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;x&#39;; j++)\n            for(char k = j+1; k &amp;lt;= &#39;y&#39;; k++)\n                for(char q = k+1; q &amp;lt;= &#39;z&#39;; q++)\n                {\n                    s[4] = &#39;\\0&#39;;\n                    s[3] = q;\n                    s[2] = k;\n                    s[1] = j;\n                    s[0] = i;\n                    if(strcmp(str,s) == 0)\n                    {\n                        printf(&amp;quot;%d&amp;quot;,cnt);\n                        return 0;\n                    }\n                    cnt++;\n                }\n\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;v&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;w&#39;; j++)\n            for(char k = j+1; k &amp;lt;= &#39;x&#39;; k++)\n                for(char q = k+1; q &amp;lt;= &#39;y&#39;; q++)\n                    for(char w = q+1; w &amp;lt;= &#39;z&#39;; w++)\n                    {\n                        s[5] = &#39;\\0&#39;;\n                        s[4] = w;\n                        s[3] = q;\n                        s[2] = k;\n                        s[1] = j;\n                        s[0] = i;\n                        if(strcmp(str,s) == 0)\n                        {\n                            printf(&amp;quot;%d&amp;quot;,cnt);\n                            return 0;\n                        }\n                        cnt++;\n                    }\n\n    for(char i = &#39;a&#39;; i &amp;lt;= &#39;u&#39;; i++)\n        for(char j = i+1; j &amp;lt;= &#39;v&#39;; j++)\n            for(char k = j+1; k &amp;lt;= &#39;w&#39;; k++)\n                for(char q = k+1; q &amp;lt;= &#39;x&#39;; q++)\n                    for(char w = q+1; w &amp;lt;= &#39;y&#39;; w++)\n                        for(char e = w+1; e &amp;lt;= &#39;z&#39;; e++)\n                        {\n                            s[6] = &#39;\\0&#39;;\n                            s[5] = e;\n                            s[4] = w;\n                            s[3] = q;\n                            s[2] = k;\n                            s[1] = j;\n                            s[0] = i;\n                            if(strcmp(str,s) == 0)\n                            {\n                                printf(&amp;quot;%d&amp;quot;,cnt);\n                                return 0;\n                            }\n                            cnt++;\n                        }\n    printf(&amp;quot;0&amp;quot;);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t21-帮贡排序\&#34;&gt;T21 帮贡排序&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1786\&#34;&gt;洛谷P1786&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-21\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;按照题意即可，要注意调整职位和输出时的排序方式不同，要写两个cmp函数，调整职位和输出前要分别调用一次sort函数。&lt;br&gt;\n&lt;s&gt;一定要注意职位的大小写，不然一个字母的差别就是全WA与全AC的差别&lt;/s&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-21\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nenum prof\n{\n    BangZhong,JingYing,TangZhu,ZhangLao,HuFa,FuBangZhu,BangZhu\n};\n\nstruct org\n{\n    string name;\n    int pro,con,level,index;\n};\n\nbool cmp1(const org &amp;amp;o1,const org &amp;amp;o2)\n{\n    if(o1.con != o2.con)\n        return o1.con &amp;gt; o2.con;\n    else\n        return o1.index &amp;lt; o2.index;\n}\n\nbool cmp2(const org &amp;amp;o1,const org &amp;amp;o2)\n{\n    if(o1.pro != o2.pro)\n        return o1.pro &amp;gt; o2.pro;\n    else if(o1.level != o2.level)\n        return o1.level &amp;gt; o2.level;\n    else\n        return o1.index &amp;lt; o2.index;\n}\n\nint bz,fbz,hf,zl,tz,jy,baz;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    struct org o[n];\n    for(int i = 0; i &amp;lt; n; i++)\n    {\n        string pr;\n        cin &amp;gt;&amp;gt; o[i].name &amp;gt;&amp;gt; pr;\n        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;o[i].con,&amp;amp;o[i].level);\n        o[i].index = i;\n        if(pr == &amp;quot;BangZhu&amp;quot;)\n            o[i].pro = BangZhu;\n        else if(pr == &amp;quot;FuBangZhu&amp;quot;)\n            o[i].pro = FuBangZhu;\n        else if(pr == &amp;quot;HuFa&amp;quot;)\n            o[i].pro = HuFa;\n        else if(pr == &amp;quot;ZhangLao&amp;quot;)\n            o[i].pro = ZhangLao;\n        else if(pr == &amp;quot;TangZhu&amp;quot;)\n            o[i].pro = TangZhu;\n        else if(pr == &amp;quot;JingYing&amp;quot;)\n            o[i].pro = JingYing;\n        else if(pr == &amp;quot;BangZhong&amp;quot;)\n            o[i].pro = BangZhong;\n    }\n    \n    sort(o,o+n,cmp1);\n    for(int i = 0; i &amp;lt; n; i++)\n    {\n        if(o[i].pro &amp;lt;= HuFa &amp;amp;&amp;amp; o[i].name != &amp;quot;absi2011&amp;quot;)\n        {\n            if(hf &amp;lt; 2)\n            {\n                o[i].pro = HuFa;\n                hf++;\n            }\n            else if(zl &amp;lt; 4)\n            {\n                o[i].pro = ZhangLao;\n                zl++;\n            }\n            else if(tz &amp;lt; 7)\n            {\n                o[i].pro = TangZhu;\n                tz++;\n            }\n            else if(jy &amp;lt; 25)\n            {\n                o[i].pro = JingYing;\n                jy++;\n            }\n            else\n            {\n                o[i].pro = BangZhong;\n                baz++;\n            }\n        }\n    }\n    \n    sort(o,o+n,cmp2);\n    for(auto i:o)\n    {\n        cout &amp;lt;&amp;lt; i.name &amp;lt;&amp;lt; &amp;quot; &amp;quot;;\n        switch(i.pro)\n        {\n            case BangZhu:\n                printf(&amp;quot;BangZhu&amp;quot;);/*打成Bangzhu导致全WA，改正后全AC*/\n                break;\n            case FuBangZhu:\n                printf(&amp;quot;FuBangZhu&amp;quot;);\n                break;\n            case HuFa:\n                printf(&amp;quot;HuFa&amp;quot;);\n                break;\n            case ZhangLao:\n                printf(&amp;quot;ZhangLao&amp;quot;);\n                break;\n            case TangZhu:\n                printf(&amp;quot;TangZhu&amp;quot;);\n                break;\n            case JingYing:\n                printf(&amp;quot;JingYing&amp;quot;);\n                break;\n            case BangZhong:\n                printf(&amp;quot;BangZhong&amp;quot;);\n                break;\n        }\n        printf(&amp;quot; %d\\n&amp;quot;,i.level);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t22-数列找不同\&#34;&gt;T22 数列找不同&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3901\&#34;&gt;洛谷P3901&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-22\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;预处理不断循环找出每个区间内各数互不相同的最长区间，每次固定右端点找出最小左端点，若询问的左端点小于对应的最小左端点即可判断存在相同的数。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-22\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;algorithm&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nconst int MAXN = 1e6;\n\nint num[MAXN],a[MAXN];//num[i]-&amp;gt;以第i个数为右端点时左端点的最小值\n\nint main()\n{\n    int n,q;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;q);\n\n    int k;\n    for(int i = 1; i &amp;lt;= n; i++)\n    {\n        scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);\n        num[i] = max(num[i-1],a[k]+1);\n        a[k] = i;\n    }\n    while(q--)\n    {\n        int l,r;\n        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;l,&amp;amp;r);\n        if(num[r] &amp;lt;= l)\n            printf(&amp;quot;Yes\\n&amp;quot;);\n        else\n            printf(&amp;quot;No\\n&amp;quot;);\n    }\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t23-倒水\&#34;&gt;T23 倒水&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P1582\&#34;&gt;洛谷P1582&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-23\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.luogu.com.cn/problem/solution/P1582\&#34;&gt;&lt;s&gt;洛谷题解里果然都是神犇&lt;/s&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;新增知识点：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;C语言内置函数： __builtin__popcount(); 返回参数在二进制下1的个数&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;复习知识点：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;位运算中 n&amp;amp;-n 表示n在二进制中最后一个1所代表的值&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;因为所有的水都是由两份相同的水合并而成的，因此每瓶水的体积一定是2^i（i ∈ N）升，最后保留k个瓶子，那么最后总的升数的二进制表示中，1的个数一定&amp;lt;=k。&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;合并前&lt;/th&gt;\n&lt;th&gt;二进制&lt;/th&gt;\n&lt;th&gt;合并后&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;1个瓶子&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2个瓶子&lt;/td&gt;\n&lt;td&gt;10&lt;/td&gt;\n&lt;td&gt;2个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;3个瓶子&lt;/td&gt;\n&lt;td&gt;11&lt;/td&gt;\n&lt;td&gt;3个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;4个瓶子&lt;/td&gt;\n&lt;td&gt;100&lt;/td&gt;\n&lt;td&gt;4个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;5个瓶子&lt;/td&gt;\n&lt;td&gt;101&lt;/td&gt;\n&lt;td&gt;5个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;6个瓶子&lt;/td&gt;\n&lt;td&gt;110&lt;/td&gt;\n&lt;td&gt;6个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;7个瓶子&lt;/td&gt;\n&lt;td&gt;111&lt;/td&gt;\n&lt;td&gt;7个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;8个瓶子&lt;/td&gt;\n&lt;td&gt;1000&lt;/td&gt;\n&lt;td&gt;8个瓶子&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;……&lt;/td&gt;\n&lt;td&gt;……&lt;/td&gt;\n&lt;td&gt;……&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;由图显然，n个有水的瓶子，最后合并成的瓶子个数，就是这个数转成二进制1的个数。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-23\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nint main()\n{\n    int n,k,res = 0;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;k);\n    while(__builtin_popcount(n) &amp;gt; k)\n    {\n        res += n&amp;amp;(-n);\n        n += n&amp;amp;(-n);\n    }\n    printf(&amp;quot;%d&amp;quot;,res);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t24-cities-and-states-s\&#34;&gt;T24 Cities and States S&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/P3405\&#34;&gt;洛谷P3405&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-24\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;题目中&lt;strong&gt;特殊的一对&lt;/strong&gt;类似于成对的飞地，显然在一对飞地中，其中一方的CS（City State）代码等于另一方的SC（State City）代码，进而存储一方的CS就可被另一方的SC吻合读取，特殊对数加一。要注意City代码与State代码相等的&lt;s&gt;本地&lt;/s&gt;特殊城市。&lt;/p&gt;\n&lt;h2 id=\&#34;ac代码-24\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;map&amp;gt;\nusing namespace std;\n//typedef long long ll;\n\nmap&amp;lt;string,int&amp;gt; mp;\n\nint main()\n{\n    int n;\n    scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);\n    \n    int cnt = 0;\n    string city,state,cs,sc;\n    for(int i = 0;i &amp;lt; n;i++)\n    {\n        cin &amp;gt;&amp;gt; city &amp;gt;&amp;gt; state;\n        cs = city.substr(0,2) + state;\n        sc = state + city.substr(0,2);\n        cnt += mp[sc];\n        if(cs == sc)\n            cnt -= mp[cs];\n        mp[cs]++;\n    }\n    printf(&amp;quot;%d&amp;quot;,cnt);\n    return 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;t25-dreamoon-and-sets\&#34;&gt;T25 Dreamoon and Sets&lt;/h1&gt;\n&lt;p&gt;题目链接：&lt;a href=\&#34;https://www.luogu.com.cn/problem/CF476D\&#34;&gt;洛谷CF476D&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;题目解析-25\&#34;&gt;题目解析&lt;/h2&gt;\n&lt;p&gt;&lt;s&gt;第一道紫题&lt;/s&gt;&lt;br&gt;\n&lt;s&gt;我觉得我得重读小学二年级&lt;/s&gt;&lt;br&gt;\n枚举失败的我从洛谷题解中获取到了一些奇怪的知识：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;互质的一组数中a,b,c,d的值越接近,就能使最大值越小。&lt;br&gt;\n相邻的两个正整数数是互质的，相邻的两个奇数也是互质的。&lt;br&gt;\n连续n个正整数必有一个数能被n整除，不考虑1,2&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;a,b,c,d互质，所以a,b,c,d中最多有一个偶数 为了让四个数的值更接近，我们不妨先假设有1个偶数，3个奇数。&lt;/li&gt;\n&lt;li&gt;进一步转换，我们可以将a,b,c,d设为x,x+m1,x+m2,x+m3.&lt;/li&gt;\n&lt;li&gt;因此我们先尝试令m1=1,m2=2,即四元组中前三个数为x,x+1,x+2。由于四元组中最多只有一个偶数，故x为奇数，根据以上易证的结论可知这三个数一定互质。&lt;/li&gt;\n&lt;li&gt;考虑x是奇数，那么(x,x+1,x+2,x+4)&lt;strong&gt;一定&lt;/strong&gt;满足要求，且不能更小。考虑x是偶数，那么(x,x+1,x+3,x+5)&lt;strong&gt;不一定&lt;/strong&gt;满足要求，而且不能更小。显然x取奇数时是最优的。&lt;/li&gt;\n&lt;li&gt;最大数为 (n*6-1)*k&lt;/li&gt;\n&lt;li&gt;第一个数从1开始选，同时要保证所以四元组的第一个数为基数，每隔6个确定一个x就好了。x的通项公式即为(i-1)*6+1&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;ac代码-25\&#34;&gt;AC代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;\nusing namespace std;\n\nint main()\n{\n    int n,k;\n    scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;k);\n    printf(&amp;quot;%d\\n&amp;quot;,(n*6-1) * k);\n    for(int i = 1;i &amp;lt;= n;i++)\n    {\n        int num = (i-1)*6+1;\n        printf(&amp;quot;%d %d %d %d\\n&amp;quot;,num*k,(num+1)*k,(num+2)*k,(num+4)*k);\n    }\n    return 0;\n}&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;han-jia-hui-gui-da-li-bao-ti-jie&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;时间跨度：01-04 17:46:10 - 01-06 23:01:46&lt;/p&gt;\n&lt;p&gt;关键知识点：&lt;strong&gt;高精度&lt;/strong&gt;，斐波那契数列&lt;/p&gt;\n&lt;p&gt;部分新增知识点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;C语言内置函数__builtin__popcount();&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;数字之间的关系&lt;/strong&gt;，&lt;strong&gt;质数的性质&lt;/strong&gt;（数论？）&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;title&#34;:&#34;寒假回归大礼包题解&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-01-06 23:03:13&#34;,&#34;dateFormat&#34;:&#34;2021-01-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://czyx007.top/post/han-jia-hui-gui-da-li-bao-ti-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;34 min read&#34;,&#34;time&#34;:2005000,&#34;words&#34;:6542,&#34;minutes&#34;:34},&#34;description&#34;:&#34;时间跨度：01-04 17:46:10 - 01-06 23:01:46\n关键知识点：高精度，斐波那契数列\n部分新增知识点：\n\nC语言内置函数__builtin__popcount();\n数字之间的关系，质数的性质（数论？）\n\n\nT1 标题...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#t1-%E6%A0%87%E9%A2%98%E7%BB%9F%E8%AE%A1\&#34;&gt;T1 标题统计&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t2-davor\&#34;&gt;T2 Davor&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-2\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t3-%E8%AF%AD%E5%8F%A5%E8%A7%A3%E6%9E%90\&#34;&gt;T3 语句解析&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-3\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-3\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t4-%E6%95%B0%E6%A5%BC%E6%A2%AF\&#34;&gt;T4 数楼梯&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-4\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-4\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t5-%E5%88%86%E6%95%B0%E7%BA%BF%E5%88%92%E5%AE%9A\&#34;&gt;T5 分数线划定&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-5\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-5\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t6-%E6%B6%82%E5%9B%BD%E6%97%97\&#34;&gt;T6 涂国旗&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-6\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-6\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t7-%E6%8B%BC%E6%95%B0\&#34;&gt;T7 拼数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-7\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-7\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t8-%E7%83%A4%E9%B8%A1\&#34;&gt;T8 烤鸡&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-8\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-8\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t9-%E7%8B%AC%E6%9C%A8%E6%A1%A5\&#34;&gt;T9 独木桥&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-9\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-9\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t10-first-step-%E3%83%95%E3%82%A1%E3%83%BC%E3%82%B9%E3%83%88%E3%82%B9%E3%83%86%E3%83%83%E3%83%97\&#34;&gt;T10 First Step (ファーストステップ)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-10\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-10\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t11-%E8%9C%9C%E8%9C%82%E8%B7%AF%E7%BA%BF\&#34;&gt;T11 蜜蜂路线&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-11\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-11\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t12-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E9%97%AE%E9%A2%98\&#34;&gt;T12 最大公约数和最小公倍数问题&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-12\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-12\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t13-%E7%A7%8D%E7%94%B0\&#34;&gt;T13 种田&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-13\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-13\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t14-%E6%B7%B7%E5%90%88%E7%89%9B%E5%A5%B6-mixing-milk\&#34;&gt;T14 混合牛奶 Mixing Milk&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-14\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-14\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t15-%E6%8E%92%E9%98%9F\&#34;&gt;T15 排队&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-15\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-15\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t16-%E5%B0%8Fa%E7%9A%84%E7%B3%96%E6%9E%9C\&#34;&gt;T16 小A的糖果&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-16\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-16\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t17-%E9%98%B6%E4%B9%98%E4%B9%8B%E5%92%8C\&#34;&gt;T17 阶乘之和&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-17\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-17\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t18-%E6%89%BE%E7%AD%B7%E5%AD%90\&#34;&gt;T18   找筷子&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-18\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-18\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t19-%E4%B8%A4%E5%8F%AA%E5%A1%94%E5%A7%86%E6%B2%83%E6%96%AF%E7%89%9B-the-tamworth-two\&#34;&gt;T19 两只塔姆沃斯牛 The Tamworth Two&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-19\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-19\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t20-%E7%BC%96%E7%A0%81\&#34;&gt;T20 编码&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-20\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-20\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t21-%E5%B8%AE%E8%B4%A1%E6%8E%92%E5%BA%8F\&#34;&gt;T21 帮贡排序&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-21\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-21\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t22-%E6%95%B0%E5%88%97%E6%89%BE%E4%B8%8D%E5%90%8C\&#34;&gt;T22 数列找不同&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-22\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-22\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t23-%E5%80%92%E6%B0%B4\&#34;&gt;T23 倒水&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-23\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-23\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t24-cities-and-states-s\&#34;&gt;T24 Cities and States S&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-24\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-24\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#t25-dreamoon-and-sets\&#34;&gt;T25 Dreamoon and Sets&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-25\&#34;&gt;题目解析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ac%E4%BB%A3%E7%A0%81-25\&#34;&gt;AC代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;本站使用Gridea博客系统，由vercel提供访问加速，在此感谢。&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀​&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://qm.qq.com/cgi-bin/qm/qr?k=I2jkn0dziL9o-T2Xcm7NG16jZzvoP7fy&amp;amp;noverify=0\&#34;&gt;QQ：1029606625&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;https://github.com/zyx006\&#34;&gt;Github：zyx006&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-01-01 17:14:11&#34;,&#34;dateFormat&#34;:&#34;2021-01-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://czyx007.top/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:10000,&#34;words&#34;:48,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n本站使用Gridea博客系统，由vercel提供访问加速，在此感谢。\n📬 联系我呀​\nQQ：1029606625\nGithub：zyx006\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀​&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;⌘  Command&lt;br&gt;\n⇧  Shift&lt;br&gt;\n⇪  CapsLock&lt;br&gt;\n⌥  Option&lt;br&gt;\n⌃  Control&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;↩  Return/Enter&lt;br&gt;\n⌫  Delete&lt;br&gt;\n⌦  向前删除键(Fn + Delete)&lt;br&gt;\n↑  上箭头&lt;br&gt;\n↓  下箭头&lt;br&gt;\n←  左箭头&lt;br&gt;\n→  右箭头&lt;br&gt;\n⇞  PageUp(Fn + ↑)&lt;br&gt;\n⇟  PageDown(Fn + ↓)&lt;br&gt;\nHome  Fn + ←&lt;br&gt;\nEnd  Fn + →&lt;br&gt;\n⇥  右制表符(Tpb键)&lt;br&gt;\n⇤  左制表符(Shift + Tpb)&lt;br&gt;\n⎋  Escape(Esc)&lt;/p&gt;\n&lt;h2 id=\&#34;searchreplace查询替换\&#34;&gt;Search/Replace(查询/替换)&lt;/h2&gt;\n&lt;p&gt;Double Shift(⇧)  查询任何东西&lt;br&gt;\nCommand(⌘) + F  文件内查找&lt;br&gt;\nCommand(⌘) + G  查找模式下，向下查找&lt;br&gt;\nCommand(⌘) + Shift(⇧) + G  查找模式下，向上查找&lt;br&gt;\nCommand(⌘) + R  文件内替换&lt;br&gt;\nCommand(⌘) + Shift(⇧) + F  全局查找(根据路径)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + R  全局替换(根据路径)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + S  查询结构(Ultimate Edition 版专用，需要在Keymap中设置)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + M  替换结构(Ultimate Edition 版专用，需要在Keymap中设置)&lt;/p&gt;\n&lt;h2 id=\&#34;usage-search使用查询\&#34;&gt;Usage Search(使用查询)&lt;/h2&gt;\n&lt;p&gt;Option(⌥) + F7 / Command(⌘) + F7  在文件中查找用法 / 在类中查找用法&lt;br&gt;\nCommand(⌘) + Shift(⇧) + F7  在文件中突出显示的用法&lt;br&gt;\nCommand(⌘) + Option(⌥) + F7  显示用法&lt;/p&gt;\n&lt;h2 id=\&#34;compile-and-run编译和运行\&#34;&gt;Compile and Run(编译和运行)&lt;/h2&gt;\n&lt;p&gt;Command(⌘) + F  编译Project&lt;br&gt;\nCommand(⌘) + Shift(⇧) + F9  编译选择的文件、包或模块&lt;br&gt;\nControl(⌃) + Option(⌥) + R  弹出 Run 的可选择菜单&lt;br&gt;\nControl(⌃) + Option(⌥) + D  弹出 Debug 的可选择菜单&lt;br&gt;\nControl(⌃) + R  运行&lt;br&gt;\nControl(⌃) + D  调试&lt;br&gt;\nControl(⌃) + Shift(⇧) + R, Control(⌃) + Shift(⇧) + D  从编辑器运行上下文环境配置&lt;/p&gt;\n&lt;h2 id=\&#34;通用\&#34;&gt;通用&lt;/h2&gt;\n&lt;p&gt;Command(⌘) + C  复制&lt;br&gt;\nCommand(⌘) + V  粘贴&lt;/p&gt;\n&lt;h3 id=\&#34;剪切\&#34;&gt;   剪切&lt;/h3&gt;\n&lt;p&gt;   Step 1:Command(⌘) + C  复制&lt;br&gt;\n   Step 2:在需要转移的文件夹位置使用Command(⌘) + Option(⌥) + V。(如果操作后悔了，还可以 Command(⌘) + Z 撤销。)&lt;/p&gt;\n&lt;p&gt;Command(⌘) + A  全选&lt;br&gt;\nCommand(⌘) + S  保存&lt;br&gt;\nCommand(⌘) + F  查找(Find)&lt;br&gt;\nCommand(⌘) + M  最小化窗口&lt;br&gt;\nCommand(⌘) + N  新建文件&lt;br&gt;\nCommand(⌘) + O  打开&lt;br&gt;\nCommand(⌘) + H  隐藏窗口&lt;br&gt;\nCommand(⌘) + Shift(⇧) + S  另存&lt;br&gt;\nCommand(⌘) + W  关闭&lt;br&gt;\nCommand(⌘) + Q  退出&lt;br&gt;\nCommand(⌘) + Z  撤销(如果是safari浏览器，就是恢复刚关闭的页面)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + Z  重做，也就是撤销的逆向操作&lt;br&gt;\nCommand(⌘) + Option(⌥) + Esc  强制退出程序(类似于window下的任务管理器)&lt;br&gt;\n自带的输入法(Capslock 短按中英文切换，长按英文大写)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + 4  截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口&lt;br&gt;\nCommand(⌘) + Delete  将文件移至废纸篓(Windows键盘是 Win + Backspace)&lt;br&gt;\nCommand(⌘) + Shift(⇧) + Delete  清倒废纸篓(Windows键盘是 Win + Shift + Backspace)&lt;br&gt;\nSpace  快速查看选中的文件，也就是预览功能&lt;br&gt;\nCommand(⌘) + ↑  打开包含当前文件夹的文件夹，相当于Windows里的“向上”&lt;br&gt;\nCommand(⌘) + Tab  在应用程序间切换(应用处于打开且在桌面的情况)&lt;/p&gt;\n&lt;h2 id=\&#34;浏览器\&#34;&gt;浏览器&lt;/h2&gt;\n&lt;p&gt;Command(⌘) + L  光标直接跳至地址栏(可能被Windows响应锁屏)&lt;br&gt;\nCommand(⌘) + &#39;+&#39; / &#39;=&#39;  放大页面&lt;br&gt;\nCommand(⌘) + &#39;-&#39;  缩小页面&lt;br&gt;\nControl(⌃) + Tab  转向下一个标签页&lt;br&gt;\nControl(⌃) + Shift(⇧) + Tab  转向上一个标签页&lt;br&gt;\nCommand(⌘) + R  刷新&lt;br&gt;\nCommand(⌘) + T  新建一个选项卡&lt;br&gt;\nPageDown  向下滚动屏幕&lt;br&gt;\nPageUp  向上滚动屏幕&lt;br&gt;\n按下箭头键 向上、向下、向左或向右滚动&lt;br&gt;\n按下箭头键时按住Option(⌥)键大幅度滚动&lt;br&gt;\nenter即回车  重命名&lt;br&gt;\nCommand(⌘) + 鼠标点击  多选不连续的文件或文件夹&lt;/p&gt;\n&lt;h2 id=\&#34;其他\&#34;&gt;其他&lt;/h2&gt;\n&lt;p&gt;选中多个连续的文件或文件夹&lt;br&gt;\n按住Shift(⇧)键不放，使用鼠标依次点击(或按住鼠标后拖动)希望选择的文件或者文件夹即可&lt;br&gt;\n文件可以右键重命名&lt;br&gt;\n如果桌面的文件不对齐排列，可以右键整理&lt;br&gt;\nShift(⇧) + Command(⌘) + C  打开“电脑”窗口&lt;br&gt;\n文件右键有一个“制作替身”，相当于新建一个快捷方式&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;⌘  Command&lt;br&gt;\n⇧  Shift&lt;br&gt;\n⇪  CapsLock&lt;br&gt;\n⌥  Option&lt;br&gt;\n⌃  Control&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Mac键盘符号和快捷键说明&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-11-14 17:41:52&#34;,&#34;dateFormat&#34;:&#34;2020-11-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://czyx007.top/post/mac-jian-pan-fu-hao-he-kuai-jie-jian-shuo-ming/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:197000,&#34;words&#34;:824,&#34;minutes&#34;:4},&#34;description&#34;:&#34;⌘  Command\n⇧  Shift\n⇪  CapsLock\n⌥  Option\n⌃  Control\n\n↩  Return/Enter\n⌫  Delete\n⌦  向前删除键(Fn + Delete)\n↑  上箭头\n↓  下箭头\n←  左...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#searchreplace%E6%9F%A5%E8%AF%A2%E6%9B%BF%E6%8D%A2\&#34;&gt;Search/Replace(查询/替换)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#usage-search%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2\&#34;&gt;Usage Search(使用查询)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#compile-and-run%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C\&#34;&gt;Compile and Run(编译和运行)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E7%94%A8\&#34;&gt;通用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%AA%E5%88%87\&#34;&gt;   剪切&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%8F%E8%A7%88%E5%99%A8\&#34;&gt;浏览器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B6%E4%BB%96\&#34;&gt;其他&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/love.js"></script>


</html>